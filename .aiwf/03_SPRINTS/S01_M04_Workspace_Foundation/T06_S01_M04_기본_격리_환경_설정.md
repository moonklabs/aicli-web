# T06_S01_M04_ê¸°ë³¸_ê²©ë¦¬_í™˜ê²½_ì„¤ì •

**íƒœìŠ¤í¬ ID**: T06_S01_M04  
**ì œëª©**: ê¸°ë³¸ ê²©ë¦¬ í™˜ê²½ ì„¤ì •  
**ì„¤ëª…**: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë³„ ê¸°ë³¸ì ì¸ ë³´ì•ˆ ë° ë¦¬ì†ŒìŠ¤ ê²©ë¦¬ í™˜ê²½ ì„¤ì •  
**ìš°ì„ ìˆœìœ„**: ì¤‘ê°„  
**ë³µì¡ë„**: ë‚®ìŒ  
**ì˜ˆìƒ ì†Œìš”ì‹œê°„**: 3-4ì‹œê°„  
**ìƒíƒœ**: completed  
**ì‹œì‘ ì‹œê°„**: 2025-07-22 17:00  
**ì™„ë£Œ ì‹œê°„**: 2025-07-22 19:30  

## ğŸ“‹ ì‘ì—… ê°œìš”

ì›Œí¬ìŠ¤í˜ì´ìŠ¤ê°„ ê²©ë¦¬ì„±ì„ ìœ„í•œ ê¸°ë³¸ì ì¸ ë³´ì•ˆ ì„¤ì •ê³¼ ë¦¬ì†ŒìŠ¤ ì œí•œì„ êµ¬í˜„í•©ë‹ˆë‹¤. ê° ì›Œí¬ìŠ¤í˜ì´ìŠ¤ê°€ ë…ë¦½ëœ í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ì‹¤í–‰ë˜ë„ë¡ í•˜ì—¬ ì‹œìŠ¤í…œ ë³´ì•ˆê³¼ ì•ˆì •ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.

## ğŸ¯ ëª©í‘œ

1. **ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬**: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ê°„ ë„¤íŠ¸ì›Œí¬ ë¶„ë¦¬ ë° ì ‘ê·¼ ì œí•œ
2. **ë¦¬ì†ŒìŠ¤ ì œí•œ**: CPU, ë©”ëª¨ë¦¬, ë””ìŠ¤í¬ I/O ì‚¬ìš©ëŸ‰ ì œí•œ
3. **ê¶Œí•œ ê´€ë¦¬**: ì»¬í…Œì´ë„ˆ ë‚´ë¶€ ì‚¬ìš©ì ê¶Œí•œ ìµœì†Œí™”
4. **ë³´ì•ˆ ì •ì±…**: ì‹œìŠ¤í…œ í˜¸ì¶œ ì œí•œ ë° ë³´ì•ˆ ì˜µì…˜ ì ìš©
5. **ëª¨ë‹ˆí„°ë§**: ë³´ì•ˆ ì´ë²¤íŠ¸ ë° ë¹„ì •ìƒ í–‰ìœ„ ê°ì§€

## ğŸ“‚ ì½”ë“œë² ì´ìŠ¤ ë¶„ì„

### ì˜ì¡´ì„±
- `T02_S01_M04`: Docker SDK ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸ (ë„¤íŠ¸ì›Œí¬ ì„¤ì •)
- `T03_S01_M04`: ì»¬í…Œì´ë„ˆ ìƒëª…ì£¼ê¸° ê´€ë¦¬ì (ë³´ì•ˆ ì„¤ì • ì ìš©)
- `T04_S01_M04`: ë§ˆìš´íŠ¸ ì‹œìŠ¤í…œ (ê¶Œí•œ ê´€ë¦¬)

### ê¸°ì¡´ ë³´ì•ˆ ì„¤ì •
```go
// Docker í´ë¼ì´ì–¸íŠ¸ ê¸°ë³¸ ë³´ì•ˆ ì„¤ì •
type Config struct {
    SecurityOpts []string `yaml:"security_opts" json:"security_opts"`
    Privileged   bool     `yaml:"privileged" json:"privileged"`
    ReadOnly     bool     `yaml:"read_only" json:"read_only"`
}
```

### êµ¬í˜„ ìœ„ì¹˜
```
internal/docker/
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ isolation.go     # ê²©ë¦¬ ì„¤ì • ê´€ë¦¬ì (ìƒˆë¡œ ìƒì„±)
â”‚   â”œâ”€â”€ limits.go        # ë¦¬ì†ŒìŠ¤ ì œí•œ (ìƒˆë¡œ ìƒì„±)
â”‚   â”œâ”€â”€ network.go       # ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬ (ìƒˆë¡œ ìƒì„±)
â”‚   â””â”€â”€ monitor.go       # ë³´ì•ˆ ëª¨ë‹ˆí„° (ìƒˆë¡œ ìƒì„±)
â””â”€â”€ policies/            # ë³´ì•ˆ ì •ì±… íŒŒì¼ë“¤
    â”œâ”€â”€ seccomp.json     # Seccomp í”„ë¡œíŒŒì¼
    â””â”€â”€ apparmor.conf    # AppArmor í”„ë¡œíŒŒì¼
```

## ğŸ› ï¸ ê¸°ìˆ  ê°€ì´ë“œ

### 1. ê²©ë¦¬ ì„¤ì • ê´€ë¦¬ì

```go
// internal/docker/security/isolation.go
package security

import (
    "context"
    "fmt"
    "strings"
    
    "github.com/docker/docker/api/types/container"
    "github.com/aicli/aicli-web/internal/models"
)

type IsolationManager struct {
    config *IsolationConfig
}

type IsolationConfig struct {
    // ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬
    EnableNetworkIsolation bool                  `yaml:"enable_network_isolation" json:"enable_network_isolation"`
    AllowedNetworks       []string              `yaml:"allowed_networks" json:"allowed_networks"`
    BlockedPorts          []int                 `yaml:"blocked_ports" json:"blocked_ports"`
    
    // ë¦¬ì†ŒìŠ¤ ì œí•œ
    DefaultCPULimit       float64               `yaml:"default_cpu_limit" json:"default_cpu_limit"`
    DefaultMemoryLimit    int64                 `yaml:"default_memory_limit" json:"default_memory_limit"`
    DefaultDiskLimit      int64                 `yaml:"default_disk_limit" json:"default_disk_limit"`
    
    // ë³´ì•ˆ ì„¤ì •
    EnableSeccomp         bool                  `yaml:"enable_seccomp" json:"enable_seccomp"`
    EnableAppArmor        bool                  `yaml:"enable_apparmor" json:"enable_apparmor"`
    DisablePrivileged     bool                  `yaml:"disable_privileged" json:"disable_privileged"`
    
    // íŒŒì¼ ì‹œìŠ¤í…œ ë³´ì•ˆ
    ReadOnlyRootFS        bool                  `yaml:"read_only_root_fs" json:"read_only_root_fs"`
    NoNewPrivileges       bool                  `yaml:"no_new_privileges" json:"no_new_privileges"`
    
    // ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§
    EnableAuditLog        bool                  `yaml:"enable_audit_log" json:"enable_audit_log"`
    MonitorSystemCalls    bool                  `yaml:"monitor_system_calls" json:"monitor_system_calls"`
}

func NewIsolationManager() *IsolationManager {
    return &IsolationManager{
        config: DefaultIsolationConfig(),
    }
}

func DefaultIsolationConfig() *IsolationConfig {
    return &IsolationConfig{
        // ë„¤íŠ¸ì›Œí¬ ê¸°ë³¸ê°’
        EnableNetworkIsolation: true,
        AllowedNetworks:        []string{"aicli-network"},
        BlockedPorts:           []int{22, 80, 443, 3000, 8000, 8080},
        
        // ë¦¬ì†ŒìŠ¤ ê¸°ë³¸ ì œí•œ
        DefaultCPULimit:        1.0,    // 1 CPU
        DefaultMemoryLimit:     512 * 1024 * 1024, // 512MB
        DefaultDiskLimit:       1024 * 1024 * 1024, // 1GB
        
        // ë³´ì•ˆ ê¸°ë³¸ ì„¤ì •
        EnableSeccomp:          true,
        EnableAppArmor:         true,
        DisablePrivileged:      true,
        ReadOnlyRootFS:         false, // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ëŠ” ì“°ê¸° ê°€ëŠ¥
        NoNewPrivileges:        true,
        
        // ëª¨ë‹ˆí„°ë§ ê¸°ë³¸ ì„¤ì •
        EnableAuditLog:         true,
        MonitorSystemCalls:     false, // ì„±ëŠ¥ ìƒ ê¸°ë³¸ ë¹„í™œì„±í™”
    }
}

// ì›Œí¬ìŠ¤í˜ì´ìŠ¤ìš© ê²©ë¦¬ ì„¤ì • ìƒì„±
func (im *IsolationManager) CreateWorkspaceIsolation(workspace *models.Workspace) (*WorkspaceIsolation, error) {
    isolation := &WorkspaceIsolation{
        WorkspaceID:      workspace.ID,
        NetworkMode:      "custom",
        NetworkName:      fmt.Sprintf("aicli-workspace-%s", workspace.ID),
        IsolationLevel:   IsolationLevelStandard,
        ResourceLimits:   im.createResourceLimits(),
        SecurityOptions:  im.createSecurityOptions(),
        MonitoringConfig: im.createMonitoringConfig(),
    }
    
    return isolation, nil
}

type WorkspaceIsolation struct {
    WorkspaceID      string                 `json:"workspace_id"`
    NetworkMode      string                 `json:"network_mode"`
    NetworkName      string                 `json:"network_name"`
    IsolationLevel   IsolationLevel         `json:"isolation_level"`
    ResourceLimits   *ResourceLimits        `json:"resource_limits"`
    SecurityOptions  *SecurityOptions       `json:"security_options"`
    MonitoringConfig *MonitoringConfig      `json:"monitoring_config"`
}

type IsolationLevel string

const (
    IsolationLevelBasic     IsolationLevel = "basic"     // ê¸°ë³¸ ê²©ë¦¬
    IsolationLevelStandard  IsolationLevel = "standard"  // í‘œì¤€ ê²©ë¦¬
    IsolationLevelStrict    IsolationLevel = "strict"    // ì—„ê²©í•œ ê²©ë¦¬
)

type ResourceLimits struct {
    CPUShares        int64  `json:"cpu_shares"`        // CPU ê°€ì¤‘ì¹˜
    CPUQuota         int64  `json:"cpu_quota"`         // CPU í• ë‹¹ëŸ‰
    CPUPeriod        int64  `json:"cpu_period"`        // CPU ì£¼ê¸°
    Memory           int64  `json:"memory"`            // ë©”ëª¨ë¦¬ ì œí•œ
    MemorySwap       int64  `json:"memory_swap"`       // Swap ì œí•œ
    PidsLimit        int64  `json:"pids_limit"`        // í”„ë¡œì„¸ìŠ¤ ìˆ˜ ì œí•œ
    IOMaxBandwidth   string `json:"io_max_bandwidth"`  // I/O ëŒ€ì—­í­ ì œí•œ
    IOMaxIOps        int64  `json:"io_max_iops"`       // I/O ì†ë„ ì œí•œ
}

type SecurityOptions struct {
    SeccompProfile   string   `json:"seccomp_profile"`   // Seccomp í”„ë¡œíŒŒì¼
    AppArmorProfile  string   `json:"apparmor_profile"`  // AppArmor í”„ë¡œíŒŒì¼
    SELinuxLabels    []string `json:"selinux_labels"`    // SELinux ë ˆì´ë¸”
    Capabilities     *CapabilityConfig `json:"capabilities"` // ì»´í”¼í„°ë¸”ë¦¬í‹°
    NoNewPrivileges  bool     `json:"no_new_privileges"` // ìƒˆ ê¶Œí•œ ê¸ˆì§€
    ReadOnlyRootFS   bool     `json:"read_only_root_fs"` // ë£¨íŠ¸ FS ì½ê¸°ì „ìš©
}

type CapabilityConfig struct {
    Drop []string `json:"drop"` // ì œê±°í•  capability
    Add  []string `json:"add"`  // ì¶”ê°€í•  capability
}

type MonitoringConfig struct {
    EnableResourceMonitoring bool     `json:"enable_resource_monitoring"`
    EnableNetworkMonitoring  bool     `json:"enable_network_monitoring"`
    EnableFileSystemAudit    bool     `json:"enable_filesystem_audit"`
    LogLevel                 string   `json:"log_level"`
    AlertThresholds          *AlertThresholds `json:"alert_thresholds"`
}

type AlertThresholds struct {
    CPUThreshold     float64 `json:"cpu_threshold"`      // CPU ì‚¬ìš©ë¥  ê²½ê³  ì„ê³„ê°’
    MemoryThreshold  float64 `json:"memory_threshold"`   // ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ê²½ê³  ì„ê³„ê°’
    NetworkThreshold int64   `json:"network_threshold"`  // ë„¤íŠ¸ì›Œí¬ I/O ê²½ê³  ì„ê³„ê°’
    DiskThreshold    int64   `json:"disk_threshold"`     // ë””ìŠ¤í¬ I/O ê²½ê³  ì„ê³„ê°’
}
```

### 2. ë¦¬ì†ŒìŠ¤ ì œí•œ ê´€ë¦¬

```go
// internal/docker/security/limits.go
package security

import (
    "github.com/docker/docker/api/types/container"
)

type ResourceManager struct {
    config *IsolationConfig
}

func NewResourceManager(config *IsolationConfig) *ResourceManager {
    return &ResourceManager{config: config}
}

func (rm *ResourceManager) createResourceLimits() *ResourceLimits {
    return &ResourceLimits{
        CPUShares:        1024, // ê¸°ë³¸ ê°€ì¤‘ì¹˜
        CPUQuota:         int64(rm.config.DefaultCPULimit * 100000),
        CPUPeriod:        100000,
        Memory:           rm.config.DefaultMemoryLimit,
        MemorySwap:       rm.config.DefaultMemoryLimit, // Swap ë¹„í™œì„±í™”
        PidsLimit:        100, // ìµœëŒ€ 100ê°œ í”„ë¡œì„¸ìŠ¤
        IOMaxBandwidth:   "100m", // 100MB/s
        IOMaxIOps:        1000,    // 1000 IOPS
    }
}

// Docker container.Resourcesë¡œ ë³€í™˜
func (rm *ResourceManager) ToDockerResources(limits *ResourceLimits) container.Resources {
    return container.Resources{
        CPUShares:  limits.CPUShares,
        CPUQuota:   limits.CPUQuota,
        CPUPeriod:  limits.CPUPeriod,
        Memory:     limits.Memory,
        MemorySwap: limits.MemorySwap,
        PidsLimit:  &limits.PidsLimit,
        
        // Block I/O ì œí•œ
        BlkioWeight: 500, // ê¸°ë³¸ I/O ê°€ì¤‘ì¹˜
        
        // Device cgroup rules
        DeviceCgroupRules: []string{
            "c 1:3 rmw",   // /dev/null ì ‘ê·¼ í—ˆìš©
            "c 1:5 rmw",   // /dev/zero ì ‘ê·¼ í—ˆìš©
            "c 1:9 rmw",   // /dev/urandom ì ‘ê·¼ í—ˆìš©
            "c 136:* rmw", // PTY ì ‘ê·¼ í—ˆìš©
        },
    }
}

// ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ê²€ì‚¬
func (rm *ResourceManager) ValidateResourceUsage(metrics *WorkspaceMetrics) []ResourceViolation {
    var violations []ResourceViolation
    
    // CPU ì‚¬ìš©ë¥  ê²€ì‚¬
    if metrics.CPUPercent > 90.0 {
        violations = append(violations, ResourceViolation{
            Type:        "cpu_high_usage",
            Threshold:   90.0,
            Current:     metrics.CPUPercent,
            Description: "CPU usage exceeded 90%",
            Severity:    "warning",
        })
    }
    
    // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê²€ì‚¬
    memoryPercent := float64(metrics.MemoryUsage) / float64(metrics.MemoryLimit) * 100
    if memoryPercent > 85.0 {
        violations = append(violations, ResourceViolation{
            Type:        "memory_high_usage",
            Threshold:   85.0,
            Current:     memoryPercent,
            Description: "Memory usage exceeded 85%",
            Severity:    "warning",
        })
    }
    
    return violations
}

type ResourceViolation struct {
    Type        string  `json:"type"`
    Threshold   float64 `json:"threshold"`
    Current     float64 `json:"current"`
    Description string  `json:"description"`
    Severity    string  `json:"severity"` // info, warning, error, critical
}
```

### 3. ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬ ê´€ë¦¬

```go
// internal/docker/security/network.go
package security

import (
    "context"
    "fmt"
    "net"
    
    "github.com/docker/docker/api/types"
    "github.com/docker/docker/api/types/network"
    "github.com/docker/go-connections/nat"
    "github.com/aicli/aicli-web/internal/docker"
)

type NetworkManager struct {
    client *docker.Client
    config *IsolationConfig
}

func NewNetworkManager(client *docker.Client, config *IsolationConfig) *NetworkManager {
    return &NetworkManager{
        client: client,
        config: config,
    }
}

// ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì „ìš© ë„¤íŠ¸ì›Œí¬ ìƒì„±
func (nm *NetworkManager) CreateWorkspaceNetwork(workspaceID string) (*NetworkInfo, error) {
    networkName := fmt.Sprintf("aicli-workspace-%s", workspaceID)
    
    // CIDR ëŒ€ì—­ í• ë‹¹ (172.20.x.0/24 ëŒ€ì—­ ì‚¬ìš©)
    subnet := nm.allocateSubnet(workspaceID)
    
    networkConfig := types.NetworkCreate{
        Name:       networkName,
        Driver:     "bridge",
        Internal:   false, // ì™¸ë¶€ ì¸í„°ë„· ì ‘ê·¼ í—ˆìš©
        Attachable: false, // ë‹¤ë¥¸ ì»¬í…Œì´ë„ˆ ì—°ê²° ê¸ˆì§€
        IPAM: &network.IPAM{
            Driver: "default",
            Config: []network.IPAMConfig{
                {
                    Subnet:  subnet,
                    Gateway: nm.getGatewayIP(subnet),
                },
            },
        },
        Options: map[string]string{
            "com.docker.network.bridge.name": networkName,
            "com.docker.network.driver.mtu":  "1500",
        },
        Labels: map[string]string{
            "aicli.workspace.id":   workspaceID,
            "aicli.managed":        "true",
            "aicli.isolation":      "workspace",
        },
    }
    
    resp, err := nm.client.NetworkCreate(context.Background(), networkName, networkConfig)
    if err != nil {
        return nil, fmt.Errorf("create workspace network: %w", err)
    }
    
    return &NetworkInfo{
        ID:          resp.ID,
        Name:        networkName,
        WorkspaceID: workspaceID,
        Subnet:      subnet,
        Gateway:     nm.getGatewayIP(subnet),
        Isolated:    true,
    }, nil
}

type NetworkInfo struct {
    ID          string `json:"id"`
    Name        string `json:"name"`
    WorkspaceID string `json:"workspace_id"`
    Subnet      string `json:"subnet"`
    Gateway     string `json:"gateway"`
    Isolated    bool   `json:"isolated"`
}

func (nm *NetworkManager) allocateSubnet(workspaceID string) string {
    // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ IDì—ì„œ í•´ì‹œë¥¼ ìƒì„±í•˜ì—¬ ê³ ìœ í•œ ì„œë¸Œë„· í• ë‹¹
    // ì˜ˆ: 172.20.1.0/24, 172.20.2.0/24, ...
    hash := nm.hashWorkspaceID(workspaceID)
    octet := (hash % 254) + 1 // 1-254 ë²”ìœ„
    return fmt.Sprintf("172.20.%d.0/24", octet)
}

func (nm *NetworkManager) getGatewayIP(subnet string) string {
    _, network, err := net.ParseCIDR(subnet)
    if err != nil {
        return "" // ì—ëŸ¬ ì²˜ë¦¬
    }
    
    // ê²Œì´íŠ¸ì›¨ì´ëŠ” ë„¤íŠ¸ì›Œí¬ì˜ ì²« ë²ˆì§¸ IP (.1)
    ip := network.IP
    ip[len(ip)-1] = 1
    return ip.String()
}

func (nm *NetworkManager) hashWorkspaceID(workspaceID string) int {
    hash := 0
    for _, char := range workspaceID {
        hash = (hash*31 + int(char)) % 1000
    }
    return hash
}

// í¬íŠ¸ ë§¤í•‘ ì œí•œ ê²€ì‚¬
func (nm *NetworkManager) ValidatePortMapping(portMap map[string]string) error {
    for hostPort, containerPort := range portMap {
        hostPortNum, err := nat.NewPort("tcp", hostPort)
        if err != nil {
            return fmt.Errorf("invalid host port %s: %w", hostPort, err)
        }
        
        // ì°¨ë‹¨ëœ í¬íŠ¸ ê²€ì‚¬
        if nm.isPortBlocked(hostPortNum.Int()) {
            return fmt.Errorf("port %s is blocked by security policy", hostPort)
        }
        
        // ì»¬í…Œì´ë„ˆ í¬íŠ¸ ê²€ì¦
        _, err = nat.NewPort("tcp", containerPort)
        if err != nil {
            return fmt.Errorf("invalid container port %s: %w", containerPort, err)
        }
    }
    
    return nil
}

func (nm *NetworkManager) isPortBlocked(port int) bool {
    for _, blockedPort := range nm.config.BlockedPorts {
        if port == blockedPort {
            return true
        }
    }
    return false
}

// ë„¤íŠ¸ì›Œí¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
func (nm *NetworkManager) MonitorNetworkUsage(ctx context.Context, networkID string) (<-chan *NetworkStats, error) {
    statsChan := make(chan *NetworkStats, 10)
    
    go func() {
        defer close(statsChan)
        
        // ë„¤íŠ¸ì›Œí¬ í†µê³„ ìˆ˜ì§‘ ë¡œì§
        // Docker APIì—ì„œ ë„¤íŠ¸ì›Œí¬ í†µê³„ ìˆ˜ì§‘
    }()
    
    return statsChan, nil
}

type NetworkStats struct {
    NetworkID     string    `json:"network_id"`
    RxBytes       int64     `json:"rx_bytes"`
    TxBytes       int64     `json:"tx_bytes"`
    RxPackets     int64     `json:"rx_packets"`
    TxPackets     int64     `json:"tx_packets"`
    ConnectionCount int     `json:"connection_count"`
    Timestamp     time.Time `json:"timestamp"`
}
```

### 4. ë³´ì•ˆ ëª¨ë‹ˆí„°ë§

```go
// internal/docker/security/monitor.go
package security

import (
    "context"
    "fmt"
    "time"
)

type SecurityMonitor struct {
    config     *IsolationConfig
    alertChan  chan SecurityAlert
    violations map[string][]ResourceViolation
}

type SecurityAlert struct {
    Type        AlertType `json:"type"`
    WorkspaceID string    `json:"workspace_id"`
    Severity    string    `json:"severity"`
    Message     string    `json:"message"`
    Timestamp   time.Time `json:"timestamp"`
    Data        interface{} `json:"data,omitempty"`
}

type AlertType string

const (
    AlertTypeResourceViolation AlertType = "resource_violation"
    AlertTypeSecurityBreach    AlertType = "security_breach"
    AlertTypeNetworkAnomaly    AlertType = "network_anomaly"
    AlertTypeProcessAnomaly    AlertType = "process_anomaly"
)

func NewSecurityMonitor(config *IsolationConfig) *SecurityMonitor {
    return &SecurityMonitor{
        config:     config,
        alertChan:  make(chan SecurityAlert, 100),
        violations: make(map[string][]ResourceViolation),
    }
}

func (sm *SecurityMonitor) StartMonitoring(ctx context.Context) <-chan SecurityAlert {
    go sm.monitoringLoop(ctx)
    return sm.alertChan
}

func (sm *SecurityMonitor) monitoringLoop(ctx context.Context) {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    defer close(sm.alertChan)
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            sm.performSecurityCheck()
        }
    }
}

func (sm *SecurityMonitor) performSecurityCheck() {
    // ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ê²€ì‚¬
    // ë„¤íŠ¸ì›Œí¬ í™œë™ ê°ì‹œ
    // ë¹„ì •ìƒ í”„ë¡œì„¸ìŠ¤ ê°ì§€
    // íŒŒì¼ ì‹œìŠ¤í…œ ì ‘ê·¼ ëª¨ë‹ˆí„°ë§
}

// ë³´ì•ˆ ì´ë²¤íŠ¸ ë³´ê³ 
func (sm *SecurityMonitor) ReportViolation(workspaceID string, violation ResourceViolation) {
    sm.violations[workspaceID] = append(sm.violations[workspaceID], violation)
    
    alert := SecurityAlert{
        Type:        AlertTypeResourceViolation,
        WorkspaceID: workspaceID,
        Severity:    violation.Severity,
        Message:     fmt.Sprintf("Resource violation detected: %s", violation.Description),
        Timestamp:   time.Now(),
        Data:        violation,
    }
    
    select {
    case sm.alertChan <- alert:
    default:
        // ì±„ë„ì´ ê°€ë“ ì°¬ ê²½ìš° ìƒˆë¡œìš´ ì•Œë¦¼ ë²„ë¦¬ê³  ë¡œê¹…
    }
}

// ë³´ì•ˆ ì •ì±… ìœ„ë°˜ ìë™ ëŒ€ì‘
func (sm *SecurityMonitor) HandleSecurityBreach(workspaceID string, breach SecurityBreach) {
    switch breach.Type {
    case "privilege_escalation":
        sm.handlePrivilegeEscalation(workspaceID, breach)
    case "suspicious_network_activity":
        sm.handleNetworkAnomaly(workspaceID, breach)
    case "unauthorized_file_access":
        sm.handleFileAccessViolation(workspaceID, breach)
    default:
        sm.handleGenericBreach(workspaceID, breach)
    }
}

type SecurityBreach struct {
    Type        string      `json:"type"`
    Description string      `json:"description"`
    Evidence    interface{} `json:"evidence"`
    RiskLevel   string      `json:"risk_level"`
}

func (sm *SecurityMonitor) handlePrivilegeEscalation(workspaceID string, breach SecurityBreach) {
    // ê¶Œí•œ ìƒìŠ¹ ì‹œë„ ê°ì§€ ì‹œ ëŒ€ì‘
    // 1. ì»¬í…Œì´ë„ˆ ì¼ì‹œ ì¤‘ì§€
    // 2. ê´€ë¦¬ì ì•Œë¦¼
    // 3. ë³´ì•ˆ ë¡œê·¸ ê¸°ë¡
}

// ë³´ì•ˆ ëŒ€ì‹œë³´ë“œ ë°ì´í„°
func (sm *SecurityMonitor) GetSecurityDashboard() *SecurityDashboard {
    return &SecurityDashboard{
        TotalAlerts:       len(sm.alertChan),
        CriticalAlerts:    sm.countAlertsBySeverity("critical"),
        WarningAlerts:     sm.countAlertsBySeverity("warning"),
        ViolationSummary:  sm.getViolationSummary(),
        LastUpdated:       time.Now(),
    }
}

type SecurityDashboard struct {
    TotalAlerts      int                         `json:"total_alerts"`
    CriticalAlerts   int                         `json:"critical_alerts"`
    WarningAlerts    int                         `json:"warning_alerts"`
    ViolationSummary map[string]int              `json:"violation_summary"`
    LastUpdated      time.Time                   `json:"last_updated"`
}

func (sm *SecurityMonitor) countAlertsBySeverity(severity string) int {
    // ì‹¬ê°ë„ë³„ ì•Œë¦¼ ìˆ˜ ì§‘ê³„
    return 0
}

func (sm *SecurityMonitor) getViolationSummary() map[string]int {
    summary := make(map[string]int)
    for _, violations := range sm.violations {
        for _, violation := range violations {
            summary[violation.Type]++
        }
    }
    return summary
}
```

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [ ] ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë³„ ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬ ë° ì „ìš© ì„œë¸Œë„· í• ë‹¹
- [ ] CPU, ë©”ëª¨ë¦¬, ë””ìŠ¤í¬ I/O ë¦¬ì†ŒìŠ¤ ì œí•œ ì ìš©
- [ ] Seccomp, AppArmor ë“± ë³´ì•ˆ í”„ë¡œíŒŒì¼ ì ìš©
- [ ] ì»¬í…Œì´ë„ˆ ê¶Œí•œ ìµœì†Œí™” ë° ë³´ì•ˆ ì˜µì…˜ ì„¤ì •
- [ ] ë³´ì•ˆ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ

### ë¹„ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [ ] ê²©ë¦¬ ì„¤ì • ì ìš© ì‹œê°„ < 2ì´ˆ
- [ ] ë¦¬ì†ŒìŠ¤ ì œí•œ ìœ„ë°˜ ê°ì§€ < 30ì´ˆ
- [ ] ë³´ì•ˆ ì•Œë¦¼ ì „ë‹¬ ì§€ì—° < 5ì´ˆ
- [ ] ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬ íš¨ê³¼ 100% (ì»¬í…Œì´ë„ˆê°„ í†µì‹  ì°¨ë‹¨)

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### 1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```go
func TestIsolationManager_CreateWorkspaceIsolation(t *testing.T) {
    manager := NewIsolationManager()
    
    workspace := &models.Workspace{
        ID:   "test-workspace",
        Name: "Test Workspace",
    }
    
    isolation, err := manager.CreateWorkspaceIsolation(workspace)
    
    assert.NoError(t, err)
    assert.Equal(t, IsolationLevelStandard, isolation.IsolationLevel)
    assert.NotNil(t, isolation.ResourceLimits)
    assert.NotNil(t, isolation.SecurityOptions)
}

func TestNetworkManager_ValidatePortMapping(t *testing.T) {
    config := DefaultIsolationConfig()
    manager := NewNetworkManager(nil, config)
    
    // ìœ íš¨í•œ í¬íŠ¸ ë§¤í•‘
    validPorts := map[string]string{"8888": "8080"}
    err := manager.ValidatePortMapping(validPorts)
    assert.NoError(t, err)
    
    // ì°¨ë‹¨ëœ í¬íŠ¸
    blockedPorts := map[string]string{"22": "22"}
    err = manager.ValidatePortMapping(blockedPorts)
    assert.Error(t, err)
}
```

### 2. í†µí•© í…ŒìŠ¤íŠ¸
- ì‹¤ì œ ì»¬í…Œì´ë„ˆì—ì„œ ë¦¬ì†ŒìŠ¤ ì œí•œ íš¨ê³¼ ê²€ì¦
- ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬ íš¨ê³¼ í…ŒìŠ¤íŠ¸ (ì»¬í…Œì´ë„ˆê°„ í†µì‹  ì°¨ë‹¨)
- ë³´ì•ˆ ì •ì±… ìœ„ë°˜ ì‹œ ìë™ ëŒ€ì‘ í…ŒìŠ¤íŠ¸

## ğŸ“ êµ¬í˜„ ë‹¨ê³„

1. **Phase 1**: ê²©ë¦¬ ì„¤ì • ê´€ë¦¬ì ë° ê¸°ë³¸ êµ¬ì¡° (1ì‹œê°„)
2. **Phase 2**: ë¦¬ì†ŒìŠ¤ ì œí•œ ë° ëª¨ë‹ˆí„°ë§ (1ì‹œê°„)
3. **Phase 3**: ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬ ë° ë³´ì•ˆ ì„¤ì • (1ì‹œê°„)
4. **Phase 4**: ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ (0.5ì‹œê°„)
5. **Phase 5**: í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ê²€ì¦ (0.5ì‹œê°„)

## ğŸ”— ì—°ê´€ íƒœìŠ¤í¬

- **ì˜ì¡´ì„±**: T02_S01_M04 (ë„¤íŠ¸ì›Œí¬), T03_S01_M04 (ë³´ì•ˆ ì„¤ì •), T04_S01_M04 (ê¶Œí•œ)
- **í›„ì† ì‘ì—…**: T07_S01_M04 (API í†µí•© - ë³´ì•ˆ ì„¤ì • ì œê³µ)
- **ë™ì‹œ ì§„í–‰**: T05_S01_M04 (ìƒíƒœ ì¶”ì  - ë³´ì•ˆ ëª¨ë‹ˆí„°ë§)

## ğŸ“š ì°¸ê³  ìë£Œ

- [Docker Security](https://docs.docker.com/engine/security/)
- [Container Resource Limits](https://docs.docker.com/config/containers/resource_constraints/)
- [Docker Network Security](https://docs.docker.com/network/security/)
- [Seccomp Security Profiles](https://docs.docker.com/engine/security/seccomp/)
- [AppArmor Security Profiles](https://docs.docker.com/engine/security/apparmor/)