# T04_S01_M04_í”„ë¡œì íŠ¸_ë””ë ‰í† ë¦¬_ë§ˆìš´íŠ¸_ì‹œìŠ¤í…œ

**íƒœìŠ¤í¬ ID**: T04_S01_M04  
**ì œëª©**: í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ë§ˆìš´íŠ¸ ì‹œìŠ¤í…œ  
**ì„¤ëª…**: ë¡œì»¬ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¥¼ ì•ˆì „í•˜ê²Œ Docker ë³¼ë¥¨ìœ¼ë¡œ ë§ˆìš´íŠ¸í•˜ëŠ” ì‹œìŠ¤í…œ êµ¬í˜„  
**ìš°ì„ ìˆœìœ„**: ë†’ìŒ  
**ë³µì¡ë„**: ë³´í†µ  
**ì˜ˆìƒ ì†Œìš”ì‹œê°„**: 4-5ì‹œê°„  
**ìƒíƒœ**: completed  
**ì‹œì‘ ì‹œê°„**: 2025-01-23 14:30:00  
**ì™„ë£Œ ì‹œê°„**: 2025-01-23 18:00:00  

## ğŸ“‹ ì‘ì—… ê°œìš”

ë¡œì»¬ íŒŒì¼ ì‹œìŠ¤í…œì˜ í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¥¼ ì»¬í…Œì´ë„ˆ ë‚´ë¶€ì˜ ì‘ì—… ë””ë ‰í† ë¦¬ë¡œ ì•ˆì „í•˜ê²Œ ë§ˆìš´íŠ¸í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤. íŒŒì¼ ê¶Œí•œ, ë³´ì•ˆ, ë™ê¸°í™” ë¬¸ì œë¥¼ í•´ê²°í•˜ê³  ì•ˆì •ì ì¸ íŒŒì¼ ì ‘ê·¼ì„ ë³´ì¥í•©ë‹ˆë‹¤.

## ğŸ¯ ëª©í‘œ

1. **ì•ˆì „í•œ ë§ˆìš´íŠ¸**: íŒŒì¼ ê¶Œí•œ ë° ë³´ì•ˆ ê²€ì‚¬
2. **ê²½ë¡œ ê²€ì¦**: í”„ë¡œì íŠ¸ ê²½ë¡œ ìœ íš¨ì„± ë° ì ‘ê·¼ ê¶Œí•œ í™•ì¸
3. **ë™ê¸°í™” ìµœì í™”**: íŒŒì¼ ë³€ê²½ ì‚¬í•­ ì‹¤ì‹œê°„ ë°˜ì˜
4. **ë°±ì—… ë° ë³µêµ¬**: ë¶ˆí•„ìš”í•œ ë³€ê²½ìœ¼ë¡œë¶€í„° ì›ë³¸ ë³´í˜¸
5. **ì„±ëŠ¥ ìµœì í™”**: ë¹ ë¥¸ íŒŒì¼ I/O ì„±ëŠ¥ ë³´ì¥

## ğŸ“‚ ì½”ë“œë² ì´ìŠ¤ ë¶„ì„

### ì˜ì¡´ì„±
- `T03_S01_M04`: ì»¬í…Œì´ë„ˆ ìƒëª…ì£¼ê¸° ê´€ë¦¬ì (ë§ˆìš´íŠ¸ ì„¤ì •ì— í™œìš©)
- `internal/utils/validator.go`: ê¸°ì¡´ ê²½ë¡œ ê²€ì¦ ë¡œì§
- `internal/models/workspace.go`: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ëª¨ë¸ (ProjectPath í•„ë“œ)

### êµ¬í˜„ ìœ„ì¹˜
```
internal/docker/
â”œâ”€â”€ mount/
â”‚   â”œâ”€â”€ manager.go       # ë§ˆìš´íŠ¸ ê´€ë¦¬ì (ìƒˆë¡œ ìƒì„±)
â”‚   â”œâ”€â”€ validator.go     # ê²½ë¡œ ë° ê¶Œí•œ ê²€ì¦ (ìƒˆë¡œ ìƒì„±)
â”‚   â””â”€â”€ sync.go          # ë™ê¸°í™” ë§¤ë‹ˆì € (ìƒˆë¡œ ìƒì„±)
â””â”€â”€ volume.go            # ë³¼ë¥¨ ê´€ë¦¬ (ìƒˆë¡œ ìƒì„±)
```

## ğŸ› ï¸ ê¸°ìˆ  ê°€ì´ë“œ

### 1. ë§ˆìš´íŠ¸ ê´€ë¦¬ì êµ¬ì¡°

```go
// internal/docker/mount/manager.go
package mount

import (
    "context"
    "fmt"
    "os"
    "path/filepath"
    "strings"
    "time"
    
    "github.com/docker/docker/api/types/mount"
    "github.com/aicli/aicli-web/internal/models"
)

type Manager struct {
    validator *Validator
    syncer    *Syncer
}

func NewManager() *Manager {
    return &Manager{
        validator: NewValidator(),
        syncer:    NewSyncer(),
    }
}

type MountConfig struct {
    // ê²½ë¡œ ì„¤ì •
    SourcePath      string            `json:"source_path"`      // ë¡œì»¬ í”„ë¡œì íŠ¸ ê²½ë¡œ
    TargetPath      string            `json:"target_path"`      // ì»¬í…Œì´ë„ˆ ë‚´ë¶€ ê²½ë¡œ
    
    // ê¶Œí•œ ì„¤ì •
    ReadOnly        bool              `json:"read_only"`        // ì½ê¸° ì „ìš© ë§ˆìš´íŠ¸
    UserID          int               `json:"user_id"`          // ë§ˆìš´íŠ¸ ì†Œìœ ì UID
    GroupID         int               `json:"group_id"`         // ë§ˆìš´íŠ¸ ê·¸ë£¹ GID
    
    // ë™ê¸°í™” ì˜µì…˜
    SyncMode        SyncMode          `json:"sync_mode"`        // ë™ê¸°í™” ëª¨ë“œ
    ExcludePatterns []string          `json:"exclude_patterns"` // ì œì™¸ íŒ¨í„´
    IncludePatterns []string          `json:"include_patterns"` // í¬í•¨ íŒ¨í„´
    
    // ë³´ì•ˆ ì„¤ì •
    NoExec          bool              `json:"no_exec"`          // ì‹¤í–‰ ê¶Œí•œ ì œê±°
    NoSuid          bool              `json:"no_suid"`          // SUID ë¹„íŠ¸ ë¬´ì‹œ
    NoDev           bool              `json:"no_dev"`           // ë””ë°”ì´ìŠ¤ íŒŒì¼ ì ‘ê·¼ ì°¨ë‹¨
}

type SyncMode string

const (
    SyncModeNative     SyncMode = "native"     // ê¸°ë³¸ Docker ë§ˆìš´íŠ¸
    SyncModeOptimized  SyncMode = "optimized"  // ì„±ëŠ¥ ìµœì í™” ëª¨ë“œ
    SyncModeCached     SyncMode = "cached"     // ì«€ì‹œ ëª¨ë“œ
    SyncModeDelegated  SyncMode = "delegated"  // ìœ„ì„ ëª¨ë“œ
)

// ì›Œí¬ìŠ¤í˜ì´ìŠ¤ìš© ë§ˆìš´íŠ¸ ì„¤ì • ìƒì„±
func (m *Manager) CreateWorkspaceMount(workspace *models.Workspace) (*MountConfig, error) {
    // ê²½ë¡œ ê²€ì¦
    if err := m.validator.ValidateProjectPath(workspace.ProjectPath); err != nil {
        return nil, fmt.Errorf("invalid project path: %w", err)
    }
    
    // ì ˆëŒ€ ê²½ë¡œ ë³€í™˜
    absPath, err := filepath.Abs(workspace.ProjectPath)
    if err != nil {
        return nil, fmt.Errorf("resolve absolute path: %w", err)
    }
    
    config := &MountConfig{
        SourcePath:      absPath,
        TargetPath:      "/workspace",
        ReadOnly:        false, // ê¸°ë³¸ì ìœ¼ë¡œ ì“°ê¸° ê°€ëŠ¥
        UserID:          1000,  // ë¹„íŠ¹ê¶Œ ì‚¬ìš©ì
        GroupID:         1000,  // ë¹„íŠ¹ê¶Œ ê·¸ë£¹
        SyncMode:        SyncModeNative,
        NoExec:          false,
        NoSuid:          true,  // ë³´ì•ˆìƒ SUID ë¹„í™œì„±í™”
        NoDev:           true,  // ë””ë°”ì´ìŠ¤ íŒŒì¼ ì ‘ê·¼ ì°¨ë‹¨
        ExcludePatterns: m.getDefaultExcludePatterns(),
    }
    
    return config, nil
}

func (m *Manager) getDefaultExcludePatterns() []string {
    return []string{
        // VCS ë””ë ‰í† ë¦¬
        ".git",
        ".svn",
        ".hg",
        
        // IDE íŒŒì¼
        ".vscode",
        ".idea",
        "*.swp",
        "*.swo",
        
        // ë¹Œë“œ ê²°ê³¼ë¬¼
        "node_modules",
        "dist",
        "build",
        "target",
        "*.log",
        
        // ì„ì‹œ íŒŒì¼
        "*.tmp",
        "*.temp",
        ".DS_Store",
        "Thumbs.db",
    }
}
```

### 2. ê²½ë¡œ ë° ê¶Œí•œ ê²€ì¦

```go
// internal/docker/mount/validator.go
package mount

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"
    "syscall"
)

type Validator struct{}

func NewValidator() *Validator {
    return &Validator{}
}

// í”„ë¡œì íŠ¸ ê²½ë¡œ ìœ íš¨ì„± ê²€ì‚¬
func (v *Validator) ValidateProjectPath(path string) error {
    if path == "" {
        return fmt.Errorf("project path is required")
    }
    
    // ì ˆëŒ€ ê²½ë¡œë¡œ ë³€í™˜
    absPath, err := filepath.Abs(path)
    if err != nil {
        return fmt.Errorf("resolve absolute path: %w", err)
    }
    
    // ë””ë ‰í† ë¦¬ ì¡´ì¬ í™•ì¸
    info, err := os.Stat(absPath)
    if err != nil {
        if os.IsNotExist(err) {
            return fmt.Errorf("project directory does not exist: %s", absPath)
        }
        return fmt.Errorf("stat project directory: %w", err)
    }
    
    if !info.IsDir() {
        return fmt.Errorf("project path is not a directory: %s", absPath)
    }
    
    // ì ‘ê·¼ ê¶Œí•œ í™•ì¸
    if err := v.checkAccess(absPath); err != nil {
        return fmt.Errorf("access check failed: %w", err)
    }
    
    // ë³´ì•ˆ ê²€ì‚¬
    if err := v.checkSecurity(absPath); err != nil {
        return fmt.Errorf("security check failed: %w", err)
    }
    
    return nil
}

func (v *Validator) checkAccess(path string) error {
    // ì½ê¸° ê¶Œí•œ í™•ì¸
    if err := syscall.Access(path, syscall.R_OK); err != nil {
        return fmt.Errorf("no read permission: %s", path)
    }
    
    // ì“°ê¸° ê¶Œí•œ í™•ì¸ (ì„ íƒì )
    if err := syscall.Access(path, syscall.W_OK); err != nil {
        // ê²½ê³ ë§Œ ì¶œë ¥, ì—ëŸ¬ëŠ” ì•„ë‹˜
        // ì½ê¸° ì „ìš©ìœ¼ë¡œ ë§ˆìš´íŠ¸ë  ê°€ëŠ¥ì„±ì´ ìˆìŒ
    }
    
    return nil
}

func (v *Validator) checkSecurity(path string) error {
    // ì‹œìŠ¤í…œ ë£¨íŠ¸ ë””ë ‰í† ë¦¬ ë§ˆìš´íŠ¸ ë°©ì§€
    systemPaths := []string{
        "/",
        "/etc",
        "/usr",
        "/bin",
        "/sbin",
        "/boot",
        "/sys",
        "/proc",
        "/dev",
    }
    
    absPath, _ := filepath.Abs(path)
    for _, sysPath := range systemPaths {
        if strings.HasPrefix(absPath, sysPath) {
            return fmt.Errorf("cannot mount system directory: %s", absPath)
        }
    }
    
    // Docker ì†Œì¼“ ë§ˆìš´íŠ¸ ë°©ì§€
    dockerSocket := "/var/run/docker.sock"
    if strings.Contains(absPath, dockerSocket) {
        return fmt.Errorf("cannot mount docker socket path: %s", absPath)
    }
    
    // ì‹¬ë³¼ë¦­ ë§í¬ ê²€ì‚¬
    if err := v.checkSymlinks(absPath); err != nil {
        return err
    }
    
    return nil
}

func (v *Validator) checkSymlinks(path string) error {
    // ì‹¬ë³¼ë¦­ ë§í¬ì¸ ê²½ìš° ì‹¤ì œ ê²½ë¡œ í™•ì¸
    realPath, err := filepath.EvalSymlinks(path)
    if err != nil {
        return fmt.Errorf("eval symlinks: %w", err)
    }
    
    // ì‹¤ì œ ê²½ë¡œê°€ ì˜ˆìƒ ê²½ë¡œì™€ ë‹¤ë¥¸ ê²½ìš° ê²½ê³ 
    if realPath != path {
        // ì‹¬ë³¼ë¦­ ë§í¬ë¥¼ í—ˆìš©í•˜ì§€ë§Œ ë³´ì•ˆ ê²€ì‚¬ëŠ” ìˆ˜í–‰
        return v.checkSecurity(realPath)
    }
    
    return nil
}

// ê¸°ì¡´ ë§ˆìš´íŠ¸ ìµœì í™” ê°€ëŠ¥ì„± ê²€ì‚¬
func (v *Validator) CanOptimizeMount(path string) (bool, SyncMode) {
    // íŒŒì¼ ì‹œìŠ¤í…œ íƒ€ì…ì— ë”°ë¥¸ ìµœì í™”
    var stat syscall.Statfs_t
    if err := syscall.Statfs(path, &stat); err != nil {
        return false, SyncModeNative
    }
    
    // ë§ˆìš´íŠ¸ í¬ì¸íŠ¸ ë¶„ì„ ë“±ì„ í†µí•œ ì„±ëŠ¥ ìµœì í™” ë°©ì‹ ê²°ì •
    switch stat.Type {
    case 0x58465342: // XFS
        return true, SyncModeOptimized
    case 0xEF53:     // EXT4
        return true, SyncModeCached
    default:
        return false, SyncModeNative
    }
}
```

### 3. Docker ë§ˆìš´íŠ¸ ìƒì„±

```go
// Docker Mount ê°ì²´ë¡œ ë³€í™˜
func (m *Manager) ToDockerMount(config *MountConfig) mount.Mount {
    mountObj := mount.Mount{
        Type:   mount.TypeBind,
        Source: config.SourcePath,
        Target: config.TargetPath,
        BindOptions: &mount.BindOptions{
            Propagation: mount.PropagationRPrivate,
        },
    }
    
    // ì½ê¸° ì „ìš© ì„¤ì •
    if config.ReadOnly {
        mountObj.ReadOnly = true
    }
    
    // ë™ê¸°í™” ëª¨ë“œ ì„¤ì •
    consistency := m.syncModeToConsistency(config.SyncMode)
    if consistency != "" {
        mountObj.Consistency = mount.Consistency(consistency)
    }
    
    // tmpfs ì˜µì…˜ (Linux ì „ìš©)
    if config.NoExec || config.NoSuid || config.NoDev {
        tmpfsOpts := make(map[string]string)
        
        if config.NoExec {
            tmpfsOpts["noexec"] = ""
        }
        if config.NoSuid {
            tmpfsOpts["nosuid"] = ""
        }
        if config.NoDev {
            tmpfsOpts["nodev"] = ""
        }
        
        mountObj.BindOptions.CreateMountpoint = true
    }
    
    return mountObj
}

func (m *Manager) syncModeToConsistency(mode SyncMode) string {
    switch mode {
    case SyncModeCached:
        return "cached"
    case SyncModeDelegated:
        return "delegated"
    default:
        return "" // native/optimizedëŠ” ê¸°ë³¸ ì¼ê´€ì„± ì‚¬ìš©
    }
}
```

### 4. ë™ê¸°í™” ë§¤ë‹ˆì €

```go
// internal/docker/mount/sync.go
package mount

import (
    "context"
    "path/filepath"
    "strings"
    "time"
)

type Syncer struct {
    watchInterval time.Duration
}

func NewSyncer() *Syncer {
    return &Syncer{
        watchInterval: 5 * time.Second,
    }
}

type SyncStatus struct {
    LastSync      time.Time `json:"last_sync"`
    FilesChanged  int       `json:"files_changed"`
    SyncDuration  string    `json:"sync_duration"`
    Errors        []string  `json:"errors,omitempty"`
}

// íŒŒì¼ ë³€ê²½ ì‚¬í•­ ì‹¤ì‹œê°„ ê°ì‹œ (ì„ íƒì )
func (s *Syncer) WatchChanges(ctx context.Context, sourcePath string, callback func([]string)) error {
    // íŒŒì¼ ì‹œìŠ¤í…œ ê°ì‹œ ë¡œì§
    // inotify (Linux) ë˜ëŠ” ë‹¤ë¥¸ í”Œë«í¼ ë“±ê°€ ì‚¬ìš©
    // ì¼ë‹¨ ê¸°ë³¸ì ì¸ í´ë§ ê¸°ë°˜ êµ¬í˜„
    
    ticker := time.NewTicker(s.watchInterval)
    defer ticker.Stop()
    
    var lastModTime time.Time
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-ticker.C:
            changes, modTime, err := s.scanForChanges(sourcePath, lastModTime)
            if err != nil {
                continue // ì—ëŸ¬ ë°´ìƒ ì‹œ ê³„ì† ëª¨ë‹ˆí„°ë§
            }
            
            if len(changes) > 0 && callback != nil {
                callback(changes)
            }
            lastModTime = modTime
        }
    }
}

func (s *Syncer) scanForChanges(rootPath string, since time.Time) ([]string, time.Time, error) {
    var changes []string
    var latestModTime time.Time
    
    err := filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return nil // ê°œë³„ íŒŒì¼ ì—ëŸ¬ëŠ” ë¬´ì‹œ
        }
        
        // ì œì™¸ íŒ¨í„´ ê²€ì‚¬
        if s.shouldExclude(path, rootPath) {
            if info.IsDir() {
                return filepath.SkipDir
            }
            return nil
        }
        
        // ë³€ê²½ ì‹œê°„ í™•ì¸
        modTime := info.ModTime()
        if modTime.After(since) {
            relPath, _ := filepath.Rel(rootPath, path)
            changes = append(changes, relPath)
        }
        
        if modTime.After(latestModTime) {
            latestModTime = modTime
        }
        
        return nil
    })
    
    return changes, latestModTime, err
}

func (s *Syncer) shouldExclude(path, rootPath string) bool {
    relPath, err := filepath.Rel(rootPath, path)
    if err != nil {
        return true
    }
    
    // ê¸°ë³¸ ì œì™¸ íŒ¨í„´ í™•ì¸
    excludePatterns := []string{
        ".git/*",
        "node_modules/*",
        "*.tmp",
        "*.log",
        ".DS_Store",
    }
    
    for _, pattern := range excludePatterns {
        if matched, _ := filepath.Match(pattern, relPath); matched {
            return true
        }
        // ë””ë ‰í† ë¦¬ íŒ¨í„´ ì²˜ë¦¬
        if strings.Contains(relPath, strings.TrimSuffix(pattern, "/*")) {
            return true
        }
    }
    
    return false
}

// ë§ˆìš´íŠ¸ ìƒíƒœ í™•ì¸
func (s *Syncer) CheckMountStatus(containerID string, mountPath string) (*SyncStatus, error) {
    // Docker APIë¥¼ í†µí•´ ë§ˆìš´íŠ´ ìƒíƒœ í™•ì¸
    // ì˜ˆ: ë§ˆìš´íŠ´ ì§€ì ì˜ íŒŒì¼ ìˆ˜, ì²¨ê·¼ ì‹œê°„ ë“±
    
    status := &SyncStatus{
        LastSync:     time.Now(),
        FilesChanged: 0,
        SyncDuration: "0ms",
    }
    
    return status, nil
}
```

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [x] í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ì•ˆì „ ê²€ì¦ ë° ë§ˆìš´íŠ¸
- [x] ê¶Œí•œ ë° ë³´ì•ˆ ì„¤ì • ì ìš©
- [x] ë™ê¸°í™” ëª¨ë“œ ë° ì„±ëŠ¥ ìµœì í™”
- [x] ì œì™¸ íŒ¨í„´ ë° í•„í„°ë§
- [x] ë§ˆìš´íŠ´ ìƒíƒœ ëª¨ë‹ˆí„°ë§

### ë¹„ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [x] ë§ˆìš´íŠ¸ ì‹œê°„ < 1ì´ˆ
- [x] íŒŒì¼ I/O ì„±ëŠ¥ ì €í•˜ < 10%
- [x] ì•ˆì „ ê²€ì¦ ì‹œê°„ < 500ms
- [x] ëŒ€ìš©ëŸ‰ ë””ë ‰í† ë¦¬ ì§€ì› (> 10GB)

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### 1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```go
func TestValidator_ValidateProjectPath(t *testing.T) {
    validator := NewValidator()
    
    // ìœ íš¨í•œ ê²½ë¡œ í…ŒìŠ¤íŠ¸
    tempDir := t.TempDir()
    err := validator.ValidateProjectPath(tempDir)
    assert.NoError(t, err)
    
    // ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ë¡œ í…ŒìŠ¤íŠ¸
    err = validator.ValidateProjectPath("/etc")
    assert.Error(t, err)
}

func TestManager_CreateWorkspaceMount(t *testing.T) {
    manager := NewManager()
    
    workspace := &models.Workspace{
        ProjectPath: t.TempDir(),
    }
    
    config, err := manager.CreateWorkspaceMount(workspace)
    
    assert.NoError(t, err)
    assert.Equal(t, "/workspace", config.TargetPath)
    assert.True(t, config.NoSuid)
}
```

### 2. í†µí•© í…ŒìŠ¤íŠ¸
- ì‹¤ì œ ì»¬í…Œì´ë„ˆì—ì„œ ë§ˆìš´íŠ¸ í…ŒìŠ¤íŠ¸
- íŒŒì¼ ë° ë””ë ‰í† ë¦¬ ìƒì„±/ìˆ˜ì •/ì‚­ì œ ê²€ì¦
- ê¶Œí•œ ì œí•œ íš¨ê³¼ í…ŒìŠ¤íŠ¸

## ğŸ“ êµ¬í˜„ ë‹¨ê³„

1. **Phase 1**: ê²½ë¡œ ê²€ì¦ ë° ë³´ì•ˆ ê²€ì‚¬ (1.5ì‹œê°„)
2. **Phase 2**: ë§ˆìš´íŠ¸ ê´€ë¦¬ì ë° ì„¤ì • (1.5ì‹œê°„)
3. **Phase 3**: Docker ë§ˆìš´íŠ¸ í†µí•© (1ì‹œê°„)
4. **Phase 4**: ë™ê¸°í™” ë§¤ë‹ˆì € ë° ëª¨ë‹ˆí„°ë§ (1ì‹œê°„)
5. **Phase 5**: í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ê²€ì¦ (1ì‹œê°„)

## ğŸ”— ì—°ê´€ íƒœìŠ¤í¬

- **ì˜ì¡´ì„±**: T03_S01_M04 (ì»¬í…Œì´ë„ˆ ìƒëª…ì£¼ê¸° - ë§ˆìš´íŠ¸ ì„¤ì •)
- **í›„ì† ì‘ì—…**: T05_S01_M04 (ìƒíƒœ ì¶”ì  - ë§ˆìš´íŠ¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§)
- **ë™ì‹œ ì§„í–‰**: T06_S01_M04 (ê²©ë¦¬ í™˜ê²½ - ë³´ì•ˆ ì„¤ì •)

## ğŸ“š ì°¸ê³  ìë£Œ

- [Docker Bind Mounts](https://docs.docker.com/storage/bind-mounts/)
- [Docker Volume ë³´ì•ˆ](https://docs.docker.com/engine/security/)
- [Linux File Permissions](https://www.linux.com/training-tutorials/understanding-linux-file-permissions/)
- [Container Mount Performance](https://docs.docker.com/docker-for-mac/osxfs-caching/)