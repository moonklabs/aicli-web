# T05_S01_M04_ì›Œí¬ìŠ¤í˜ì´ìŠ¤_ìƒíƒœ_ì¶”ì _ì‹œìŠ¤í…œ

**íƒœìŠ¤í¬ ID**: T05_S01_M04  
**ì œëª©**: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒíƒœ ì¶”ì  ì‹œìŠ¤í…œ  
**ì„¤ëª…**: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì™€ ì»¬í…Œì´ë„ˆì˜ ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¶”ì í•˜ê³  ë™ê¸°í™”í•˜ëŠ” ì‹œìŠ¤í…œ  
**ìš°ì„ ìˆœìœ„**: ì¤‘ê°„  
**ë³µì¡ë„**: ë‚®ìŒ  
**ì˜ˆìƒ ì†Œìš”ì‹œê°„**: 3-4ì‹œê°„  
**ìƒíƒœ**: completed  
**ì‹œì‘ ì‹œê°„**: 2025-01-25T10:30:00Z  
**ì™„ë£Œ ì‹œê°„**: 2025-01-25T18:45:00Z  

## ğŸ“‹ ì‘ì—… ê°œìš”

ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì˜ ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ê³ , Docker ì»¬í…Œì´ë„ˆì˜ ìƒíƒœì™€ ë™ê¸°í™”í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì‚¬ìš©ìëŠ” ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì˜ í˜„ì¬ ìƒíƒœë¥¼ ì •í™•í•˜ê²Œ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ğŸ¯ ëª©í‘œ

1. **ìƒíƒœ ë™ê¸°í™”**: Docker ì»¬í…Œì´ë„ˆì™€ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ DB ìƒíƒœ ì¼ì¹˜
2. **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**: ìƒíƒœ ë³€ê²½ ì‚¬í•­ ì¦‰ì‹œ ë°˜ì˜
3. **ì´ë²¤íŠ¸ ì²˜ë¦¬**: ìƒíƒœ ë³€ê²½ ì‹œ ì ì ˆí•œ ì½œë°± ì‹¤í–‰
4. **ì˜¤ë¥˜ ë³µêµ¬**: ë¹„ì¼ì¹˜ ìƒíƒœ ìë™ ê°ì§€ ë° ì •ì •
5. **ì„±ëŠ¥ ë©”íŠ¸ë¦­**: ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ì¶”ì 

## ğŸ“‚ ì½”ë“œë² ì´ìŠ¤ ë¶„ì„

### ì˜ì¡´ì„±
- `T01_S01_M04`: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì„œë¹„ìŠ¤ ê³„ì¸µ (ìƒíƒœ ì—…ë°ì´íŠ¸)
- `T03_S01_M04`: ì»¬í…Œì´ë„ˆ ìƒëª…ì£¼ê¸° ê´€ë¦¬ì (ìƒíƒœ ì¡°íšŒ)
- `internal/models/workspace.go`: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ëª¨ë¸ (Status í•„ë“œ)

### ê¸°ì¡´ ìƒíƒœ ëª¨ë¸
```go
// internal/models/workspace.go
type WorkspaceStatus string

const (
    WorkspaceStatusActive    WorkspaceStatus = "active"
    WorkspaceStatusInactive  WorkspaceStatus = "inactive"  
    WorkspaceStatusArchived  WorkspaceStatus = "archived"
)
```

### êµ¬í˜„ ìœ„ì¹˜
```
internal/docker/
â”œâ”€â”€ status/
â”‚   â”œâ”€â”€ tracker.go       # ìƒíƒœ ì¶”ì ì (ìƒˆë¡œ ìƒì„±)
â”‚   â”œâ”€â”€ monitor.go       # ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„° (ìƒˆë¡œ ìƒì„±)
â”‚   â””â”€â”€ events.go        # ì´ë²¤íŠ¸ ì²˜ë¦¬ (ìƒˆë¡œ ìƒì„±)
â””â”€â”€ metrics.go           # ë©”íŠ¸ë¦­ ì½œë ‰í„° (ìƒˆë¡œ ìƒì„±)
```

## ğŸ› ï¸ ê¸°ìˆ  ê°€ì´ë“œ

### 1. ìƒíƒœ ì¶”ì ì êµ¬ì¡°

```go
// internal/docker/status/tracker.go
package status

import (
    "context"
    "fmt"
    "sync"
    "time"
    
    "github.com/aicli/aicli-web/internal/models"
    "github.com/aicli/aicli-web/internal/services"
    "github.com/aicli/aicli-web/internal/docker"
)

type Tracker struct {
    // ì˜ì¡´ì„±
    workspaceService services.WorkspaceService
    containerManager *docker.ContainerManager
    
    // ë‚´ë¶€ ìƒíƒœ
    states           sync.Map // workspaceID -> *WorkspaceState
    eventCallbacks   []EventCallback
    
    // ì„¤ì •
    syncInterval     time.Duration
    retryInterval    time.Duration
    maxRetries       int
    
    // ì œì–´
    ctx              context.Context
    cancel           context.CancelFunc
    wg               sync.WaitGroup
}

type WorkspaceState struct {
    // ê¸°ë³¸ ì •ë³´
    WorkspaceID      string                 `json:"workspace_id"`
    Name             string                 `json:"name"`
    Status           models.WorkspaceStatus `json:"status"`
    
    // ì»¬í…Œì´ë„ˆ ìƒíƒœ
    ContainerID      string                 `json:"container_id,omitempty"`
    ContainerState   docker.ContainerState  `json:"container_state,omitempty"`
    
    // ì‹œê°„ ì •ë³´
    LastUpdated      time.Time              `json:"last_updated"`
    LastSyncAttempt  time.Time              `json:"last_sync_attempt"`
    
    // ìƒíƒœ ë©”íƒ€ë°ì´í„°
    SyncAttempts     int                    `json:"sync_attempts"`
    LastError        string                 `json:"last_error,omitempty"`
    Metrics          *WorkspaceMetrics      `json:"metrics,omitempty"`
}

type WorkspaceMetrics struct {
    // ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰
    CPUPercent       float64   `json:"cpu_percent"`
    MemoryUsage      int64     `json:"memory_usage"`
    MemoryLimit      int64     `json:"memory_limit"`
    NetworkRxMB      float64   `json:"network_rx_mb"`
    NetworkTxMB      float64   `json:"network_tx_mb"`
    
    // íƒ€ì´ë° ì •ë³´
    Uptime           string    `json:"uptime"`
    LastActivity     time.Time `json:"last_activity"`
    
    // ì˜¤ë¥˜ í†µê³„
    ErrorCount       int       `json:"error_count"`
    LastErrorTime    time.Time `json:"last_error_time,omitempty"`
}

type EventCallback func(workspaceID string, oldState, newState *WorkspaceState)

func NewTracker(workspaceService services.WorkspaceService, containerManager *docker.ContainerManager) *Tracker {
    ctx, cancel := context.WithCancel(context.Background())
    
    return &Tracker{
        workspaceService: workspaceService,
        containerManager: containerManager,
        states:           sync.Map{},
        eventCallbacks:   make([]EventCallback, 0),
        syncInterval:     30 * time.Second,
        retryInterval:    5 * time.Second,
        maxRetries:       3,
        ctx:              ctx,
        cancel:           cancel,
    }
}
```

### 2. ìƒíƒœ ë™ê¸°í™” ë¡œì§

```go
// ìƒíƒœ ì¶”ì  ì‹œì‘
func (t *Tracker) Start() error {
    t.wg.Add(1)
    go t.syncLoop()
    return nil
}

func (t *Tracker) Stop() error {
    t.cancel()
    t.wg.Wait()
    return nil
}

func (t *Tracker) syncLoop() {
    defer t.wg.Done()
    
    ticker := time.NewTicker(t.syncInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-t.ctx.Done():
            return
        case <-ticker.C:
            t.syncAllWorkspaces()
        }
    }
}

func (t *Tracker) syncAllWorkspaces() {
    // DBì—ì„œ ëª¨ë“  ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì¡°íšŒ
    workspaces, err := t.getAllWorkspaces()
    if err != nil {
        return // ë¡œê¹… ë° ì—ëŸ¬ ì²˜ë¦¬
    }
    
    for _, workspace := range workspaces {
        t.syncWorkspaceState(workspace.ID)
    }
    
    // ì‚­ì œëœ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì •ë¦¬
    t.cleanupDeletedWorkspaces(workspaces)
}

func (t *Tracker) syncWorkspaceState(workspaceID string) {
    // í˜„ì¬ ìƒíƒœ ì¡°íšŒ
    currentState := t.getCurrentState(workspaceID)
    
    // DBì—ì„œ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì •ë³´ ì¡°íšŒ
    workspace, err := t.workspaceService.GetWorkspace(t.ctx, workspaceID, "")
    if err != nil {
        t.handleSyncError(workspaceID, err)
        return
    }
    
    // ì»¬í…Œì´ë„ˆ ìƒíƒœ ì¡°íšŒ
    containers, err := t.containerManager.ListWorkspaceContainers(t.ctx, workspaceID)
    if err != nil {
        t.handleSyncError(workspaceID, err)
        return
    }
    
    // ìƒˆë¡œìš´ ìƒíƒœ ê³„ì‚°
    newState := t.calculateNewState(workspace, containers)
    
    // ìƒíƒœ ë³€ê²½ ê°ì§€ ë° ì—…ë°ì´íŠ¸
    if t.hasStateChanged(currentState, newState) {
        t.updateState(workspaceID, currentState, newState)
    }
}

func (t *Tracker) calculateNewState(workspace *models.Workspace, containers []*docker.WorkspaceContainer) *WorkspaceState {
    state := &WorkspaceState{
        WorkspaceID:     workspace.ID,
        Name:            workspace.Name,
        Status:          workspace.Status,
        LastUpdated:     time.Now(),
        LastSyncAttempt: time.Now(),
    }
    
    // ì»¬í…Œì´ë„ˆ ìƒíƒœ ë°˜ì˜
    if len(containers) > 0 {
        // ê°€ì¥ ìµœê·¼ ì»¬í…Œì´ë„ˆ ì‚¬ìš©
        container := containers[0]
        state.ContainerID = container.ID
        state.ContainerState = container.State
        
        // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒíƒœë¥¼ ì»¬í…Œì´ë„ˆ ìƒíƒœì— ë”°ë¼ ì—…ë°ì´íŠ¸
        state.Status = t.deriveWorkspaceStatus(container.State)
        
        // ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        if container.Stats != nil {
            state.Metrics = t.containerStatsToMetrics(container.Stats)
        }
    } else {
        // ì»¬í…Œì´ë„ˆê°€ ì—†ìœ¼ë©´ inactive
        state.Status = models.WorkspaceStatusInactive
    }
    
    return state
}

func (t *Tracker) deriveWorkspaceStatus(containerState docker.ContainerState) models.WorkspaceStatus {
    switch containerState {
    case docker.ContainerStateRunning:
        return models.WorkspaceStatusActive
    case docker.ContainerStateExited, docker.ContainerStateDead:
        return models.WorkspaceStatusInactive
    case docker.ContainerStatePaused:
        return models.WorkspaceStatusInactive // ì¼ì‹œ ì¤‘ì§€ë¡œ ê°„ì£¼
    default:
        return models.WorkspaceStatusInactive
    }
}
```

### 3. ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œìŠ¤í…œ

```go
// internal/docker/status/events.go
package status

import (
    "context"
    "fmt"
    "time"
)

type EventType string

const (
    EventTypeStatusChanged   EventType = "status_changed"
    EventTypeContainerUpdate EventType = "container_update"
    EventTypeError           EventType = "error"
    EventTypeRecovery        EventType = "recovery"
)

type Event struct {
    Type        EventType     `json:"type"`
    WorkspaceID string        `json:"workspace_id"`
    Timestamp   time.Time     `json:"timestamp"`
    Data        interface{}   `json:"data"`
    Message     string        `json:"message,omitempty"`
}

type StatusChangeEvent struct {
    OldStatus models.WorkspaceStatus `json:"old_status"`
    NewStatus models.WorkspaceStatus `json:"new_status"`
    Reason    string                 `json:"reason,omitempty"`
}

func (t *Tracker) updateState(workspaceID string, oldState, newState *WorkspaceState) {
    // ìƒíƒœ ì €ì¥
    t.states.Store(workspaceID, newState)
    
    // ì´ë²¤íŠ¸ ìƒì„±
    event := t.createStateChangeEvent(workspaceID, oldState, newState)
    t.emitEvent(event)
    
    // ì½œë°± ì‹¤í–‰
    for _, callback := range t.eventCallbacks {
        go func(cb EventCallback) {
            defer func() {
                if r := recover(); r != nil {
                    // ì½œë°± ì—ëŸ¬ ë¡œê¹…
                }
            }()
            cb(workspaceID, oldState, newState)
        }(callback)
    }
    
    // DB ìƒíƒœ ë™ê¸°í™”
    t.syncToDatabase(workspaceID, newState)
}

func (t *Tracker) createStateChangeEvent(workspaceID string, oldState, newState *WorkspaceState) *Event {
    var reason string
    if oldState == nil {
        reason = "workspace_initialized"
    } else if oldState.Status != newState.Status {
        reason = fmt.Sprintf("status_changed_%s_to_%s", oldState.Status, newState.Status)
    } else if oldState.ContainerState != newState.ContainerState {
        reason = fmt.Sprintf("container_state_changed_%s_to_%s", oldState.ContainerState, newState.ContainerState)
    }
    
    return &Event{
        Type:        EventTypeStatusChanged,
        WorkspaceID: workspaceID,
        Timestamp:   time.Now(),
        Data: StatusChangeEvent{
            OldStatus: oldState.Status,
            NewStatus: newState.Status,
            Reason:    reason,
        },
        Message: fmt.Sprintf("Workspace %s status changed: %s", workspaceID, reason),
    }
}

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
func (t *Tracker) OnStateChange(callback EventCallback) {
    t.eventCallbacks = append(t.eventCallbacks, callback)
}

func (t *Tracker) emitEvent(event *Event) {
    // ì´ë²¤íŠ¸ ë¡œê¹…
    fmt.Printf("[%s] %s: %s\n", event.Timestamp.Format(time.RFC3339), event.Type, event.Message)
    
    // í–¥í›„ ì´ë²¤íŠ¸ ë²„ìŠ¤ë‚˜ WebSocketìœ¼ë¡œ ì „ì†¡ ê°€ëŠ¥
}
```

### 4. ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§

```go
// internal/docker/status/monitor.go
package status

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/docker/docker/api/types"
    "github.com/aicli/aicli-web/internal/docker"
)

type ResourceMonitor struct {
    containerManager *docker.ContainerManager
    statsCache       map[string]*docker.ContainerStats
    collectInterval  time.Duration
}

func NewResourceMonitor(cm *docker.ContainerManager) *ResourceMonitor {
    return &ResourceMonitor{
        containerManager: cm,
        statsCache:       make(map[string]*docker.ContainerStats),
        collectInterval:  10 * time.Second,
    }
}

func (rm *ResourceMonitor) StartMonitoring(ctx context.Context, workspaceID string) (<-chan *WorkspaceMetrics, error) {
    metricsChan := make(chan *WorkspaceMetrics, 10)
    
    go func() {
        defer close(metricsChan)
        
        ticker := time.NewTicker(rm.collectInterval)
        defer ticker.Stop()
        
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                metrics := rm.collectMetrics(ctx, workspaceID)
                if metrics != nil {
                    select {
                    case metricsChan <- metrics:
                    case <-ctx.Done():
                        return
                    }
                }
            }
        }
    }()
    
    return metricsChan, nil
}

func (rm *ResourceMonitor) collectMetrics(ctx context.Context, workspaceID string) *WorkspaceMetrics {
    containers, err := rm.containerManager.ListWorkspaceContainers(ctx, workspaceID)
    if err != nil || len(containers) == 0 {
        return nil
    }
    
    // ê°€ì¥ ìµœê·¼ ì»¬í…Œì´ë„ˆì˜ í†µê³„ ìˆ˜ì§‘
    container := containers[0]
    if container.State != docker.ContainerStateRunning {
        return nil
    }
    
    // ì´ì „ í†µê³„ì™€ ë¹„êµí•˜ì—¬ uptime ê³„ì‚°
    var uptime string
    if container.Started != nil {
        uptime = time.Since(*container.Started).String()
    }
    
    metrics := &WorkspaceMetrics{
        Uptime:        uptime,
        LastActivity:  time.Now(),
        ErrorCount:    0, // ì—ëŸ¬ ì¹´ìš´í„°ëŠ” ë”°ë¡œ ê´€ë¦¬
    }
    
    // ì»¬í…Œì´ë„ˆì—ì„œ ë¦¬ì†ŒìŠ¤ í†µê³„ ìˆ˜ì§‘
    if container.Stats != nil {
        metrics.CPUPercent = container.Stats.CPUPercent
        metrics.MemoryUsage = container.Stats.MemoryUsage
        metrics.MemoryLimit = container.Stats.MemoryLimit
        metrics.NetworkRxMB = container.Stats.NetworkRxMB
        metrics.NetworkTxMB = container.Stats.NetworkTxMB
    }
    
    return metrics
}

// ì „ì²´ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ì§‘ê³„
func (rm *ResourceMonitor) GetResourceSummary(ctx context.Context) (*ResourceSummary, error) {
    // ëª¨ë“  ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì˜ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ì§‘ê³„
    return &ResourceSummary{
        TotalWorkspaces: 0,
        ActiveContainers: 0,
        TotalCPUUsage: 0.0,
        TotalMemoryUsage: 0,
        TotalNetworkIO: 0.0,
    }, nil
}

type ResourceSummary struct {
    TotalWorkspaces   int     `json:"total_workspaces"`
    ActiveContainers  int     `json:"active_containers"`
    TotalCPUUsage     float64 `json:"total_cpu_usage"`
    TotalMemoryUsage  int64   `json:"total_memory_usage"`
    TotalNetworkIO    float64 `json:"total_network_io_mb"`
    LastUpdated       time.Time `json:"last_updated"`
}
```

### 5. API í†µí•© ì¸í„°í˜ì´ìŠ¤

```go
// ìƒíƒœ ì¶”ì ì ì¸í„°í˜ì´ìŠ¤ í™•ì¥
func (t *Tracker) GetWorkspaceState(workspaceID string) (*WorkspaceState, bool) {
    if state, ok := t.states.Load(workspaceID); ok {
        return state.(*WorkspaceState), true
    }
    return nil, false
}

func (t *Tracker) GetAllWorkspaceStates() map[string]*WorkspaceState {
    result := make(map[string]*WorkspaceState)
    
    t.states.Range(func(key, value interface{}) bool {
        workspaceID := key.(string)
        state := value.(*WorkspaceState)
        result[workspaceID] = state
        return true
    })
    
    return result
}

// ìˆ˜ë™ ë™ê¸°í™” íŠ¸ë¦¬ê±°
func (t *Tracker) ForceSync(workspaceID string) error {
    if workspaceID == "" {
        // ëª¨ë“  ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë™ê¸°í™”
        go t.syncAllWorkspaces()
    } else {
        // íŠ¹ì • ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë§Œ ë™ê¸°í™”
        go t.syncWorkspaceState(workspaceID)
    }
    return nil
}
```

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [ ] ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì™€ Docker ì»¬í…Œì´ë„ˆ ìƒíƒœ ë™ê¸°í™”
- [ ] ì‹¤ì‹œê°„ ìƒíƒœ ë³€ê²½ ê°ì§€ ë° ì•Œë¦¼
- [ ] ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ë° ì§‘ê³„
- [ ] ìƒíƒœ ë¹„ì¼ì¹˜ ìë™ ê°ì§€ ë° ë³µêµ¬
- [ ] ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° ì½œë°± ì‹œìŠ¤í…œ

### ë¹„ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [ ] ìƒíƒœ ë™ê¸°í™” ì§€ì—° < 30ì´ˆ
- [ ] ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ì˜¤ë²„í—¤ë“œ < 5%
- [ ] ì´ë²¤íŠ¸ ì²˜ë¦¬ ì§€ì—° < 1ì´ˆ
- [ ] ë™ì‹œ ì²˜ë¦¬ ê°€ëŠ¥ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìˆ˜ > 100ê°œ

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### 1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```go
func TestTracker_SyncWorkspaceState(t *testing.T) {
    // Mock ì„œë¹„ìŠ¤ ë° ëª¨ë‹ˆí„° ì„¤ì •
    mockService := &MockWorkspaceService{}
    mockManager := &MockContainerManager{}
    
    tracker := NewTracker(mockService, mockManager)
    
    // ìƒíƒœ ë™ê¸°í™” í…ŒìŠ¤íŠ¸
    err := tracker.syncWorkspaceState("test-workspace")
    
    assert.NoError(t, err)
    state, exists := tracker.GetWorkspaceState("test-workspace")
    assert.True(t, exists)
    assert.NotNil(t, state)
}

func TestResourceMonitor_CollectMetrics(t *testing.T) {
    monitor := NewResourceMonitor(mockContainerManager)
    
    metrics := monitor.collectMetrics(context.Background(), "test-workspace")
    
    assert.NotNil(t, metrics)
    assert.NotZero(t, metrics.LastActivity)
}
```

### 2. í†µí•© í…ŒìŠ¤íŠ¸
- ì‹¤ì œ ì»¬í…Œì´ë„ˆ ìƒì„±/ì‚­ì œ ì‹œ ìƒíƒœ ë³€ê²½ ê°ì§€
- ì—¬ëŸ¬ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë™ì‹œ ëª¨ë‹ˆí„°ë§
- ë„¤íŠ¸ì›Œí¬ ë‹¨ì ˆ/ë³µêµ¬ ì‹œ ë™ì‘

## ğŸ“ êµ¬í˜„ ë‹¨ê³„

1. **Phase 1**: ìƒíƒœ ì¶”ì ì ê¸°ë³¸ êµ¬ì¡° (1ì‹œê°„)
2. **Phase 2**: ë™ê¸°í™” ë¡œì§ ë° ì´ë²¤íŠ¸ ì²˜ë¦¬ (1.5ì‹œê°„)
3. **Phase 3**: ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ (1ì‹œê°„)
4. **Phase 4**: API í†µí•© ì¸í„°í˜ì´ìŠ¤ (0.5ì‹œê°„)
5. **Phase 5**: í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ê²€ì¦ (1ì‹œê°„)

## ğŸ”— ì—°ê´€ íƒœìŠ¤í¬

- **ì˜ì¡´ì„±**: T01_S01_M04 (ì„œë¹„ìŠ¤ ê³„ì¸µ), T03_S01_M04 (ì»¬í…Œì´ë„ˆ ê´€ë¦¬ì)
- **í›„ì† ì‘ì—…**: T07_S01_M04 (API í†µí•© - ìƒíƒœ ì •ë³´ ì œê³µ)
- **ë™ì‹œ ì§„í–‰**: T04_S01_M04 (ë§ˆìš´íŠ¸ ì‹œìŠ¤í…œ)

## ğŸ“š ì°¸ê³  ìë£Œ

- [Docker Events API](https://docs.docker.com/engine/api/v1.41/#operation/SystemEvents)
- [Container Stats API](https://docs.docker.com/engine/api/v1.41/#operation/ContainerStats)
- [Go Context íŒ¨í„´](https://golang.org/pkg/context/)
- [Prometheus Metrics](https://prometheus.io/docs/concepts/metric_types/)