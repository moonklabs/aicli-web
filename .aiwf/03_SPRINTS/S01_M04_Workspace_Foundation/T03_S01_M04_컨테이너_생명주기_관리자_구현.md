# T03_S01_M04_ì»¬í…Œì´ë„ˆ_ìƒëª…ì£¼ê¸°_ê´€ë¦¬ì_êµ¬í˜„

---
task_id: T03_S01_M04
title: ì»¬í…Œì´ë„ˆ ìƒëª…ì£¼ê¸° ê´€ë¦¬ì êµ¬í˜„
description: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì»¬í…Œì´ë„ˆì˜ ìƒì„±, ì‹œì‘, ì¤‘ì§€, ì‚­ì œ ê¸°ëŠ¥ êµ¬í˜„
priority: ë†’ìŒ
complexity: ë³´í†µ
estimated_hours: 5-7
status: completed
assignee: Claude
created_at: 2025-01-27
started_at: 2025-01-27T10:00:00Z
completed_at: 2025-01-27T12:00:00Z
dependencies: [T02_S01_M04]
---

**íƒœìŠ¤í¬ ID**: T03_S01_M04  
**ì œëª©**: ì»¬í…Œì´ë„ˆ ìƒëª…ì£¼ê¸° ê´€ë¦¬ì êµ¬í˜„  
**ì„¤ëª…**: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì»¬í…Œì´ë„ˆì˜ ìƒì„±, ì‹œì‘, ì¤‘ì§€, ì‚­ì œ ê¸°ëŠ¥ êµ¬í˜„  
**ìš°ì„ ìˆœìœ„**: ë†’ìŒ  
**ë³µì¡ë„**: ë³´í†µ  
**ì˜ˆìƒ ì†Œìš”ì‹œê°„**: 5-7ì‹œê°„  

## ğŸ“‹ ì‘ì—… ê°œìš”

Docker SDKë¥¼ ì‚¬ìš©í•˜ì—¬ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë³„ ì „ìš© ì»¬í…Œì´ë„ˆë¥¼ ìƒì„±, ê´€ë¦¬, ì‚­ì œí•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ê° ì»¬í…Œì´ë„ˆëŠ” ë…ë¦½ëœ í™˜ê²½ì—ì„œ ì‹¤í–‰ë˜ë©°, ì ì ˆí•œ ë¦¬ì†ŒìŠ¤ ì œí•œê³¼ ë³´ì•ˆ ì„¤ì •ì„ ì ìš©ë°›ìŠµë‹ˆë‹¤.

## ğŸ¯ ëª©í‘œ

1. **ì»¬í…Œì´ë„ˆ ìƒì„±**: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë³„ ì „ìš© ì»¬í…Œì´ë„ˆ ìƒì„±
2. **ìƒëª…ì£¼ê¸° ê´€ë¦¬**: ì‹œì‘, ì¤‘ì§€, ì¬ì‹œì‘, ì‚­ì œ ê¸°ëŠ¥
3. **ìƒíƒœ ì¶”ì **: ì»¬í…Œì´ë„ˆ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ë° ì—…ë°ì´íŠ¸
4. **ë¦¬ì†ŒìŠ¤ ê´€ë¦¬**: CPU, ë©”ëª¨ë¦¬, ë„¤íŠ¸ì›Œí¬ ì‚¬ìš©ëŸ‰ ì œí•œ
5. **ì—ëŸ¬ ë³µêµ¬**: ì‹¤íŒ¨ ì‹œ ìë™ ì •ë¦¬ ë° ë³µêµ¬

## ğŸ“‚ ì½”ë“œë² ì´ìŠ¤ ë¶„ì„

### ì˜ì¡´ì„±
- `T02_S01_M04`: Docker SDK ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸ (í•„ìˆ˜)
- `internal/models/workspace.go`: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ëª¨ë¸
- `/docs/cli-design/docker-integration.md`: ì„¤ê³„ ë¬¸ì„œ ì°¸ì¡°

### êµ¬í˜„ ìœ„ì¹˜
```
internal/docker/
â”œâ”€â”€ container.go         # ì»¬í…Œì´ë„ˆ ê´€ë¦¬ì (ìƒˆë¡œ ìƒì„±)
â”œâ”€â”€ container_manager.go # ìƒëª…ì£¼ê¸° ê´€ë¦¬ (ìƒˆë¡œ ìƒì„±)
â””â”€â”€ lifecycle.go         # ìƒíƒœ ë° ì´ë²¤íŠ¸ (ìƒˆë¡œ ìƒì„±)
```

## ğŸ› ï¸ ê¸°ìˆ  ê°€ì´ë“œ

### 1. ì»¬í…Œì´ë„ˆ ê´€ë¦¬ì êµ¬ì¡°

```go
// internal/docker/container_manager.go
package docker

import (
    "context"
    "fmt"
    "time"
    
    "github.com/docker/docker/api/types"
    "github.com/docker/docker/api/types/container"
    "github.com/docker/docker/api/types/mount"
    "github.com/docker/docker/api/types/network"
    "github.com/aicli/aicli-web/internal/models"
)

type ContainerManager struct {
    client *Client
}

func NewContainerManager(client *Client) *ContainerManager {
    return &ContainerManager{
        client: client,
    }
}

type WorkspaceContainer struct {
    ID          string                 `json:"id"`
    Name        string                 `json:"name"`
    WorkspaceID string                 `json:"workspace_id"`
    State       ContainerState         `json:"state"`
    Created     time.Time              `json:"created_at"`
    Started     *time.Time             `json:"started_at,omitempty"`
    Finished    *time.Time             `json:"finished_at,omitempty"`
    ExitCode    *int                   `json:"exit_code,omitempty"`
    Stats       *ContainerStats        `json:"stats,omitempty"`
    Ports       map[string]string      `json:"ports,omitempty"`
    Mounts      []ContainerMount       `json:"mounts,omitempty"`
}

type ContainerState string

const (
    ContainerStateCreated    ContainerState = "created"
    ContainerStateRunning    ContainerState = "running"
    ContainerStateExited     ContainerState = "exited"
    ContainerStatePaused     ContainerState = "paused"
    ContainerStateRestarting ContainerState = "restarting"
    ContainerStateRemoving   ContainerState = "removing"
    ContainerStateDead       ContainerState = "dead"
)

type ContainerStats struct {
    CPUPercent    float64   `json:"cpu_percent"`
    MemoryUsage   int64     `json:"memory_usage"`
    MemoryLimit   int64     `json:"memory_limit"`
    NetworkRxMB   float64   `json:"network_rx_mb"`
    NetworkTxMB   float64   `json:"network_tx_mb"`
    BlockRead     int64     `json:"block_read"`
    BlockWrite    int64     `json:"block_write"`
    LastUpdated   time.Time `json:"last_updated"`
}

type ContainerMount struct {
    Source      string `json:"source"`
    Destination string `json:"destination"`
    Mode        string `json:"mode"`
    ReadOnly    bool   `json:"read_only"`
}
```

### 2. ì»¬í…Œì´ë„ˆ ìƒì„± ë° ì„¤ì •

```go
type CreateContainerRequest struct {
    WorkspaceID   string            `json:"workspace_id"`
    Name          string            `json:"name"`
    ProjectPath   string            `json:"project_path"`
    Image         string            `json:"image,omitempty"`
    Command       []string          `json:"command,omitempty"`
    Environment   map[string]string `json:"environment,omitempty"`
    WorkingDir    string            `json:"working_dir,omitempty"`
    
    // ë¦¬ì†ŒìŠ¤ ì œí•œ
    CPULimit      float64           `json:"cpu_limit,omitempty"`
    MemoryLimit   int64             `json:"memory_limit,omitempty"`
    
    // ë„¤íŠ¸ì›Œí¬ ì„¤ì •
    Ports         map[string]string `json:"ports,omitempty"`
    
    // ë³´ì•ˆ ì„¤ì •
    Privileged    bool              `json:"privileged,omitempty"`
    ReadOnly      bool              `json:"read_only,omitempty"`
}

func (cm *ContainerManager) CreateWorkspaceContainer(ctx context.Context, req *CreateContainerRequest) (*WorkspaceContainer, error) {
    // ê¸°ë³¸ê°’ ì„¤ì •
    if req.Image == "" {
        req.Image = cm.client.config.DefaultImage
    }
    if req.WorkingDir == "" {
        req.WorkingDir = "/workspace"
    }
    
    containerName := cm.client.GenerateContainerName(req.WorkspaceID)
    
    // ê¸°ì¡´ ì»¬í…Œì´ë„ˆ ì •ë¦¬
    if err := cm.cleanupExistingContainer(ctx, containerName); err != nil {
        return nil, fmt.Errorf("cleanup existing container: %w", err)
    }
    
    // ì»¬í…Œì´ë„ˆ ì„¤ì •
    config := &container.Config{
        Image:        req.Image,
        Cmd:          req.Command,
        WorkingDir:   req.WorkingDir,
        Hostname:     containerName,
        AttachStdin:  true,
        AttachStdout: true,
        AttachStderr: true,
        OpenStdin:    true,
        StdinOnce:    false,
        Tty:          true,
        Labels:       cm.client.WorkspaceLabels(req.WorkspaceID, req.Name),
    }
    
    // í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
    config.Env = cm.buildEnvironment(req)
    
    // í˜¸ìŠ¤íŠ¸ ì„¤ì •
    hostConfig := &container.HostConfig{
        // í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ë§ˆìš´íŠ¸
        Mounts: []mount.Mount{
            {
                Type:   mount.TypeBind,
                Source: req.ProjectPath,
                Target: "/workspace",
                BindOptions: &mount.BindOptions{
                    Propagation: mount.PropagationRPrivate,
                },
            },
        },
        
        // ë¦¬ì†ŒìŠ¤ ì œí•œ
        Resources: cm.buildResourceLimits(req),
        
        // ë³´ì•ˆ ì„¤ì •
        Privileged:     req.Privileged,
        ReadonlyRootfs: req.ReadOnly || cm.client.config.ReadOnly,
        SecurityOpt:    cm.client.config.SecurityOpts,
        CapDrop:        []string{"ALL"},
        CapAdd:         []string{"CHOWN", "SETUID", "SETGID", "DAC_OVERRIDE"},
        
        // ì¬ì‹œì‘ ì •ì±…
        RestartPolicy: container.RestartPolicy{
            Name: "unless-stopped",
        },
        
        // í¬íŠ¸ ë§¤í•‘
        PortBindings: cm.buildPortBindings(req.Ports),
    }
    
    // ë„¤íŠ¸ì›Œí¬ ì„¤ì •
    networkConfig := &network.NetworkingConfig{
        EndpointsConfig: map[string]*network.EndpointSettings{
            cm.client.config.NetworkName: {
                NetworkID: cm.client.GetNetworkID(),
            },
        },
    }
    
    // ì»¬í…Œì´ë„ˆ ìƒì„±
    resp, err := cm.client.cli.ContainerCreate(
        ctx, config, hostConfig, networkConfig, nil, containerName,
    )
    if err != nil {
        return nil, fmt.Errorf("create container: %w", err)
    }
    
    return &WorkspaceContainer{
        ID:          resp.ID,
        Name:        containerName,
        WorkspaceID: req.WorkspaceID,
        State:       ContainerStateCreated,
        Created:     time.Now(),
    }, nil
}

func (cm *ContainerManager) buildEnvironment(req *CreateContainerRequest) []string {
    env := []string{
        fmt.Sprintf("WORKSPACE_ID=%s", req.WorkspaceID),
        fmt.Sprintf("WORKSPACE_NAME=%s", req.Name),
        fmt.Sprintf("AICLI_MANAGED=true"),
    }
    
    // ì‚¬ìš©ì ì§€ì • í™˜ê²½ ë³€ìˆ˜ ì¶”ê°€
    for key, value := range req.Environment {
        env = append(env, fmt.Sprintf("%s=%s", key, value))
    }
    
    return env
}

func (cm *ContainerManager) buildResourceLimits(req *CreateContainerRequest) container.Resources {
    cpuLimit := req.CPULimit
    if cpuLimit == 0 {
        cpuLimit = cm.client.config.CPULimit
    }
    
    memLimit := req.MemoryLimit
    if memLimit == 0 {
        memLimit = cm.client.config.MemoryLimit
    }
    
    return container.Resources{
        CPUQuota:   int64(cpuLimit * 100000), // 1.0 = 100%
        CPUPeriod:  100000,
        Memory:     memLimit,
        MemorySwap: memLimit, // Swap ë¹„í™œì„±í™”
        
        // PID ì œí•œ
        PidsLimit: func() *int64 { 
            limit := int64(100) // ìµœëŒ€ 100ê°œ í”„ë¡œì„¸ìŠ¤
            return &limit
        }(),
    }
}
```

### 3. ìƒëª…ì£¼ê¸° ê´€ë¦¬ ê¸°ëŠ¥

```go
// ì»¬í…Œì´ë„ˆ ì‹œì‘
func (cm *ContainerManager) StartContainer(ctx context.Context, containerID string) error {
    if err := cm.client.cli.ContainerStart(ctx, containerID, types.ContainerStartOptions{}); err != nil {
        return fmt.Errorf("start container: %w", err)
    }
    return nil
}

// ì»¬í…Œì´ë„ˆ ì¤‘ì§€
func (cm *ContainerManager) StopContainer(ctx context.Context, containerID string, timeout time.Duration) error {
    if timeout == 0 {
        timeout = 10 * time.Second
    }
    
    timeoutSeconds := int(timeout.Seconds())
    if err := cm.client.cli.ContainerStop(ctx, containerID, container.StopOptions{
        Timeout: &timeoutSeconds,
    }); err != nil {
        return fmt.Errorf("stop container: %w", err)
    }
    return nil
}

// ì»¬í…Œì´ë„ˆ ì¬ì‹œì‘
func (cm *ContainerManager) RestartContainer(ctx context.Context, containerID string, timeout time.Duration) error {
    if timeout == 0 {
        timeout = 10 * time.Second
    }
    
    timeoutSeconds := int(timeout.Seconds())
    if err := cm.client.cli.ContainerRestart(ctx, containerID, container.StopOptions{
        Timeout: &timeoutSeconds,
    }); err != nil {
        return fmt.Errorf("restart container: %w", err)
    }
    return nil
}

// ì»¬í…Œì´ë„ˆ ì‚­ì œ
func (cm *ContainerManager) RemoveContainer(ctx context.Context, containerID string, force bool) error {
    options := types.ContainerRemoveOptions{
        RemoveVolumes: true,
        RemoveLinks:   true,
        Force:         force,
    }
    
    if err := cm.client.cli.ContainerRemove(ctx, containerID, options); err != nil {
        return fmt.Errorf("remove container: %w", err)
    }
    return nil
}

// ì»¬í…Œì´ë„ˆ ìƒíƒœ ì¡°íšŒ
func (cm *ContainerManager) InspectContainer(ctx context.Context, containerID string) (*WorkspaceContainer, error) {
    inspect, err := cm.client.cli.ContainerInspect(ctx, containerID)
    if err != nil {
        return nil, fmt.Errorf("inspect container: %w", err)
    }
    
    return cm.inspectResultToWorkspaceContainer(&inspect), nil
}

func (cm *ContainerManager) inspectResultToWorkspaceContainer(inspect *types.ContainerJSON) *WorkspaceContainer {
    wc := &WorkspaceContainer{
        ID:          inspect.ID,
        Name:        inspect.Name,
        WorkspaceID: inspect.Config.Labels[cm.client.labelKey("workspace.id")],
        State:       ContainerState(inspect.State.Status),
        Created:     inspect.Created,
    }
    
    if inspect.State.StartedAt != "" {
        if startTime, err := time.Parse(time.RFC3339Nano, inspect.State.StartedAt); err == nil {
            wc.Started = &startTime
        }
    }
    
    if inspect.State.FinishedAt != "" {
        if finishTime, err := time.Parse(time.RFC3339Nano, inspect.State.FinishedAt); err == nil {
            wc.Finished = &finishTime
        }
    }
    
    if inspect.State.ExitCode != 0 {
        wc.ExitCode = &inspect.State.ExitCode
    }
    
    // ë§ˆìš´íŠ¸ ì •ë³´
    for _, mount := range inspect.Mounts {
        wc.Mounts = append(wc.Mounts, ContainerMount{
            Source:      mount.Source,
            Destination: mount.Destination,
            Mode:        string(mount.Mode),
            ReadOnly:    !mount.RW,
        })
    }
    
    return wc
}
```

### 4. ëŒ€ëŸ‰ ì‘ì—… ê´€ë¦¬

```go
// ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë³„ ì»¬í…Œì´ë„ˆ ëª©ë¡ ì¡°íšŒ
func (cm *ContainerManager) ListWorkspaceContainers(ctx context.Context, workspaceID string) ([]*WorkspaceContainer, error) {
    filters := filters.NewArgs()
    filters.Add("label", fmt.Sprintf("%s.workspace.id=%s", cm.client.labelPrefix, workspaceID))
    
    containers, err := cm.client.cli.ContainerList(ctx, types.ContainerListOptions{
        All:     true,
        Filters: filters,
    })
    if err != nil {
        return nil, fmt.Errorf("list containers: %w", err)
    }
    
    result := make([]*WorkspaceContainer, 0, len(containers))
    for _, container := range containers {
        wc := &WorkspaceContainer{
            ID:          container.ID,
            Name:        container.Names[0],
            WorkspaceID: workspaceID,
            State:       ContainerState(container.State),
            Created:     time.Unix(container.Created, 0),
        }
        result = append(result, wc)
    }
    
    return result, nil
}

// ëª¨ë“  ì»¬í…Œì´ë„ˆ ì •ë¦¬
func (cm *ContainerManager) CleanupWorkspace(ctx context.Context, workspaceID string, force bool) error {
    containers, err := cm.ListWorkspaceContainers(ctx, workspaceID)
    if err != nil {
        return fmt.Errorf("list workspace containers: %w", err)
    }
    
    for _, container := range containers {
        // ì‹¤í–‰ ì¤‘ì´ë©´ ì¤‘ì§€
        if container.State == ContainerStateRunning {
            if err := cm.StopContainer(ctx, container.ID, 10*time.Second); err != nil {
                if !force {
                    return fmt.Errorf("stop container %s: %w", container.ID, err)
                }
            }
        }
        
        // ì»¬í…Œì´ë„ˆ ì‚­ì œ
        if err := cm.RemoveContainer(ctx, container.ID, force); err != nil {
            if !force {
                return fmt.Errorf("remove container %s: %w", container.ID, err)
            }
        }
    }
    
    return nil
}

func (cm *ContainerManager) cleanupExistingContainer(ctx context.Context, containerName string) error {
    // ì´ë¦„ìœ¼ë¡œ ì»¬í…Œì´ë„ˆ ì°¾ê¸°
    containers, err := cm.client.cli.ContainerList(ctx, types.ContainerListOptions{
        All: true,
        Filters: filters.NewArgs(
            filters.Arg("name", containerName),
        ),
    })
    
    if err != nil {
        return err
    }
    
    // ê¸°ì¡´ ì»¬í…Œì´ë„ˆ ì‚­ì œ
    for _, container := range containers {
        if err := cm.RemoveContainer(ctx, container.ID, true); err != nil {
            return fmt.Errorf("remove existing container %s: %w", container.ID, err)
        }
    }
    
    return nil
}
```

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [x] ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì»¨í…Œì´ë„ˆ ìƒì„± ë° ì„¤ì •
- [x] ì»¨í…Œì´ë„ˆ ìƒëª…ì£¼ê¸° ê´€ë¦¬ (ì‹œì‘/ì¤‘ì§€/ì¬ì‹œì‘/ì‚­ì œ)
- [x] ë¦¬ì†ŒìŠ¤ ì œí•œ ë° ë³´ì•ˆ ì„¤ì • ì ìš©
- [x] ì»¨í…Œì´ë„ˆ ìƒíƒœ ì¶”ì  ë° ëª¨ë‹ˆí„°ë§
- [x] ì—ëŸ¬ ì‹œ ìë™ ì •ë¦¬ ê¸°ëŠ¥

### ë¹„ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [x] ì»¨í…Œì´ë„ˆ ìƒì„± ì‹œê°„ < 5ì´ˆ
- [x] ì¤‘ì§€/ì¬ì‹œì‘ ì‹œê°„ < 10ì´ˆ
- [x] ì»¨í…Œì´ë„ˆ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤ì‹œê°„
- [x] ë™ì‹œ ì‹¤í–‰ ì»¨í…Œì´ë„ˆ ìˆ˜ ì œí•œ ì—†ìŒ

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### 1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```go
func TestContainerManager_CreateWorkspaceContainer(t *testing.T) {
    client := setupTestDockerClient(t)
    manager := NewContainerManager(client)
    
    req := &CreateContainerRequest{
        WorkspaceID: "test-workspace",
        Name:        "test",
        ProjectPath: "/tmp/test-project",
    }
    
    container, err := manager.CreateWorkspaceContainer(context.Background(), req)
    
    assert.NoError(t, err)
    assert.NotEmpty(t, container.ID)
    assert.Equal(t, ContainerStateCreated, container.State)
    
    // ì •ë¦¬
    manager.RemoveContainer(context.Background(), container.ID, true)
}
```

### 2. í†µí•© í…ŒìŠ¤íŠ¸
- ì „ì²´ ìƒëª…ì£¼ê¸° í…ŒìŠ¤íŠ¸ (ìƒì„± â†’ ì‹œì‘ â†’ ì¤‘ì§€ â†’ ì‚­ì œ)
- ë¦¬ì†ŒìŠ¤ ì œí•œ íš¨ê³¼ ê²€ì¦
- ë™ì‹œ ì‹¤í–‰ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

## ğŸ“ êµ¬í˜„ ë‹¨ê³„

1. **Phase 1**: ê¸°ë³¸ êµ¬ì¡° ë° ëª¨ë¸ ì •ì˜ (1ì‹œê°„)
2. **Phase 2**: ì»¬í…Œì´ë„ˆ ìƒì„± ë° ì„¤ì • (2ì‹œê°„)
3. **Phase 3**: ìƒëª…ì£¼ê¸° ê´€ë¦¬ ê¸°ëŠ¥ (2ì‹œê°„)
4. **Phase 4**: ëŒ€ëŸ‰ ì‘ì—… ë° ì •ë¦¬ ê¸°ëŠ¥ (1ì‹œê°„)
5. **Phase 5**: í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ê²€ì¦ (1-2ì‹œê°„)

## ğŸ”— ì—°ê´€ íƒœìŠ¤í¬

- **ì˜ì¡´ì„±**: T02_S01_M04 (Docker SDK ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸)
- **í›„ì† ì‘ì—…**: T04_S01_M04 (í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ë§ˆìš´íŠ¸), T07_S01_M04 (API í†µí•©)
- **ë™ì‹œ ì§„í–‰**: T05_S01_M04 (ìƒíƒœ ì¶”ì )

## ğŸ“š ì°¸ê³  ìë£Œ

- [Docker í†µí•© ê°€ì´ë“œ](/docs/cli-design/docker-integration.md)
- [Docker Container API](https://docs.docker.com/engine/api/v1.41/#tag/Container)
- [Go Docker SDK ë¬¸ì„œ](https://pkg.go.dev/github.com/docker/docker)
- [Container Runtime Security](https://kubernetes.io/docs/concepts/security/runtime-security/)