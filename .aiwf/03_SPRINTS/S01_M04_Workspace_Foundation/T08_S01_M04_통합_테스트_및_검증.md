# T08_S01_M04_í†µí•©_í…ŒìŠ¤íŠ¸_ë°_ê²€ì¦

**íƒœìŠ¤í¬ ID**: T08_S01_M04  
**ì œëª©**: í†µí•© í…ŒìŠ¤íŠ¸ ë° ê²€ì¦  
**ì„¤ëª…**: ì „ì²´ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ Docker í†µí•© ì‹œìŠ¤í…œì˜ ì¢…í•© í…ŒìŠ¤íŠ¸ ë° ê²€ì¦  
**ìš°ì„ ìˆœìœ„**: ì¤‘ê°„  
**ë³µì¡ë„**: ë‚®ìŒ  
**ì˜ˆìƒ ì†Œìš”ì‹œê°„**: 4-5ì‹œê°„  

## ğŸ“‹ ì‘ì—… ê°œìš”

ì§€ê¸ˆê¹Œì§€ êµ¬í˜„ëœ ëª¨ë“  ì›Œí¬ìŠ¤í˜ì´ìŠ¤ Docker í†µí•© ì»´í¬ë„ŒíŠ¸ë“¤ì´ í•¨ê»˜ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ëŠ”ì§€ ì¢…í•©ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸í•˜ê³  ê²€ì¦í•©ë‹ˆë‹¤. ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.

## ğŸ¯ ëª©í‘œ

1. **ì „ì²´ í”Œë¡œìš° ê²€ì¦**: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„±ë¶€í„° ì‚­ì œê¹Œì§€ ì „ì²´ ë¼ì´í”„ì‚¬ì´í´
2. **ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸**: Docker ì—ëŸ¬, ë„¤íŠ¸ì›Œí¬ ì¥ì•  ë“± ì˜ˆì™¸ ìƒí™©
3. **ì„±ëŠ¥ í…ŒìŠ¤íŠ¸**: ë™ì‹œ ë‹¤ì¤‘ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì²˜ë¦¬ ì„±ëŠ¥
4. **ë³´ì•ˆ ê²€ì¦**: ê²©ë¦¬ í™˜ê²½ ë° ë³´ì•ˆ ì œì•½ íš¨ê³¼
5. **ë¬¸ì„œí™”**: í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë° ì•Œë ¤ì§„ ì´ìŠˆ ë¬¸ì„œí™”

## ğŸ“‚ ì½”ë“œë² ì´ìŠ¤ ë¶„ì„

### í…ŒìŠ¤íŠ¸ ëŒ€ìƒ ì»´í¬ë„ŒíŠ¸
- `T01_S01_M04`: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì„œë¹„ìŠ¤ ê³„ì¸µ
- `T02_S01_M04`: Docker SDK ê¸°ë³¸ í´ë¼ì´ì–¸íŠ¸
- `T03_S01_M04`: ì»¬í…Œì´ë„ˆ ìƒëª…ì£¼ê¸° ê´€ë¦¬ì
- `T04_S01_M04`: í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ ë§ˆìš´íŠ¸ ì‹œìŠ¤í…œ
- `T05_S01_M04`: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒíƒœ ì¶”ì  ì‹œìŠ¤í…œ
- `T06_S01_M04`: ê¸°ë³¸ ê²©ë¦¬ í™˜ê²½ ì„¤ì •
- `T07_S01_M04`: API-Docker ì„œë¹„ìŠ¤ í†µí•©

### ê¸°ì¡´ í…ŒìŠ¤íŠ¸ êµ¬ì¡°
```
test/
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ process_test.go
â”‚   â””â”€â”€ stream_test.go
â”œâ”€â”€ e2e/
â”‚   â””â”€â”€ claude_workflow_test.go
â””â”€â”€ testdata/
```

### ì‹ ê·œ í…ŒìŠ¤íŠ¸ êµ¬ì¡°
```
test/integration/
â”œâ”€â”€ workspace_docker_test.go        # ì „ì²´ í†µí•© í…ŒìŠ¤íŠ¸ (ìƒˆë¡œ ìƒì„±)
â”œâ”€â”€ workspace_lifecycle_test.go     # ë¼ì´í”„ì‚¬ì´í´ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ workspace_isolation_test.go     # ê²©ë¦¬ í™˜ê²½ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ workspace_performance_test.go   # ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
â””â”€â”€ workspace_error_test.go         # ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

test/e2e/
â””â”€â”€ workspace_complete_flow_test.go # ì¢…ë‹¨ê°„ í…ŒìŠ¤íŠ¸
```

## ğŸ› ï¸ ê¸°ìˆ  ê°€ì´ë“œ

### 1. ì „ì²´ í†µí•© í…ŒìŠ¤íŠ¸

```go
// test/integration/workspace_docker_test.go
package integration

import (
    "context"
    "testing"
    "time"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"
    "github.com/aicli/aicli-web/internal/models"
    "github.com/aicli/aicli-web/internal/services"
    "github.com/aicli/aicli-web/internal/docker"
    "github.com/aicli/aicli-web/internal/storage"
)

type WorkspaceDockerTestSuite struct {
    suite.Suite
    
    // í…ŒìŠ¤íŠ¸ ì¸í”„ë¼
    storage       storage.Storage
    dockerService *services.DockerWorkspaceService
    
    // í…ŒìŠ¤íŠ¸ ë°ì´í„°
    testWorkspaces []*models.Workspace
    testUser       string
}

func TestWorkspaceDockerSuite(t *testing.T) {
    if !isDockerAvailable() {
        t.Skip("Docker daemon not available, skipping integration tests")
    }
    
    suite.Run(t, new(WorkspaceDockerTestSuite))
}

func (suite *WorkspaceDockerTestSuite) SetupSuite() {
    // í…ŒìŠ¤íŠ¸ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
    suite.storage = setupTestStorage()
    
    // Docker ì„œë¹„ìŠ¤ ì„¤ì •
    dockerClient, err := docker.NewClient(docker.DefaultConfig())
    suite.Require().NoError(err)
    
    containerMgr := docker.NewContainerManager(dockerClient)
    baseService := services.NewWorkspaceService(suite.storage)
    
    suite.dockerService = services.NewDockerWorkspaceService(
        baseService, suite.storage, containerMgr, nil, nil,
    )
    
    suite.testUser = "test-user-" + generateRandomID()
    suite.testWorkspaces = make([]*models.Workspace, 0)
}

func (suite *WorkspaceDockerTestSuite) TearDownSuite() {
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° ì •ë¦¬
    suite.cleanupTestWorkspaces()
    suite.storage.Close()
}

func (suite *WorkspaceDockerTestSuite) TearDownTest() {
    // ê° í…ŒìŠ¤íŠ¸ í›„ ì •ë¦¬
    suite.cleanupTestContainers()
}
```

### 2. ë¼ì´í”„ì‚¬ì´í´ í…ŒìŠ¤íŠ¸

```go
// ì „ì²´ ë¼ì´í”„ì‚¬ì´í´ í…ŒìŠ¤íŠ¸
func (suite *WorkspaceDockerTestSuite) TestWorkspaceCompleteLifecycle() {
    ctx := context.Background()
    
    // Phase 1: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„±
    req := &models.CreateWorkspaceRequest{
        Name:        "test-lifecycle-workspace",
        ProjectPath: suite.createTempProject(),
    }
    
    workspace, err := suite.dockerService.CreateWorkspace(ctx, req, suite.testUser)
    suite.Require().NoError(err)
    suite.NotEmpty(workspace.ID)
    suite.Equal(models.WorkspaceStatusActive, workspace.Status)
    
    // Phase 2: Docker ì»¬í…Œì´ë„ˆ í™•ì¸
    containers, err := suite.getWorkspaceContainers(workspace.ID)
    suite.Require().NoError(err)
    suite.Len(containers, 1)
    suite.Equal(docker.ContainerStateRunning, containers[0].State)
    
    // Phase 3: ìƒíƒœ ë™ê¸°í™” ê²€ì¦
    suite.Eventually(func() bool {
        ws, err := suite.dockerService.GetWorkspace(ctx, workspace.ID, suite.testUser)
        return err == nil && ws.Status == models.WorkspaceStatusActive
    }, 30*time.Second, 1*time.Second)
    
    // Phase 4: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì¤‘ì§€
    err = suite.dockerService.StopWorkspace(ctx, workspace.ID, suite.testUser)
    suite.Require().NoError(err)
    
    // ì¤‘ì§€ í›„ ìƒíƒœ ë° ì»¬í…Œì´ë„ˆ í™•ì¸
    suite.Eventually(func() bool {
        ws, _ := suite.dockerService.GetWorkspace(ctx, workspace.ID, suite.testUser)
        containers, _ := suite.getWorkspaceContainers(workspace.ID)
        return ws.Status == models.WorkspaceStatusInactive && 
               len(containers) > 0 && containers[0].State == docker.ContainerStateExited
    }, 15*time.Second, 1*time.Second)
    
    // Phase 5: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì¬ì‹œì‘
    err = suite.dockerService.StartWorkspace(ctx, workspace.ID, suite.testUser)
    suite.Require().NoError(err)
    
    suite.Eventually(func() bool {
        containers, _ := suite.getWorkspaceContainers(workspace.ID)
        return len(containers) > 0 && containers[0].State == docker.ContainerStateRunning
    }, 15*time.Second, 1*time.Second)
    
    // Phase 6: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì‚­ì œ
    err = suite.dockerService.DeleteWorkspace(ctx, workspace.ID, suite.testUser)
    suite.Require().NoError(err)
    
    // ì‚­ì œ í›„ ì»¬í…Œì´ë„ˆ ë° DB ì •ë¦¬ í™•ì¸
    suite.Eventually(func() bool {
        // DBì—ì„œ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì‚­ì œ í™•ì¸
        _, err := suite.dockerService.GetWorkspace(ctx, workspace.ID, suite.testUser)
        if err == nil {
            return false // ì•„ì§ ì¡´ì¬
        }
        
        // Docker ì»¬í…Œì´ë„ˆ ì‚­ì œ í™•ì¸
        containers, _ := suite.getWorkspaceContainers(workspace.ID)
        return len(containers) == 0
    }, 20*time.Second, 1*time.Second)
}

// ë™ì‹œ ë‹¤ì¤‘ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸
func (suite *WorkspaceDockerTestSuite) TestConcurrentWorkspaceOperations() {
    ctx := context.Background()
    concurrency := 5
    
    // ë™ì‹œ ìƒì„± í…ŒìŠ¤íŠ¸
    var workspaces []*models.Workspace
    workspaceChan := make(chan *models.Workspace, concurrency)
    errorChan := make(chan error, concurrency)
    
    for i := 0; i < concurrency; i++ {
        go func(index int) {
            req := &models.CreateWorkspaceRequest{
                Name:        fmt.Sprintf("concurrent-workspace-%d", index),
                ProjectPath: suite.createTempProject(),
            }
            
            workspace, err := suite.dockerService.CreateWorkspace(ctx, req, suite.testUser)
            if err != nil {
                errorChan <- err
                return
            }
            workspaceChan <- workspace
        }(i)
    }
    
    // ê²°ê³¼ ìˆ˜ì§‘
    for i := 0; i < concurrency; i++ {
        select {
        case workspace := <-workspaceChan:
            workspaces = append(workspaces, workspace)
        case err := <-errorChan:
            suite.Fail("Concurrent workspace creation failed", err)
        case <-time.After(30 * time.Second):
            suite.Fail("Timeout waiting for concurrent workspace creation")
        }
    }
    
    suite.Len(workspaces, concurrency)
    
    // ëª¨ë“  ì›Œí¬ìŠ¤í˜ì´ìŠ¤ê°€ ì˜¬ë°”ë¥´ê²Œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
    for _, workspace := range workspaces {
        containers, err := suite.getWorkspaceContainers(workspace.ID)
        suite.NoError(err)
        suite.NotEmpty(containers)
        
        suite.testWorkspaces = append(suite.testWorkspaces, workspace)
    }
}
```

### 3. ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

```go
// test/integration/workspace_error_test.go
package integration

func (suite *WorkspaceDockerTestSuite) TestDockerDaemonFailure() {
    ctx := context.Background()
    
    // ì •ìƒì ì¸ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„±
    workspace := suite.createTestWorkspace()
    
    // Docker daemon ì¤‘ë‹¨ ì‹œë®¤ë ˆì´ì…˜ 
    // (ì‹¤ì œ í…ŒìŠ¤íŠ¸ì—ì„œëŠ” mockì„ ì‚¬ìš©)
    suite.simulateDockerFailure()
    
    // ì—ëŸ¬ ë°œìƒ ì‹œ ì„œë¹„ìŠ¤ ë™ì‘ ê²€ì¦
    _, err := suite.dockerService.GetWorkspaceStatus(ctx, workspace.ID)
    suite.Error(err)
    suite.True(docker.IsDockerError(err))
    
    // ìë™ ë³µêµ¬ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
    suite.restoreDockerConnection()
    
    // ë³µêµ¬ í›„ ì •ìƒ ë™ì‘ í™•ì¸
    suite.Eventually(func() bool {
        status, err := suite.dockerService.GetWorkspaceStatus(ctx, workspace.ID)
        return err == nil && status != nil
    }, 30*time.Second, 2*time.Second)
}

func (suite *WorkspaceDockerTestSuite) TestInvalidProjectPath() {
    ctx := context.Background()
    
    // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ë¡œ
    req := &models.CreateWorkspaceRequest{
        Name:        "invalid-path-workspace",
        ProjectPath: "/nonexistent/path/to/project",
    }
    
    _, err := suite.dockerService.CreateWorkspace(ctx, req, suite.testUser)
    suite.Error(err)
    suite.Contains(err.Error(), "invalid project path")
}

func (suite *WorkspaceDockerTestSuite) TestResourceLimitViolation() {
    ctx := context.Background()
    
    // ë¦¬ì†ŒìŠ¤ ì œí•œì„ ì´ˆê³¼í•˜ëŠ” ìš”ì²­
    workspace := suite.createTestWorkspace()
    
    // CPU ì‚¬ìš©ëŸ‰ ì¦ê°€ ì‹œë®¤ë ˆì´ì…˜ (stress test)
    err := suite.simulateHighCPUUsage(workspace.ID)
    suite.NoError(err)
    
    // ë¦¬ì†ŒìŠ¤ ì œí•œ ìœ„ë°˜ ê°ì§€ ëŒ€ê¸°
    suite.Eventually(func() bool {
        violations := suite.getResourceViolations(workspace.ID)
        return len(violations) > 0 && violations[0].Type == "cpu_high_usage"
    }, 60*time.Second, 5*time.Second)
    
    // ìë™ ì œí•œ ì ìš© í™•ì¸
    containers, err := suite.getWorkspaceContainers(workspace.ID)
    suite.NoError(err)
    suite.NotEmpty(containers)
    
    // CPU ì œí•œì´ ì ìš©ë˜ì—ˆëŠ”ì§€ í™•ì¸
    suite.True(containers[0].Stats.CPUPercent < 100.0) // ì œí•œëœ ìƒíƒœ
}
```

### 4. ë³´ì•ˆ ë° ê²©ë¦¬ í…ŒìŠ¤íŠ¸

```go
// test/integration/workspace_isolation_test.go
func (suite *WorkspaceDockerTestSuite) TestNetworkIsolation() {
    ctx := context.Background()
    
    // ë‘ ê°œì˜ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„±
    workspace1 := suite.createTestWorkspace("workspace-1")
    workspace2 := suite.createTestWorkspace("workspace-2")
    
    // ê° ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì˜ ë„¤íŠ¸ì›Œí¬ ì„¤ì • í™•ì¸
    containers1, _ := suite.getWorkspaceContainers(workspace1.ID)
    containers2, _ := suite.getWorkspaceContainers(workspace2.ID)
    
    suite.NotEmpty(containers1)
    suite.NotEmpty(containers2)
    
    // ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬ í…ŒìŠ¤íŠ¸
    isolated := suite.testNetworkIsolation(containers1[0].ID, containers2[0].ID)
    suite.True(isolated, "Workspaces should be network isolated")
}

func (suite *WorkspaceDockerTestSuite) TestSecurityConstraints() {
    ctx := context.Background()
    workspace := suite.createTestWorkspace()
    
    containers, err := suite.getWorkspaceContainers(workspace.ID)
    suite.NoError(err)
    suite.NotEmpty(containers)
    
    container := containers[0]
    
    // ë³´ì•ˆ ì„¤ì • ê²€ì¦
    inspect, err := suite.inspectContainer(container.ID)
    suite.NoError(err)
    
    // Capability ì œí•œ ê²€ì¦
    suite.Contains(inspect.HostConfig.CapDrop, "ALL")
    suite.NotContains(inspect.HostConfig.CapAdd, "SYS_ADMIN")
    
    // ê¶Œí•œ ì œí•œ ê²€ì¦
    suite.False(inspect.HostConfig.Privileged)
    suite.True(inspect.HostConfig.SecurityOpt != nil)
    
    // íŒŒì¼ ì‹œìŠ¤í…œ ì ‘ê·¼ í…ŒìŠ¤íŠ¸
    forbidden := suite.testForbiddenFileAccess(container.ID)
    suite.True(forbidden, "Should not have access to sensitive system files")
}

func (suite *WorkspaceDockerTestSuite) testNetworkIsolation(container1ID, container2ID string) bool {
    // ì»¸í…Œì´ë„ˆ 1ì—ì„œ ì»¸í…Œì´ë„ˆ 2ë¡œ ping ì‹œë„
    cmd := []string{"ping", "-c", "1", "-W", "2", suite.getContainerIP(container2ID)}
    result, err := suite.execInContainer(container1ID, cmd)
    
    // pingì´ ì‹¤íŒ¨í•´ì•¼ ì •ìƒ (ê²©ë¦¬ë˜ì–´ ìˆìŒ)
    return err != nil || result.ExitCode != 0
}
```

### 5. ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ í…ŒìŠ¤íŠ¸

```go
// test/integration/workspace_performance_test.go
func (suite *WorkspaceDockerTestSuite) TestPerformanceBenchmarks() {
    // ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„± ì‹œê°„ ë²¤ì¹˜ë§ˆí¬
    suite.benchmarkWorkspaceCreation()
    
    // ë™ì‹œ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì²˜ë¦¬ ì„±ëŠ¥
    suite.benchmarkConcurrentOperations()
    
    // ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ë²¤ì¹˜ë§ˆí¬
    suite.benchmarkResourceUsage()
}

func (suite *WorkspaceDockerTestSuite) benchmarkWorkspaceCreation() {
    iterations := 10
    var totalDuration time.Duration
    
    for i := 0; i < iterations; i++ {
        start := time.Now()
        
        req := &models.CreateWorkspaceRequest{
            Name:        fmt.Sprintf("benchmark-workspace-%d", i),
            ProjectPath: suite.createTempProject(),
        }
        
        workspace, err := suite.dockerService.CreateWorkspace(context.Background(), req, suite.testUser)
        suite.NoError(err)
        
        // ì™„ì „íˆ ìƒì„±ë  ë•Œê¹Œì§€ ëŒ€ê¸°
        suite.waitForContainerRunning(workspace.ID, 30*time.Second)
        
        duration := time.Since(start)
        totalDuration += duration
        
        suite.testWorkspaces = append(suite.testWorkspaces, workspace)
    }
    
    avgDuration := totalDuration / time.Duration(iterations)
    suite.T().Logf("Average workspace creation time: %v", avgDuration)
    suite.Less(avgDuration, 10*time.Second, "Workspace creation should be faster than 10 seconds")
}

func (suite *WorkspaceDockerTestSuite) benchmarkConcurrentOperations() {
    concurrency := 20
    start := time.Now()
    
    var wg sync.WaitGroup
    results := make(chan error, concurrency)
    
    for i := 0; i < concurrency; i++ {
        wg.Add(1)
        go func(index int) {
            defer wg.Done()
            
            req := &models.CreateWorkspaceRequest{
                Name:        fmt.Sprintf("concurrent-perf-workspace-%d", index),
                ProjectPath: suite.createTempProject(),
            }
            
            _, err := suite.dockerService.CreateWorkspace(context.Background(), req, suite.testUser)
            results <- err
        }(i)
    }
    
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // ê²°ê³¼ ìˆ˜ì§‘
    successCount := 0
    for err := range results {
        if err == nil {
            successCount++
        }
    }
    
    duration := time.Since(start)
    suite.T().Logf("Concurrent operations (%d workspaces): %v, Success rate: %d/%d", 
                   concurrency, duration, successCount, concurrency)
    
    suite.GreaterOrEqual(successCount, concurrency*8/10, "At least 80% success rate expected")
    suite.Less(duration, 60*time.Second, "Concurrent operations should complete within 60 seconds")
}
```

### 6. ì¢…ë‹¨ê°„ (E2E) í…ŒìŠ¤íŠ¸

```go
// test/e2e/workspace_complete_flow_test.go
package e2e

func TestCompleteWorkspaceFlow(t *testing.T) {
    // API ì„œë²„ ì‹œì‘
    server := startTestAPIServer(t)
    defer server.Close()
    
    client := &http.Client{Timeout: 30 * time.Second}
    baseURL := server.URL
    
    // Phase 1: ì‚¬ìš©ì ë¡œê·¸ì¸
    token := authenticateTestUser(t, client, baseURL)
    
    // Phase 2: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„± API í˜¸ì¶œ
    workspace := createWorkspaceViaAPI(t, client, baseURL, token, WorkspaceCreateRequest{
        Name:        "e2e-test-workspace",
        ProjectPath: createTempTestProject(t),
    })
    
    // Phase 3: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒíƒœ í™•ì¸
    eventually(t, 30*time.Second, func() bool {
        status := getWorkspaceStatusViaAPI(t, client, baseURL, token, workspace.ID)
        return status.ContainerStatus.ContainerState == "running"
    })
    
    // Phase 4: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì¤‘ì§€/ì‹œì‘ API í…ŒìŠ¤íŠ¸
    stopWorkspaceViaAPI(t, client, baseURL, token, workspace.ID)
    eventually(t, 15*time.Second, func() bool {
        status := getWorkspaceStatusViaAPI(t, client, baseURL, token, workspace.ID)
        return status.Workspace.Status == "inactive"
    })
    
    startWorkspaceViaAPI(t, client, baseURL, token, workspace.ID)
    eventually(t, 15*time.Second, func() bool {
        status := getWorkspaceStatusViaAPI(t, client, baseURL, token, workspace.ID)
        return status.Workspace.Status == "active"
    })
    
    // Phase 5: ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì‚­ì œ
    deleteWorkspaceViaAPI(t, client, baseURL, token, workspace.ID)
    
    // Phase 6: ì‚­ì œ í›„ ì¡°íšŒ ì‹œ 404 í™•ì¸
    eventually(t, 20*time.Second, func() bool {
        resp, err := client.Get(fmt.Sprintf("%s/api/workspaces/%s", baseURL, workspace.ID))
        return err == nil && resp.StatusCode == http.StatusNotFound
    })
}
```

## âœ… ì™„ë£Œ ê¸°ì¤€

### ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [ ] ì „ì²´ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë¼ì´í”„ì‚¬ì´í´ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ë™ì‹œ ë‹¤ì¤‘ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] Docker ì—ëŸ¬ ë° ë³µêµ¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ë³´ì•ˆ ë° ê²©ë¦¬ íš¨ê³¼ ê²€ì¦
- [ ] E2E API í…ŒìŠ¤íŠ¸ í†µê³¼

### ë¹„ê¸°ëŠ¥ì  ìš”êµ¬ì‚¬í•­
- [ ] ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„± ì„±ëŠ¥ < 10ì´ˆ
- [ ] ë™ì‹œ ì‘ì—… ì„±ê³µë¥  > 80%
- [ ] ëª¨ë“  í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ í†µê³¼ë¥  100%
- [ ] í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ > 80%

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ê°€ì´ë“œ

### ë¡œì»¬ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
```bash
# Docker daemon ì‹œì‘ í™•ì¸
sudo systemctl start docker

# í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰
go test ./test/integration/... -v -timeout 10m

# ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
go test ./test/integration/ -bench=. -v

# E2E í…ŒìŠ¤íŠ¸ ì‹¤í–‰
go test ./test/e2e/... -v -timeout 15m

# ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„±
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html
```

### CI/CD í™˜ê²½ ì„¤ì •
```yaml
# .github/workflows/integration-test.yml
name: Integration Tests

on: [push, pull_request]

jobs:
  integration-test:
    runs-on: ubuntu-latest
    services:
      docker:
        image: docker:dind
        options: --privileged
        
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.21
    
    - name: Wait for Docker
      run: |
        timeout 60 sh -c 'until docker info; do sleep 1; done'
    
    - name: Run Integration Tests
      run: |
        go test ./test/integration/... -v -timeout 10m
        
    - name: Run E2E Tests
      run: |
        go test ./test/e2e/... -v -timeout 15m
```

## ğŸ“ êµ¬í˜„ ë‹¨ê³„

1. **Phase 1**: í…ŒìŠ¤íŠ¸ ì¸í”„ë¼ ì„¤ì • ë° ê¸°ë³¸ í†µí•© í…ŒìŠ¤íŠ¸ (1.5ì‹œê°„)
2. **Phase 2**: ë¼ì´í”„ì‚¬ì´í´ ë° ì—ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ (1.5ì‹œê°„)
3. **Phase 3**: ë³´ì•ˆ/ê²©ë¦¬ ë° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (1ì‹œê°„)
4. **Phase 4**: E2E í…ŒìŠ¤íŠ¸ ë° CI ì„¤ì • (0.5ì‹œê°„)
5. **Phase 5**: í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë¶„ì„ ë° ë¬¸ì„œí™” (0.5ì‹œê°„)

## ğŸ”— ì—°ê´€ íƒœìŠ¤í¬

- **ì˜ì¡´ì„±**: ëª¨ë“  ì´ì „ íƒœìŠ¤í¬ (T01~T07) ì™„ë£Œ í•„ìˆ˜
- **ì™„ë£Œ í›„**: S01_M04 ìŠ¤í”„ë¦°íŠ¸ ì™„ë£Œ ë° ë‹¤ìŒ ìŠ¤í”„ë¦°íŠ¸ ì¤€ë¹„
- **í•™ìŠµ ë°ì´í„°**: í–¥í›„ ì„±ëŠ¥ ìµœì í™” ë° ê°œì„  ì‚¬í•­ ë„ì¶œ

## ğŸ“š ì°¸ê³  ìë£Œ

- [Go Testing ê°€ì´ë“œ](https://golang.org/doc/tutorial/add-a-test)
- [Testify Testing Framework](https://github.com/stretchr/testify)
- [Docker Test Containers](https://golang.testcontainers.org/)
- [Integration Testing Best Practices](https://martinfowler.com/articles/practical-test-pyramid.html)