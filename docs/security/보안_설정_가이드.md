# 보안 설정 가이드

## 개요

AICode Manager는 Claude CLI를 안전하게 관리하기 위한 다층 보안 시스템을 제공합니다. 이 문서는 시스템의 모든 보안 기능에 대한 설정 방법과 모범 사례를 제공합니다.

## 목차

1. [환경 설정 및 기본 보안](#환경-설정-및-기본-보안)
2. [인증 및 권한 관리](#인증-및-권한-관리)
3. [세션 관리](#세션-관리)
4. [API 보안](#api-보안)
5. [Docker 컨테이너 보안](#docker-컨테이너-보안)
6. [네트워크 보안](#네트워크-보안)
7. [로깅 및 감사](#로깅-및-감사)
8. [공격 탐지 및 차단](#공격-탐지-및-차단)
9. [정기 보안 점검](#정기-보안-점검)

## 환경 설정 및 기본 보안

### 환경 변수 설정

```bash
# JWT 설정
JWT_SECRET_KEY=your-super-secret-jwt-key-at-least-32-characters
JWT_ISSUER=aicli-web
JWT_AUDIENCE=aicli-users
JWT_EXPIRY=24h

# OAuth2 설정
GOOGLE_CLIENT_ID=your-google-oauth-client-id
GOOGLE_CLIENT_SECRET=your-google-oauth-client-secret
GITHUB_CLIENT_ID=your-github-oauth-client-id
GITHUB_CLIENT_SECRET=your-github-oauth-client-secret

# 세션 보안
SESSION_SECRET_KEY=your-session-secret-key-32-chars
SESSION_REDIS_URL=redis://localhost:6379/0
SESSION_REDIS_PASSWORD=your-redis-password

# API 보안
API_RATE_LIMIT_GLOBAL=1000
API_RATE_LIMIT_USER=100
API_RATE_LIMIT_IP=50

# CSRF 보호
CSRF_SECRET_KEY=your-csrf-secret-32-characters
CSRF_TRUSTED_ORIGINS=https://yourdomain.com,https://www.yourdomain.com

# 데이터베이스 암호화
DB_ENCRYPTION_KEY=your-database-encryption-key-32-chars

# 로깅
LOG_LEVEL=info
AUDIT_LOG_ENABLED=true
SECURITY_LOG_ENABLED=true

# Docker 보안
DOCKER_SECURITY_PROFILE=strict
DOCKER_RESOURCE_LIMITS=enabled
```

### 설정 파일 (config.yml)

```yaml
# 기본 서버 설정
server:
  host: 0.0.0.0
  port: 8080
  read_timeout: 30s
  write_timeout: 30s
  idle_timeout: 60s
  shutdown_timeout: 30s

# 보안 설정
security:
  # TLS/HTTPS 설정
  tls:
    enabled: true
    cert_file: "/path/to/cert.pem"
    key_file: "/path/to/key.pem"
    min_version: "1.2"
    ciphers:
      - "ECDHE-RSA-AES256-GCM-SHA384"
      - "ECDHE-RSA-AES128-GCM-SHA256"
      - "ECDHE-RSA-AES256-SHA384"

  # CORS 설정
  cors:
    allowed_origins:
      - "https://yourdomain.com"
      - "https://www.yourdomain.com"
    allowed_methods:
      - "GET"
      - "POST"
      - "PUT"
      - "DELETE"
    allowed_headers:
      - "Authorization"
      - "Content-Type"
      - "X-CSRF-Token"
      - "X-Requested-With"
    exposed_headers:
      - "X-Total-Count"
    allow_credentials: true
    max_age: 3600

  # 보안 헤더
  headers:
    hsts_max_age: 31536000
    hsts_include_subdomains: true
    frame_options: "DENY"
    content_type_nosniff: true
    xss_protection: "1; mode=block"
    csp: "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'"
    referrer_policy: "strict-origin-when-cross-origin"

# JWT 설정
jwt:
  secret_key: "${JWT_SECRET_KEY}"
  issuer: "${JWT_ISSUER}"
  audience: "${JWT_AUDIENCE}"
  expiry: "${JWT_EXPIRY}"
  refresh_expiry: "168h"  # 7 days
  algorithm: "HS256"
  
  # JWT 블랙리스트 (로그아웃된 토큰)
  blacklist:
    enabled: true
    cleanup_interval: "1h"
    max_entries: 10000

# OAuth2 설정
oauth2:
  google:
    client_id: "${GOOGLE_CLIENT_ID}"
    client_secret: "${GOOGLE_CLIENT_SECRET}"
    redirect_url: "https://yourdomain.com/auth/callback/google"
    scopes:
      - "openid"
      - "profile"
      - "email"
  
  github:
    client_id: "${GITHUB_CLIENT_ID}"
    client_secret: "${GITHUB_CLIENT_SECRET}"
    redirect_url: "https://yourdomain.com/auth/callback/github"
    scopes:
      - "user:email"
      - "read:user"

# RBAC (역할 기반 접근 제어)
rbac:
  enabled: true
  cache:
    ttl: "5m"
    size: 1000
  
  roles:
    admin:
      description: "시스템 관리자"
      permissions:
        - "system:*"
        - "user:*"
        - "workspace:*"
        - "project:*"
        - "task:*"
    
    user:
      description: "일반 사용자"
      permissions:
        - "workspace:create"
        - "workspace:read"
        - "workspace:update"
        - "workspace:delete:own"
        - "project:create"
        - "project:read:own"
        - "project:update:own"
        - "project:delete:own"
        - "task:*:own"
    
    viewer:
      description: "읽기 전용 사용자"
      permissions:
        - "workspace:read:own"
        - "project:read:own"
        - "task:read:own"

# 세션 관리
session:
  store: "redis"
  redis:
    url: "${SESSION_REDIS_URL}"
    password: "${SESSION_REDIS_PASSWORD}"
    db: 0
    pool_size: 100
  
  security:
    max_concurrent_sessions: 5
    session_timeout: "30m"
    idle_timeout: "15m"
    secure_cookie: true
    same_site: "strict"
    device_tracking: true
    geo_location_check: true
    
    # 세션 보안 정책
    policies:
      force_logout_on_location_change: false
      require_reauthentication_on_ip_change: true
      max_failed_attempts: 5
      lockout_duration: "30m"

# Rate Limiting
rate_limit:
  global:
    requests: 1000
    window: "1m"
    
  per_ip:
    requests: 100
    window: "1m"
    
  per_user:
    requests: 500
    window: "1m"
  
  # 엔드포인트별 제한
  endpoints:
    "/api/v1/auth/login":
      requests: 5
      window: "1m"
    "/api/v1/auth/register":
      requests: 3
      window: "5m"
    "/api/v1/workspaces":
      requests: 50
      window: "1m"

# CSRF 보호
csrf:
  secret_key: "${CSRF_SECRET_KEY}"
  token_lifetime: "24h"
  secure_cookie: true
  same_site: "strict"
  trusted_origins:
    - "https://yourdomain.com"
    - "https://www.yourdomain.com"

# 데이터베이스 보안
database:
  encryption:
    enabled: true
    key: "${DB_ENCRYPTION_KEY}"
    algorithm: "AES-256-GCM"
    
    # 암호화할 필드
    encrypted_fields:
      - "users.oauth_tokens"
      - "sessions.data"
      - "workspaces.environment_vars"
      
  backup:
    enabled: true
    encryption: true
    schedule: "0 2 * * *"  # 매일 새벽 2시
    retention: "30d"

# 감사 로깅
audit:
  enabled: true
  storage: "database"  # file, database, both
  
  events:
    authentication:
      - "login"
      - "logout" 
      - "login_failed"
      - "token_refresh"
    
    authorization:
      - "permission_denied"
      - "role_changed"
    
    data_access:
      - "workspace_created"
      - "workspace_deleted"
      - "project_accessed"
      - "task_executed"
    
    security:
      - "password_changed"
      - "session_terminated"
      - "suspicious_activity"

# 보안 모니터링
monitoring:
  attack_detection:
    enabled: true
    
    # SQL Injection 탐지
    sql_injection:
      enabled: true
      patterns:
        - "union\\s+select"
        - "drop\\s+table"
        - "or\\s+1\\s*=\\s*1"
        - "script\\s*:"
    
    # XSS 탐지
    xss_detection:
      enabled: true
      patterns:
        - "<script[^>]*>"
        - "javascript:"
        - "on\\w+\\s*="
    
    # 브루트포스 공격 탐지
    brute_force:
      enabled: true
      max_attempts: 5
      window: "5m"
      block_duration: "30m"
  
  alerts:
    enabled: true
    channels:
      - type: "email"
        recipients:
          - "admin@yourdomain.com"
      - type: "slack"
        webhook_url: "https://hooks.slack.com/services/..."
    
    thresholds:
      failed_logins: 10
      rate_limit_violations: 100
      attack_attempts: 5

# Docker 보안
docker:
  security:
    # 컨테이너 격리
    isolation:
      enabled: true
      user_namespace: true
      pid_namespace: true
      network_namespace: true
      
    # 리소스 제한
    resources:
      memory_limit: "2g"
      cpu_limit: "1.0"
      pids_limit: 1024
      
    # 보안 프로필
    security_profiles:
      apparmor: "/path/to/apparmor/profile"
      seccomp: "/path/to/seccomp/profile.json"
      
    # 네트워크 보안
    network:
      bridge_name: "aicli-secure"
      isolate_containers: true
      allowed_ports:
        - "80"
        - "443"
```

## 인증 및 권한 관리

### 1. JWT 토큰 관리

#### JWT 설정 예시 (Go)

```go
// internal/auth/jwt.go
package auth

import (
    "crypto/rand"
    "encoding/base64"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
)

type JWTConfig struct {
    SecretKey    string        `yaml:"secret_key"`
    Issuer       string        `yaml:"issuer"`
    Audience     string        `yaml:"audience"`
    Expiry       time.Duration `yaml:"expiry"`
    RefreshExpiry time.Duration `yaml:"refresh_expiry"`
    Algorithm    string        `yaml:"algorithm"`
}

type JWTManager struct {
    config    *JWTConfig
    blacklist *TokenBlacklist
}

func NewJWTManager(config *JWTConfig) *JWTManager {
    return &JWTManager{
        config:    config,
        blacklist: NewTokenBlacklist(),
    }
}

// JWT 토큰 생성
func (j *JWTManager) GenerateToken(userID string, role string, permissions []string) (string, error) {
    now := time.Now()
    
    claims := &CustomClaims{
        UserID:      userID,
        Role:        role,
        Permissions: permissions,
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    j.config.Issuer,
            Audience:  jwt.ClaimStrings{j.config.Audience},
            ExpiresAt: jwt.NewNumericDate(now.Add(j.config.Expiry)),
            NotBefore: jwt.NewNumericDate(now),
            IssuedAt:  jwt.NewNumericDate(now),
            ID:        generateJTI(), // 토큰 고유 ID
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(j.config.SecretKey))
}

// JWT 토큰 검증
func (j *JWTManager) ValidateToken(tokenString string) (*CustomClaims, error) {
    // 블랙리스트 확인
    if j.blacklist.IsBlacklisted(tokenString) {
        return nil, ErrTokenBlacklisted
    }
    
    token, err := jwt.ParseWithClaims(
        tokenString,
        &CustomClaims{},
        func(token *jwt.Token) (interface{}, error) {
            return []byte(j.config.SecretKey), nil
        },
        jwt.WithValidMethods([]string{j.config.Algorithm}),
    )
    
    if err != nil {
        return nil, err
    }
    
    if !token.Valid {
        return nil, ErrInvalidToken
    }
    
    claims, ok := token.Claims.(*CustomClaims)
    if !ok {
        return nil, ErrInvalidClaims
    }
    
    return claims, nil
}

// 토큰 블랙리스트 추가 (로그아웃)
func (j *JWTManager) BlacklistToken(tokenString string, expiry time.Time) error {
    return j.blacklist.Add(tokenString, expiry)
}

// JTI 생성 (토큰 고유 ID)
func generateJTI() string {
    bytes := make([]byte, 32)
    rand.Read(bytes)
    return base64.URLEncoding.EncodeToString(bytes)
}
```

### 2. RBAC (역할 기반 접근 제어)

#### RBAC 미들웨어

```go
// internal/auth/rbac_middleware.go
package auth

import (
    "context"
    "net/http"
    "strings"
    
    "github.com/gin-gonic/gin"
)

// 권한 확인 미들웨어
func RequirePermission(permission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        claims := GetClaimsFromContext(c)
        if claims == nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "인증이 필요합니다"})
            c.Abort()
            return
        }
        
        // 권한 확인
        if !hasPermission(claims.Permissions, permission) {
            c.JSON(http.StatusForbidden, gin.H{"error": "권한이 부족합니다"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// 역할 확인 미들웨어
func RequireRole(requiredRoles ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        claims := GetClaimsFromContext(c)
        if claims == nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "인증이 필요합니다"})
            c.Abort()
            return
        }
        
        // 역할 확인
        for _, role := range requiredRoles {
            if claims.Role == role {
                c.Next()
                return
            }
        }
        
        c.JSON(http.StatusForbidden, gin.H{"error": "필요한 역할이 없습니다"})
        c.Abort()
    }
}

// 동적 권한 확인 (리소스 소유권 등)
func RequireResourceAccess(resourceType string) gin.HandlerFunc {
    return func(c *gin.Context) {
        claims := GetClaimsFromContext(c)
        if claims == nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "인증이 필요합니다"})
            c.Abort()
            return
        }
        
        resourceID := c.Param("id")
        if resourceID == "" {
            c.JSON(http.StatusBadRequest, gin.H{"error": "리소스 ID가 필요합니다"})
            c.Abort()
            return
        }
        
        // 관리자는 모든 리소스 접근 가능
        if claims.Role == "admin" {
            c.Next()
            return
        }
        
        // 리소스 소유권 확인
        if !checkResourceOwnership(claims.UserID, resourceType, resourceID) {
            c.JSON(http.StatusForbidden, gin.H{"error": "해당 리소스에 접근할 권한이 없습니다"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// 권한 확인 함수
func hasPermission(userPermissions []string, requiredPermission string) bool {
    for _, perm := range userPermissions {
        if perm == requiredPermission || perm == "*" {
            return true
        }
        
        // 와일드카드 권한 확인 (예: "workspace:*")
        if strings.HasSuffix(perm, ":*") {
            prefix := strings.TrimSuffix(perm, ":*")
            if strings.HasPrefix(requiredPermission, prefix+":") {
                return true
            }
        }
    }
    return false
}
```

### 3. OAuth2 통합

```go
// internal/auth/oauth2.go
package auth

import (
    "context"
    "crypto/rand"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "net/http"
    
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/github"
    "golang.org/x/oauth2/google"
)

type OAuth2Manager struct {
    providers map[string]*oauth2.Config
    states    map[string]StateInfo // CSRF 보호용 state 저장
}

type StateInfo struct {
    Value     string
    Provider  string
    CreatedAt time.Time
    ExpiresAt time.Time
}

func NewOAuth2Manager(config *OAuth2Config) *OAuth2Manager {
    providers := make(map[string]*oauth2.Config)
    
    // Google OAuth2 설정
    if config.Google != nil {
        providers["google"] = &oauth2.Config{
            ClientID:     config.Google.ClientID,
            ClientSecret: config.Google.ClientSecret,
            RedirectURL:  config.Google.RedirectURL,
            Scopes:       config.Google.Scopes,
            Endpoint:     google.Endpoint,
        }
    }
    
    // GitHub OAuth2 설정
    if config.GitHub != nil {
        providers["github"] = &oauth2.Config{
            ClientID:     config.GitHub.ClientID,
            ClientSecret: config.GitHub.ClientSecret,
            RedirectURL:  config.GitHub.RedirectURL,
            Scopes:       config.GitHub.Scopes,
            Endpoint:     github.Endpoint,
        }
    }
    
    return &OAuth2Manager{
        providers: providers,
        states:    make(map[string]StateInfo),
    }
}

// OAuth2 로그인 시작
func (o *OAuth2Manager) BeginAuth(provider string) (string, error) {
    config, exists := o.providers[provider]
    if !exists {
        return "", fmt.Errorf("지원하지 않는 OAuth2 공급자: %s", provider)
    }
    
    // CSRF 보호용 state 생성
    state, err := o.generateState(provider)
    if err != nil {
        return "", err
    }
    
    // 인증 URL 생성
    authURL := config.AuthCodeURL(state, 
        oauth2.SetAuthURLParam("access_type", "offline"),
        oauth2.SetAuthURLParam("prompt", "consent"),
    )
    
    return authURL, nil
}

// OAuth2 콜백 처리
func (o *OAuth2Manager) HandleCallback(provider, code, state string) (*UserInfo, error) {
    // State 검증 (CSRF 보호)
    if !o.validateState(state, provider) {
        return nil, fmt.Errorf("잘못된 state 값입니다")
    }
    
    config, exists := o.providers[provider]
    if !exists {
        return nil, fmt.Errorf("지원하지 않는 OAuth2 공급자: %s", provider)
    }
    
    // 인증 코드로 토큰 교환
    token, err := config.Exchange(context.Background(), code)
    if err != nil {
        return nil, fmt.Errorf("토큰 교환 실패: %v", err)
    }
    
    // 사용자 정보 가져오기
    userInfo, err := o.getUserInfo(provider, token)
    if err != nil {
        return nil, err
    }
    
    // State 정리
    delete(o.states, state)
    
    return userInfo, nil
}

// State 생성 (CSRF 보호)
func (o *OAuth2Manager) generateState(provider string) (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    
    state := base64.URLEncoding.EncodeToString(bytes)
    
    o.states[state] = StateInfo{
        Value:     state,
        Provider:  provider,
        CreatedAt: time.Now(),
        ExpiresAt: time.Now().Add(10 * time.Minute), // 10분 후 만료
    }
    
    return state, nil
}

// State 검증
func (o *OAuth2Manager) validateState(state, provider string) bool {
    stateInfo, exists := o.states[state]
    if !exists {
        return false
    }
    
    // 만료 시간 확인
    if time.Now().After(stateInfo.ExpiresAt) {
        delete(o.states, state)
        return false
    }
    
    // Provider 확인
    return stateInfo.Provider == provider
}
```

## 세션 관리

### Redis 기반 세션 저장소

```go
// internal/session/redis_store.go
package session

import (
    "crypto/rand"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
)

type RedisSessionStore struct {
    client        *redis.Client
    keyPrefix     string
    maxSessions   int
    sessionExpiry time.Duration
    config        *SessionSecurityConfig
}

type SessionData struct {
    UserID          string                 `json:"user_id"`
    Role            string                 `json:"role"`
    Permissions     []string               `json:"permissions"`
    CreatedAt       time.Time              `json:"created_at"`
    LastAccessedAt  time.Time              `json:"last_accessed_at"`
    IPAddress       string                 `json:"ip_address"`
    UserAgent       string                 `json:"user_agent"`
    DeviceID        string                 `json:"device_id"`
    Location        *GeoLocation           `json:"location,omitempty"`
    Metadata        map[string]interface{} `json:"metadata"`
}

func NewRedisSessionStore(client *redis.Client, config *SessionSecurityConfig) *RedisSessionStore {
    return &RedisSessionStore{
        client:        client,
        keyPrefix:     "session:",
        maxSessions:   config.MaxConcurrentSessions,
        sessionExpiry: config.SessionTimeout,
        config:        config,
    }
}

// 세션 생성
func (r *RedisSessionStore) CreateSession(userID string, sessionData *SessionData) (string, error) {
    // 기존 세션 수 확인
    if err := r.enforceSessionLimit(userID); err != nil {
        return "", err
    }
    
    // 세션 ID 생성
    sessionID, err := r.generateSessionID()
    if err != nil {
        return "", err
    }
    
    sessionData.CreatedAt = time.Now()
    sessionData.LastAccessedAt = time.Now()
    
    // Redis에 저장
    key := r.keyPrefix + sessionID
    data, err := json.Marshal(sessionData)
    if err != nil {
        return "", err
    }
    
    err = r.client.Set(context.Background(), key, data, r.sessionExpiry).Err()
    if err != nil {
        return "", err
    }
    
    // 사용자별 세션 목록에 추가
    userSessionsKey := fmt.Sprintf("user_sessions:%s", userID)
    err = r.client.SAdd(context.Background(), userSessionsKey, sessionID).Err()
    if err != nil {
        return "", err
    }
    
    // 사용자 세션 목록 만료 시간 설정
    r.client.Expire(context.Background(), userSessionsKey, r.sessionExpiry)
    
    return sessionID, nil
}

// 세션 조회
func (r *RedisSessionStore) GetSession(sessionID string) (*SessionData, error) {
    key := r.keyPrefix + sessionID
    
    data, err := r.client.Get(context.Background(), key).Result()
    if err != nil {
        if err == redis.Nil {
            return nil, ErrSessionNotFound
        }
        return nil, err
    }
    
    var sessionData SessionData
    err = json.Unmarshal([]byte(data), &sessionData)
    if err != nil {
        return nil, err
    }
    
    return &sessionData, nil
}

// 세션 업데이트
func (r *RedisSessionStore) UpdateSession(sessionID string, sessionData *SessionData) error {
    sessionData.LastAccessedAt = time.Now()
    
    key := r.keyPrefix + sessionID
    data, err := json.Marshal(sessionData)
    if err != nil {
        return err
    }
    
    // TTL을 유지하면서 업데이트
    return r.client.Set(context.Background(), key, data, 0).Err()
}

// 세션 삭제
func (r *RedisSessionStore) DeleteSession(sessionID string, userID string) error {
    key := r.keyPrefix + sessionID
    
    // 세션 삭제
    err := r.client.Del(context.Background(), key).Err()
    if err != nil {
        return err
    }
    
    // 사용자 세션 목록에서 제거
    if userID != "" {
        userSessionsKey := fmt.Sprintf("user_sessions:%s", userID)
        r.client.SRem(context.Background(), userSessionsKey, sessionID)
    }
    
    return nil
}

// 사용자의 모든 세션 삭제 (강제 로그아웃)
func (r *RedisSessionStore) DeleteAllUserSessions(userID string) error {
    userSessionsKey := fmt.Sprintf("user_sessions:%s", userID)
    
    // 사용자의 모든 세션 ID 가져오기
    sessionIDs, err := r.client.SMembers(context.Background(), userSessionsKey).Result()
    if err != nil {
        return err
    }
    
    // 각 세션 삭제
    for _, sessionID := range sessionIDs {
        key := r.keyPrefix + sessionID
        r.client.Del(context.Background(), key)
    }
    
    // 사용자 세션 목록 삭제
    return r.client.Del(context.Background(), userSessionsKey).Err()
}

// 동시 세션 수 제한
func (r *RedisSessionStore) enforceSessionLimit(userID string) error {
    userSessionsKey := fmt.Sprintf("user_sessions:%s", userID)
    
    sessionCount, err := r.client.SCard(context.Background(), userSessionsKey).Result()
    if err != nil {
        return err
    }
    
    if int(sessionCount) >= r.maxSessions {
        // 가장 오래된 세션 삭제
        return r.removeOldestSession(userID)
    }
    
    return nil
}

// 세션 ID 생성
func (r *RedisSessionStore) generateSessionID() (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(bytes), nil
}
```

### 세션 보안 검사기

```go
// internal/session/security_checker.go
package session

import (
    "errors"
    "net"
    "strings"
    "time"
)

type SecurityChecker struct {
    geoService *GeoIPService
    config     *SessionSecurityConfig
}

type SecurityCheckResult struct {
    IsSecure      bool
    Warnings      []string
    Actions       []string
    RiskScore     int // 0-100
}

func NewSecurityChecker(geoService *GeoIPService, config *SessionSecurityConfig) *SecurityChecker {
    return &SecurityChecker{
        geoService: geoService,
        config:     config,
    }
}

// 세션 보안 검사
func (sc *SecurityChecker) CheckSession(sessionData *SessionData, currentIP, currentUserAgent string) (*SecurityCheckResult, error) {
    result := &SecurityCheckResult{
        IsSecure:  true,
        Warnings:  []string{},
        Actions:   []string{},
        RiskScore: 0,
    }
    
    // IP 주소 변경 검사
    if err := sc.checkIPChange(sessionData, currentIP, result); err != nil {
        return result, err
    }
    
    // User-Agent 변경 검사
    sc.checkUserAgentChange(sessionData, currentUserAgent, result)
    
    // 위치 변경 검사
    if sc.config.GeoLocationCheck {
        if err := sc.checkLocationChange(sessionData, currentIP, result); err != nil {
            return result, err
        }
    }
    
    // 세션 시간 검사
    sc.checkSessionTime(sessionData, result)
    
    // 비활성 시간 검사
    sc.checkIdleTime(sessionData, result)
    
    // 위험도에 따른 조치 결정
    sc.determineActions(result)
    
    return result, nil
}

// IP 주소 변경 검사
func (sc *SecurityChecker) checkIPChange(sessionData *SessionData, currentIP string, result *SecurityCheckResult) error {
    if sessionData.IPAddress != currentIP {
        // 같은 네트워크인지 확인
        if !sc.isSameNetwork(sessionData.IPAddress, currentIP) {
            result.RiskScore += 30
            result.Warnings = append(result.Warnings, "IP 주소가 변경되었습니다")
            
            if sc.config.RequireReauthenticationOnIPChange {
                result.IsSecure = false
                result.Actions = append(result.Actions, "재인증 필요")
            }
        } else {
            result.RiskScore += 10
            result.Warnings = append(result.Warnings, "같은 네트워크 내에서 IP가 변경되었습니다")
        }
    }
    
    return nil
}

// User-Agent 변경 검사
func (sc *SecurityChecker) checkUserAgentChange(sessionData *SessionData, currentUserAgent string, result *SecurityCheckResult) {
    if sessionData.UserAgent != currentUserAgent {
        // 브라우저 유형이 완전히 다른지 확인
        if sc.isDifferentBrowser(sessionData.UserAgent, currentUserAgent) {
            result.RiskScore += 40
            result.Warnings = append(result.Warnings, "브라우저가 변경되었습니다")
            result.IsSecure = false
            result.Actions = append(result.Actions, "세션 종료")
        } else {
            result.RiskScore += 15
            result.Warnings = append(result.Warnings, "브라우저 버전이 업데이트되었습니다")
        }
    }
}

// 위치 변경 검사
func (sc *SecurityChecker) checkLocationChange(sessionData *SessionData, currentIP string, result *SecurityCheckResult) error {
    if sessionData.Location == nil {
        // 첫 번째 위치 정보 저장
        location, err := sc.geoService.GetLocation(currentIP)
        if err != nil {
            return err
        }
        sessionData.Location = location
        return nil
    }
    
    currentLocation, err := sc.geoService.GetLocation(currentIP)
    if err != nil {
        return err
    }
    
    // 거리 계산
    distance := sc.calculateDistance(sessionData.Location, currentLocation)
    
    if distance > 1000 { // 1000km 이상 이동
        result.RiskScore += 50
        result.Warnings = append(result.Warnings, fmt.Sprintf("%.0fkm 떨어진 위치에서 접근했습니다", distance))
        
        if sc.config.ForceLogoutOnLocationChange {
            result.IsSecure = false
            result.Actions = append(result.Actions, "세션 종료")
        }
    } else if distance > 100 { // 100km 이상 이동
        result.RiskScore += 20
        result.Warnings = append(result.Warnings, "다른 도시에서 접근했습니다")
    }
    
    return nil
}

// 세션 시간 검사
func (sc *SecurityChecker) checkSessionTime(sessionData *SessionData, result *SecurityCheckResult) {
    sessionAge := time.Since(sessionData.CreatedAt)
    
    if sessionAge > sc.config.SessionTimeout {
        result.IsSecure = false
        result.Actions = append(result.Actions, "세션 만료")
    } else if sessionAge > sc.config.SessionTimeout/2 {
        result.RiskScore += 10
        result.Warnings = append(result.Warnings, "세션이 오래되었습니다")
    }
}

// 비활성 시간 검사
func (sc *SecurityChecker) checkIdleTime(sessionData *SessionData, result *SecurityCheckResult) {
    idleTime := time.Since(sessionData.LastAccessedAt)
    
    if idleTime > sc.config.IdleTimeout {
        result.IsSecure = false
        result.Actions = append(result.Actions, "비활성 시간 초과")
    } else if idleTime > sc.config.IdleTimeout/2 {
        result.RiskScore += 5
        result.Warnings = append(result.Warnings, "세션이 비활성 상태입니다")
    }
}

// 같은 네트워크인지 확인
func (sc *SecurityChecker) isSameNetwork(ip1, ip2 string) bool {
    // 간단한 서브넷 검사 (실제로는 더 정교한 로직 필요)
    parts1 := strings.Split(ip1, ".")
    parts2 := strings.Split(ip2, ".")
    
    if len(parts1) != 4 || len(parts2) != 4 {
        return false
    }
    
    // 같은 /24 네트워크인지 확인
    return parts1[0] == parts2[0] && parts1[1] == parts2[1] && parts1[2] == parts2[2]
}

// 다른 브라우저인지 확인
func (sc *SecurityChecker) isDifferentBrowser(ua1, ua2 string) bool {
    browsers := []string{"Chrome", "Firefox", "Safari", "Edge", "Opera"}
    
    browser1 := ""
    browser2 := ""
    
    for _, browser := range browsers {
        if strings.Contains(ua1, browser) {
            browser1 = browser
        }
        if strings.Contains(ua2, browser) {
            browser2 = browser
        }
    }
    
    return browser1 != browser2
}

// 위험도에 따른 조치 결정
func (sc *SecurityChecker) determineActions(result *SecurityCheckResult) {
    if result.RiskScore >= 70 {
        result.IsSecure = false
        result.Actions = append(result.Actions, "즉시 세션 종료")
    } else if result.RiskScore >= 50 {
        result.Actions = append(result.Actions, "2단계 인증 요구")
    } else if result.RiskScore >= 30 {
        result.Actions = append(result.Actions, "보안 질문 확인")
    }
}
```

## API 보안

### Rate Limiting

```go
// internal/middleware/ratelimit_advanced.go
package middleware

import (
    "fmt"
    "net/http"
    "strconv"
    "sync"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/go-redis/redis/v8"
)

type AdvancedRateLimiter struct {
    redis          *redis.Client
    globalLimit    *RateLimit
    ipLimits       *RateLimit
    userLimits     *RateLimit
    endpointLimits map[string]*RateLimit
    mu             sync.RWMutex
}

type RateLimit struct {
    Requests int           `yaml:"requests"`
    Window   time.Duration `yaml:"window"`
}

type RateLimitKey struct {
    Type       string // global, ip, user, endpoint
    Identifier string
    Endpoint   string
}

func NewAdvancedRateLimiter(redis *redis.Client, config *RateLimitConfig) *AdvancedRateLimiter {
    return &AdvancedRateLimiter{
        redis:          redis,
        globalLimit:    &config.Global,
        ipLimits:       &config.PerIP,
        userLimits:     &config.PerUser,
        endpointLimits: config.Endpoints,
    }
}

func (rl *AdvancedRateLimiter) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 전역 Rate Limit 검사
        if !rl.checkGlobalLimit(c) {
            return
        }
        
        // IP별 Rate Limit 검사
        if !rl.checkIPLimit(c) {
            return
        }
        
        // 사용자별 Rate Limit 검사 (인증된 사용자)
        if userID := getUserIDFromContext(c); userID != "" {
            if !rl.checkUserLimit(c, userID) {
                return
            }
        }
        
        // 엔드포인트별 Rate Limit 검사
        if !rl.checkEndpointLimit(c) {
            return
        }
        
        c.Next()
    }
}

// 전역 Rate Limit 검사
func (rl *AdvancedRateLimiter) checkGlobalLimit(c *gin.Context) bool {
    key := "global:requests"
    return rl.checkLimit(c, key, rl.globalLimit, "전역")
}

// IP별 Rate Limit 검사
func (rl *AdvancedRateLimiter) checkIPLimit(c *gin.Context) bool {
    clientIP := c.ClientIP()
    key := fmt.Sprintf("ip:%s", clientIP)
    return rl.checkLimit(c, key, rl.ipLimits, "IP")
}

// 사용자별 Rate Limit 검사
func (rl *AdvancedRateLimiter) checkUserLimit(c *gin.Context, userID string) bool {
    key := fmt.Sprintf("user:%s", userID)
    return rl.checkLimit(c, key, rl.userLimits, "사용자")
}

// 엔드포인트별 Rate Limit 검사
func (rl *AdvancedRateLimiter) checkEndpointLimit(c *gin.Context) bool {
    endpoint := c.FullPath()
    
    rl.mu.RLock()
    limit, exists := rl.endpointLimits[endpoint]
    rl.mu.RUnlock()
    
    if !exists {
        return true // 제한이 없으면 통과
    }
    
    clientIP := c.ClientIP()
    userID := getUserIDFromContext(c)
    
    var identifier string
    if userID != "" {
        identifier = userID
    } else {
        identifier = clientIP
    }
    
    key := fmt.Sprintf("endpoint:%s:%s", endpoint, identifier)
    return rl.checkLimit(c, key, limit, "엔드포인트")
}

// Redis를 사용한 Sliding Window Rate Limit
func (rl *AdvancedRateLimiter) checkLimit(c *gin.Context, key string, limit *RateLimit, limitType string) bool {
    ctx := c.Request.Context()
    now := time.Now()
    windowStart := now.Add(-limit.Window)
    
    pipe := rl.redis.Pipeline()
    
    // 윈도우 밖의 오래된 엔트리 제거
    pipe.ZRemRangeByScore(ctx, key, "0", strconv.FormatInt(windowStart.UnixNano(), 10))
    
    // 현재 윈도우의 요청 수 확인
    countCmd := pipe.ZCard(ctx, key)
    
    // 현재 요청을 윈도우에 추가
    pipe.ZAdd(ctx, key, &redis.Z{
        Score:  float64(now.UnixNano()),
        Member: fmt.Sprintf("%d", now.UnixNano()),
    })
    
    // 키의 TTL 설정
    pipe.Expire(ctx, key, limit.Window*2)
    
    _, err := pipe.Exec(ctx)
    if err != nil {
        // Redis 오류 시 제한하지 않음 (서비스 가용성 우선)
        return true
    }
    
    count := countCmd.Val()
    
    // 헤더에 Rate Limit 정보 추가
    c.Header("X-RateLimit-Limit", strconv.Itoa(limit.Requests))
    c.Header("X-RateLimit-Remaining", strconv.Itoa(int(max(0, int64(limit.Requests)-count))))
    c.Header("X-RateLimit-Reset", strconv.FormatInt(now.Add(limit.Window).Unix(), 10))
    
    if count >= int64(limit.Requests) {
        c.JSON(http.StatusTooManyRequests, gin.H{
            "error":   "요청 한도 초과",
            "message": fmt.Sprintf("%s 요청 한도를 초과했습니다", limitType),
            "retry_after": int(limit.Window.Seconds()),
        })
        c.Abort()
        return false
    }
    
    return true
}

func max(a, b int64) int64 {
    if a > b {
        return a
    }
    return b
}
```

### CSRF 보호

```go
// internal/middleware/csrf.go
package middleware

import (
    "crypto/hmac"
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "net/http"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
)

type CSRFProtection struct {
    secretKey      []byte
    tokenLifetime  time.Duration
    secureCookie   bool
    sameSite       http.SameSite
    trustedOrigins []string
    fieldName      string
    headerName     string
    cookieName     string
}

func NewCSRFProtection(config *CSRFConfig) *CSRFProtection {
    return &CSRFProtection{
        secretKey:      []byte(config.SecretKey),
        tokenLifetime:  config.TokenLifetime,
        secureCookie:   config.SecureCookie,
        sameSite:       config.SameSite,
        trustedOrigins: config.TrustedOrigins,
        fieldName:      "_csrf_token",
        headerName:     "X-CSRF-Token",
        cookieName:     "_csrf",
    }
}

func (csrf *CSRFProtection) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // GET, HEAD, OPTIONS 요청은 CSRF 토큰 검증하지 않음
        if c.Request.Method == "GET" || c.Request.Method == "HEAD" || c.Request.Method == "OPTIONS" {
            // 새로운 CSRF 토큰 생성 및 설정
            token := csrf.generateToken()
            csrf.setTokenCookie(c, token)
            c.Header("X-CSRF-Token", token)
            c.Next()
            return
        }
        
        // Origin 검증
        if !csrf.validateOrigin(c) {
            c.JSON(http.StatusForbidden, gin.H{"error": "잘못된 Origin입니다"})
            c.Abort()
            return
        }
        
        // CSRF 토큰 검증
        if !csrf.validateToken(c) {
            c.JSON(http.StatusForbidden, gin.H{"error": "유효하지 않은 CSRF 토큰입니다"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// CSRF 토큰 생성
func (csrf *CSRFProtection) generateToken() string {
    // 랜덤 바이트 생성
    bytes := make([]byte, 32)
    rand.Read(bytes)
    
    // 현재 시간을 포함하여 토큰 생성
    timestamp := time.Now().Unix()
    data := append(bytes, []byte(string(timestamp))...)
    
    // HMAC 서명 생성
    h := hmac.New(sha256.New, csrf.secretKey)
    h.Write(data)
    signature := h.Sum(nil)
    
    // 토큰 = base64(data + signature)
    token := append(data, signature...)
    return base64.URLEncoding.EncodeToString(token)
}

// CSRF 토큰 검증
func (csrf *CSRFProtection) validateToken(c *gin.Context) bool {
    // 토큰 추출
    token := csrf.extractToken(c)
    if token == "" {
        return false
    }
    
    // 토큰 디코딩
    decoded, err := base64.URLEncoding.DecodeString(token)
    if err != nil {
        return false
    }
    
    if len(decoded) < 64 { // 32 bytes data + 32 bytes signature
        return false
    }
    
    // 데이터와 서명 분리
    data := decoded[:len(decoded)-32]
    signature := decoded[len(decoded)-32:]
    
    // HMAC 검증
    h := hmac.New(sha256.New, csrf.secretKey)
    h.Write(data)
    expectedSignature := h.Sum(nil)
    
    if !hmac.Equal(signature, expectedSignature) {
        return false
    }
    
    // 토큰 만료 검증 (선택적)
    if csrf.tokenLifetime > 0 {
        // 실제 구현에서는 타임스탬프 추출 로직 필요
        // 여기서는 간단히 생략
    }
    
    return true
}

// 토큰 추출 (헤더 또는 폼 필드에서)
func (csrf *CSRFProtection) extractToken(c *gin.Context) string {
    // 헤더에서 토큰 확인
    if token := c.GetHeader(csrf.headerName); token != "" {
        return token
    }
    
    // 폼 필드에서 토큰 확인
    if token := c.PostForm(csrf.fieldName); token != "" {
        return token
    }
    
    return ""
}

// Origin 검증
func (csrf *CSRFProtection) validateOrigin(c *gin.Context) bool {
    origin := c.GetHeader("Origin")
    if origin == "" {
        origin = c.GetHeader("Referer")
    }
    
    if origin == "" {
        return false
    }
    
    for _, trustedOrigin := range csrf.trustedOrigins {
        if strings.HasPrefix(origin, trustedOrigin) {
            return true
        }
    }
    
    return false
}

// CSRF 토큰을 쿠키에 설정
func (csrf *CSRFProtection) setTokenCookie(c *gin.Context, token string) {
    c.SetSameSite(csrf.sameSite)
    c.SetCookie(
        csrf.cookieName,
        token,
        int(csrf.tokenLifetime.Seconds()),
        "/",
        "",
        csrf.secureCookie,
        false, // HttpOnly를 false로 설정 (JavaScript에서 접근 가능해야 함)
    )
}
```

## Docker 컨테이너 보안

### 보안 강화된 Dockerfile

```dockerfile
# 다단계 빌드를 사용한 보안 강화
FROM golang:1.21-alpine AS builder

# 보안 업데이트 및 필요한 도구 설치
RUN apk update && apk upgrade && apk add --no-cache \
    ca-certificates \
    git \
    && update-ca-certificates

# 비특권 사용자 생성
RUN adduser -D -s /bin/sh appuser

# 작업 디렉토리 설정
WORKDIR /app

# Go 모듈 파일 복사 및 의존성 다운로드
COPY go.mod go.sum ./
RUN go mod download && go mod verify

# 소스 코드 복사
COPY . .

# CGO 비활성화 및 정적 바이너리 빌드
ENV CGO_ENABLED=0 GOOS=linux GOARCH=amd64
RUN go build \
    -ldflags='-w -s -extldflags "-static"' \
    -a -installsuffix cgo \
    -o aicli-web ./cmd/api/main.go

# 최종 이미지
FROM scratch

# CA 인증서 복사 (HTTPS 통신용)
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# passwd 파일 복사 (사용자 정보)
COPY --from=builder /etc/passwd /etc/passwd

# 애플리케이션 바이너리 복사
COPY --from=builder /app/aicli-web /aicli-web

# 비특권 사용자로 실행
USER appuser

# 포트 노출
EXPOSE 8080

# 헬스체크 (scratch 이미지에서는 제한적)
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
    CMD ["/aicli-web", "healthcheck"]

# 실행
ENTRYPOINT ["/aicli-web"]
```

### Docker Compose 보안 설정

```yaml
version: '3.8'

services:
  # API 서버
  api:
    build:
      context: .
      dockerfile: Dockerfile
    
    # 보안 설정
    security_opt:
      - no-new-privileges:true
      - apparmor:docker-default
      - seccomp:/path/to/seccomp-profile.json
    
    # Capabilities 제한
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETUID
      - SETGID
      - NET_BIND_SERVICE
    
    # 읽기 전용 루트 파일시스템
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid,nodev
      - /run:noexec,nosuid,nodev
    
    # 리소스 제한
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
    
    ulimits:
      nproc: 65535
      nofile:
        soft: 20000
        hard: 40000
    
    # 환경 변수 (secrets 사용 권장)
    environment:
      - LOG_LEVEL=info
      - GIN_MODE=release
    
    # Secrets 마운트
    secrets:
      - jwt_secret
      - db_password
    
    networks:
      - frontend
      - backend
    
    depends_on:
      - redis
      - postgres
    
    restart: unless-stopped

  # Redis (세션 저장소)
  redis:
    image: redis:7-alpine
    
    security_opt:
      - no-new-privileges:true
    
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETUID
      - SETGID
    
    read_only: true
    tmpfs:
      - /tmp
    
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --appendonly yes
      --appendfsync everysec
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
    
    volumes:
      - redis_data:/data
    
    networks:
      - backend
    
    restart: unless-stopped

  # PostgreSQL (메인 데이터베이스)
  postgres:
    image: postgres:15-alpine
    
    security_opt:
      - no-new-privileges:true
    
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETUID
      - SETGID
      - FOWNER
      - DAC_OVERRIDE
    
    environment:
      - POSTGRES_DB=aicli
      - POSTGRES_USER=aicli_user
      - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
      - PGDATA=/var/lib/postgresql/data/pgdata
    
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql:ro
    
    secrets:
      - db_password
    
    networks:
      - backend
    
    restart: unless-stopped

  # 워크스페이스 컨테이너 (격리된 실행 환경)
  workspace:
    build:
      context: .
      dockerfile: Dockerfile.workspace
    
    security_opt:
      - no-new-privileges:true
      - apparmor:workspace-profile
      - seccomp:/path/to/workspace-seccomp.json
    
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETUID
      - SETGID
    
    # 엄격한 격리
    privileged: false
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid,nodev,size=100m
      - /var/tmp:noexec,nosuid,nodev,size=100m
    
    # 리소스 제한 (워크스페이스별)
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M
    
    ulimits:
      nproc: 1024
      nofile:
        soft: 1024
        hard: 2048
      fsize: 104857600  # 100MB
    
    # 격리된 네트워크
    networks:
      - workspace
    
    # 워크스페이스 데이터 볼륨 (프로젝트별)
    volumes:
      - type: bind
        source: ./workspaces/${WORKSPACE_ID}
        target: /workspace
        read_only: false
        bind:
          propagation: private

# 네트워크 분리
networks:
  frontend:
    driver: bridge
    internal: false
    ipam:
      driver: default
      config:
        - subnet: 172.20.0.0/24
  
  backend:
    driver: bridge
    internal: true
    ipam:
      driver: default
      config:
        - subnet: 172.21.0.0/24
  
  workspace:
    driver: bridge
    internal: true
    ipam:
      driver: default
      config:
        - subnet: 172.22.0.0/24

# 볼륨
volumes:
  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /var/lib/aicli/redis
  
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /var/lib/aicli/postgres

# Secrets
secrets:
  jwt_secret:
    file: ./secrets/jwt_secret.txt
  db_password:
    file: ./secrets/db_password.txt
```

### AppArmor 프로필

```bash
# /etc/apparmor.d/docker-aicli-workspace
#include <tunables/global>

profile docker-aicli-workspace flags=(attach_disconnected,mediate_deleted) {
  #include <abstractions/base>
  
  # 네트워크 제한
  network inet stream,
  network inet6 stream,
  deny network raw,
  
  # 파일 시스템 접근 제한
  / r,
  /workspace/** rw,
  /tmp/** rw,
  /var/tmp/** rw,
  
  # 실행 가능한 바이너리 제한
  /usr/bin/* ix,
  /bin/* ix,
  deny /usr/bin/sudo x,
  deny /bin/su x,
  
  # 시스템 호출 제한
  deny @{PROC}/sys/** w,
  deny /sys/** w,
  
  # 장치 접근 금지
  deny /dev/** rw,
  /dev/null rw,
  /dev/zero r,
  /dev/urandom r,
  
  # 마운트 금지
  deny mount,
  deny umount,
}
```

### Seccomp 프로필

```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "architectures": [
    "SCMP_ARCH_X86_64",
    "SCMP_ARCH_X86",
    "SCMP_ARCH_X32"
  ],
  "syscalls": [
    {
      "names": [
        "read",
        "write",
        "open",
        "close",
        "stat",
        "fstat",
        "lstat",
        "poll",
        "lseek",
        "mmap",
        "mprotect",
        "munmap",
        "brk",
        "rt_sigaction",
        "rt_sigprocmask",
        "rt_sigreturn",
        "ioctl",
        "access",
        "pipe",
        "select",
        "sched_yield",
        "mremap",
        "msync",
        "mincore",
        "madvise",
        "shmget",
        "shmat",
        "shmctl",
        "dup",
        "dup2",
        "getpid",
        "sendfile",
        "socket",
        "connect",
        "accept",
        "sendto",
        "recvfrom",
        "sendmsg",
        "recvmsg",
        "shutdown",
        "bind",
        "listen",
        "getsockname",
        "getpeername",
        "socketpair",
        "setsockopt",
        "getsockopt",
        "clone",
        "fork",
        "vfork",
        "execve",
        "exit",
        "wait4",
        "kill",
        "uname",
        "semget",
        "semop",
        "semctl",
        "shmdt",
        "msgget",
        "msgsnd",
        "msgrcv",
        "msgctl",
        "fcntl",
        "flock",
        "fsync",
        "fdatasync",
        "truncate",
        "ftruncate",
        "getdents",
        "getcwd",
        "chdir",
        "fchdir",
        "rename",
        "mkdir",
        "rmdir",
        "creat",
        "link",
        "unlink",
        "symlink",
        "readlink",
        "chmod",
        "fchmod",
        "chown",
        "fchown",
        "lchown",
        "umask",
        "gettimeofday",
        "getrlimit",
        "getrusage",
        "sysinfo",
        "times",
        "ptrace",
        "getuid",
        "syslog",
        "getgid",
        "setuid",
        "setgid",
        "geteuid",
        "getegid",
        "setpgid",
        "getppid",
        "getpgrp",
        "setsid",
        "setreuid",
        "setregid",
        "getgroups",
        "setgroups",
        "setresuid",
        "getresuid",
        "setresgid",
        "getresgid",
        "getpgid",
        "setfsuid",
        "setfsgid",
        "getsid",
        "capget",
        "capset",
        "rt_sigpending",
        "rt_sigtimedwait",
        "rt_sigqueueinfo",
        "rt_sigsuspend",
        "sigaltstack",
        "utime",
        "mknod",
        "uselib",
        "personality",
        "ustat",
        "statfs",
        "fstatfs",
        "sysfs",
        "getpriority",
        "setpriority",
        "sched_setparam",
        "sched_getparam",
        "sched_setscheduler",
        "sched_getscheduler",
        "sched_get_priority_max",
        "sched_get_priority_min",
        "sched_rr_get_interval",
        "mlock",
        "munlock",
        "mlockall",
        "munlockall",
        "vhangup",
        "modify_ldt",
        "pivot_root",
        "_sysctl",
        "prctl",
        "arch_prctl",
        "adjtimex",
        "setrlimit",
        "chroot",
        "sync",
        "acct",
        "settimeofday",
        "mount",
        "umount2",
        "swapon",
        "swapoff",
        "reboot",
        "sethostname",
        "setdomainname",
        "iopl",
        "ioperm",
        "create_module",
        "init_module",
        "delete_module",
        "get_kernel_syms",
        "query_module",
        "quotactl",
        "nfsservctl",
        "getpmsg",
        "putpmsg",
        "afs_syscall",
        "tuxcall",
        "security",
        "gettid",
        "readahead",
        "setxattr",
        "lsetxattr",
        "fsetxattr",
        "getxattr",
        "lgetxattr",
        "fgetxattr",
        "listxattr",
        "llistxattr",
        "flistxattr",
        "removexattr",
        "lremovexattr",
        "fremovexattr",
        "tkill",
        "time",
        "futex",
        "sched_setaffinity",
        "sched_getaffinity",
        "set_thread_area",
        "io_setup",
        "io_destroy",
        "io_getevents",
        "io_submit",
        "io_cancel",
        "get_thread_area",
        "lookup_dcookie",
        "epoll_create",
        "epoll_ctl_old",
        "epoll_wait_old",
        "remap_file_pages",
        "getdents64",
        "set_tid_address",
        "restart_syscall",
        "semtimedop",
        "fadvise64",
        "timer_create",
        "timer_settime",
        "timer_gettime",
        "timer_getoverrun",
        "timer_delete",
        "clock_settime",
        "clock_gettime",
        "clock_getres",
        "clock_nanosleep",
        "exit_group",
        "epoll_wait",
        "epoll_ctl",
        "tgkill",
        "utimes",
        "vserver",
        "mbind",
        "set_mempolicy",
        "get_mempolicy",
        "mq_open",
        "mq_unlink",
        "mq_timedsend",
        "mq_timedreceive",
        "mq_notify",
        "mq_getsetattr",
        "kexec_load",
        "waitid",
        "add_key",
        "request_key",
        "keyctl",
        "ioprio_set",
        "ioprio_get",
        "inotify_init",
        "inotify_add_watch",
        "inotify_rm_watch",
        "migrate_pages",
        "openat",
        "mkdirat",
        "mknodat",
        "fchownat",
        "futimesat",
        "newfstatat",
        "unlinkat",
        "renameat",
        "linkat",
        "symlinkat",
        "readlinkat",
        "fchmodat",
        "faccessat",
        "pselect6",
        "ppoll",
        "unshare",
        "set_robust_list",
        "get_robust_list",
        "splice",
        "tee",
        "sync_file_range",
        "vmsplice",
        "move_pages",
        "utimensat",
        "epoll_pwait",
        "signalfd",
        "timerfd_create",
        "eventfd",
        "fallocate",
        "timerfd_settime",
        "timerfd_gettime",
        "accept4",
        "signalfd4",
        "eventfd2",
        "epoll_create1",
        "dup3",
        "pipe2",
        "inotify_init1",
        "preadv",
        "pwritev",
        "rt_tgsigqueueinfo",
        "perf_event_open",
        "recvmmsg",
        "fanotify_init",
        "fanotify_mark",
        "prlimit64",
        "name_to_handle_at",
        "open_by_handle_at",
        "clock_adjtime",
        "syncfs",
        "sendmmsg",
        "setns",
        "getcpu",
        "process_vm_readv",
        "process_vm_writev",
        "kcmp",
        "finit_module"
      ],
      "action": "SCMP_ACT_ALLOW"
    },
    {
      "names": [
        "personality"
      ],
      "action": "SCMP_ACT_ALLOW",
      "args": [
        {
          "index": 0,
          "value": 0,
          "op": "SCMP_CMP_EQ"
        }
      ]
    },
    {
      "names": [
        "personality"
      ],
      "action": "SCMP_ACT_ALLOW",
      "args": [
        {
          "index": 0,
          "value": 8,
          "op": "SCMP_CMP_EQ"
        }
      ]
    },
    {
      "names": [
        "personality"
      ],
      "action": "SCMP_ACT_ALLOW",
      "args": [
        {
          "index": 0,
          "value": 4294967295,
          "op": "SCMP_CMP_EQ"
        }
      ]
    },
    {
      "names": [
        "chroot"
      ],
      "action": "SCMP_ACT_ALLOW"
    },
    {
      "names": [
        "clone"
      ],
      "action": "SCMP_ACT_ALLOW",
      "args": [
        {
          "index": 0,
          "value": 2114060288,
          "op": "SCMP_CMP_MASKED_EQ"
        }
      ]
    }
  ]
}
```

이상으로 보안 설정 가이드의 첫 번째 부분을 작성했습니다. 이어서 남은 섹션들을 계속 작성하겠습니다.

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"id": "T08_S01_security", "content": "\ubcf4\uc548 \uc124\uc815 \uac00\uc774\ub4dc \uc791\uc131 - JWT, \uc778\uc99d, \uad8c\ud55c \uad00\ub9ac, \ubcf4\uc548 \uccb4\ud06c\ub9ac\uc2a4\ud2b8 \ud3ec\ud568 (\ud30c\ud2b8 1 \uc644\ub8cc)", "status": "completed", "priority": "high"}, {"id": "T08_S01_troubleshooting", "content": "\ubb38\uc81c \ud574\uacb0 \uac00\uc774\ub4dc \uc791\uc131 - \uc77c\ubc18\uc801\uc778 \uc624\ub958, \ub514\ubc84\uae45 \ubc29\ubc95, FAQ \ud3ec\ud568", "status": "in_progress", "priority": "medium"}, {"id": "T08_S01_migration", "content": "\ub9c8\uc774\uadf8\ub808\uc774\uc158 \uac00\uc774\ub4dc \uc791\uc131 - \ubc84\uc804 \uc5c5\ub370\uc774\ud2b8, \ub370\uc774\ud130 \ub9c8\uc774\uadf8\ub808\uc774\uc158, \ud638\ud658\uc131", "status": "pending", "priority": "medium"}, {"id": "T08_S01_docs_site", "content": "\ubb38\uc11c \uc0ac\uc774\ud2b8 \uad6c\ucd95 (\uc120\ud0dd\uc801) - MkDocs \ub610\ub294 GitBook \uae30\ubc18 \ubb38\uc11c \uc0ac\uc774\ud2b8", "status": "pending", "priority": "low"}]