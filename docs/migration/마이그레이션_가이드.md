# 마이그레이션 가이드

## 개요

AICode Manager의 버전 업데이트, 데이터 마이그레이션, 시스템 이전에 관한 가이드입니다. 이 문서는 안전하고 효율적인 마이그레이션을 위한 단계별 절차와 모범 사례를 제공합니다.

## 목차

1. [마이그레이션 유형](#마이그레이션-유형)
2. [사전 준비](#사전-준비)
3. [데이터베이스 마이그레이션](#데이터베이스-마이그레이션)
4. [버전 업그레이드](#버전-업그레이드)
5. [환경 이전](#환경-이전)
6. [설정 마이그레이션](#설정-마이그레이션)
7. [롤백 절차](#롤백-절차)
8. [자동화 도구](#자동화-도구)
9. [모니터링 및 검증](#모니터링-및-검증)
10. [문제 해결](#문제-해결)

## 마이그레이션 유형

### 1. 데이터베이스 스키마 마이그레이션
- 테이블 구조 변경
- 인덱스 추가/삭제
- 제약 조건 수정
- 데이터 타입 변경

### 2. 애플리케이션 버전 업그레이드
- 마이너 버전 업데이트 (1.0.x → 1.1.x)
- 메이저 버전 업데이트 (1.x → 2.x)
- 패치 버전 업데이트 (1.0.1 → 1.0.2)

### 3. 환경 간 이전
- 개발 → 스테이징
- 스테이징 → 프로덕션
- 온프레미스 → 클라우드

### 4. 인프라 마이그레이션
- 데이터베이스 엔진 변경
- 캐시 시스템 변경
- 메시지 큐 변경

## 사전 준비

### 1. 현재 상태 점검

#### 시스템 상태 확인
```bash
# 애플리케이션 버전 확인
./aicli-web version

# 데이터베이스 스키마 버전 확인
./aicli-web db version

# 시스템 리소스 확인
df -h          # 디스크 공간
free -h        # 메모리 사용량
ps aux         # 실행 중인 프로세스
```

#### 데이터베이스 상태 확인
```sql
-- PostgreSQL 데이터베이스 크기 확인
SELECT 
    pg_size_pretty(pg_database_size('aicli')) as database_size;

-- 테이블별 크기 확인
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables 
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- 연결 상태 확인
SELECT state, count(*) 
FROM pg_stat_activity 
GROUP BY state;
```

### 2. 백업 생성

#### 데이터베이스 전체 백업
```bash
#!/bin/bash
# backup.sh

BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/aicli"
DB_NAME="aicli"
DB_USER="aicli_user"
DB_HOST="localhost"

# 백업 디렉토리 생성
mkdir -p ${BACKUP_DIR}

# 데이터베이스 백업
echo "Creating database backup..."
pg_dump -h ${DB_HOST} -U ${DB_USER} -d ${DB_NAME} \
    --format=custom \
    --compress=9 \
    --verbose \
    --file="${BACKUP_DIR}/db_backup_${BACKUP_DATE}.sql"

# 스키마만 백업 (복원 시 구조 확인용)
pg_dump -h ${DB_HOST} -U ${DB_USER} -d ${DB_NAME} \
    --schema-only \
    --file="${BACKUP_DIR}/schema_backup_${BACKUP_DATE}.sql"

# 데이터만 백업
pg_dump -h ${DB_HOST} -U ${DB_USER} -d ${DB_NAME} \
    --data-only \
    --format=custom \
    --file="${BACKUP_DIR}/data_backup_${BACKUP_DATE}.sql"

echo "Database backup completed: ${BACKUP_DIR}/db_backup_${BACKUP_DATE}.sql"
```

#### 설정 파일 백업
```bash
#!/bin/bash
# config_backup.sh

BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/aicli/config"

mkdir -p ${BACKUP_DIR}

# 설정 파일들 백업
tar -czf "${BACKUP_DIR}/config_backup_${BACKUP_DATE}.tar.gz" \
    ./config.yml \
    ./configs/ \
    ./docker-compose.yml \
    ./Dockerfile \
    .env 2>/dev/null || true

echo "Configuration backup completed: ${BACKUP_DIR}/config_backup_${BACKUP_DATE}.tar.gz"
```

#### Redis 데이터 백업 (세션 데이터)
```bash
#!/bin/bash
# redis_backup.sh

BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/aicli/redis"

mkdir -p ${BACKUP_DIR}

# Redis 데이터 백업 (BGSAVE 사용)
redis-cli BGSAVE
sleep 5  # 백그라운드 저장 대기

# RDB 파일 복사
cp /var/lib/redis/dump.rdb "${BACKUP_DIR}/redis_backup_${BACKUP_DATE}.rdb"

echo "Redis backup completed: ${BACKUP_DIR}/redis_backup_${BACKUP_DATE}.rdb"
```

### 3. 다운타임 계획

#### 점검 시간 계획서
```yaml
migration_plan:
  estimated_duration: "2-4 hours"
  maintenance_window: "02:00-06:00 KST"
  
  phases:
    - phase: "준비"
      duration: "30분"
      tasks:
        - "백업 생성"
        - "시스템 상태 확인"
        - "알림 발송"
    
    - phase: "마이그레이션"
      duration: "60-120분"
      tasks:
        - "서비스 중지"
        - "데이터베이스 마이그레이션"
        - "애플리케이션 업데이트"
        - "설정 변경"
    
    - phase: "검증"
      duration: "30-60분"
      tasks:
        - "기능 테스트"
        - "성능 테스트"
        - "데이터 무결성 확인"
    
    - phase: "서비스 재개"
      duration: "30분"
      tasks:
        - "서비스 시작"
        - "모니터링 확인"
        - "완료 알림"

  rollback_criteria:
    - "마이그레이션 실패"
    - "중요 기능 동작 안함"
    - "성능 심각한 저하"
    - "데이터 손실 발견"
```

## 데이터베이스 마이그레이션

### 1. 마이그레이션 파일 구조

```
migrations/
├── 001_initial_schema.up.sql
├── 001_initial_schema.down.sql
├── 002_add_user_table.up.sql
├── 002_add_user_table.down.sql
├── 003_add_workspace_indexes.up.sql
├── 003_add_workspace_indexes.down.sql
└── ...
```

### 2. 마이그레이션 파일 작성

#### 예시: 새 테이블 추가
```sql
-- 003_add_audit_log.up.sql
BEGIN;

CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    resource_type VARCHAR(50) NOT NULL,
    resource_id UUID,
    action VARCHAR(50) NOT NULL,
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB
);

-- 인덱스 생성
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);

-- 파티셔닝 설정 (선택사항)
-- CREATE TABLE audit_logs_y2024m01 PARTITION OF audit_logs
-- FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

COMMIT;
```

```sql
-- 003_add_audit_log.down.sql
BEGIN;

-- 파티션 테이블 삭제 (있는 경우)
-- DROP TABLE IF EXISTS audit_logs_y2024m01;

-- 인덱스는 테이블과 함께 자동 삭제됨
DROP TABLE IF EXISTS audit_logs;

COMMIT;
```

#### 예시: 컬럼 추가 (무중단)
```sql
-- 004_add_user_preferences.up.sql
BEGIN;

-- 1단계: 컬럼 추가 (NULL 허용)
ALTER TABLE users 
ADD COLUMN preferences JSONB;

-- 2단계: 기본값 설정
UPDATE users 
SET preferences = '{}' 
WHERE preferences IS NULL;

-- 3단계: NOT NULL 제약 추가 (선택사항)
-- ALTER TABLE users 
-- ALTER COLUMN preferences SET NOT NULL;

-- 인덱스 추가
CREATE INDEX CONCURRENTLY idx_users_preferences 
ON users USING GIN (preferences);

COMMIT;
```

### 3. 마이그레이션 실행

#### CLI를 통한 마이그레이션
```bash
# 현재 마이그레이션 상태 확인
./aicli-web migrate status

# 마이그레이션 실행
./aicli-web migrate up

# 특정 버전까지 마이그레이션
./aicli-web migrate up --target-version 5

# 마이그레이션 롤백
./aicli-web migrate down --steps 1

# 특정 버전으로 롤백
./aicli-web migrate down --target-version 3

# 마이그레이션 강제 실행 (dirty 상태 해제)
./aicli-web migrate force --version 4
```

#### Go 코드를 통한 마이그레이션 관리
```go
// internal/storage/migration/manager.go
package migration

import (
    "database/sql"
    "fmt"
    "time"
    
    "github.com/golang-migrate/migrate/v4"
    "github.com/golang-migrate/migrate/v4/database/postgres"
    _ "github.com/golang-migrate/migrate/v4/source/file"
)

type Manager struct {
    db       *sql.DB
    migrate  *migrate.Migrate
    migratePath string
}

func NewManager(db *sql.DB, migratePath string) (*Manager, error) {
    driver, err := postgres.WithInstance(db, &postgres.Config{})
    if err != nil {
        return nil, err
    }
    
    m, err := migrate.NewWithDatabaseInstance(
        fmt.Sprintf("file://%s", migratePath),
        "postgres",
        driver,
    )
    if err != nil {
        return nil, err
    }
    
    return &Manager{
        db:       db,
        migrate:  m,
        migratePath: migratePath,
    }, nil
}

func (m *Manager) Up() error {
    return m.migrate.Up()
}

func (m *Manager) Down() error {
    return m.migrate.Down()
}

func (m *Manager) Steps(n int) error {
    return m.migrate.Steps(n)
}

func (m *Manager) Goto(version uint) error {
    return m.migrate.Migrate(version)
}

func (m *Manager) Version() (uint, bool, error) {
    return m.migrate.Version()
}

func (m *Manager) Force(version int) error {
    return m.migrate.Force(version)
}

// 안전한 마이그레이션 실행
func (m *Manager) SafeMigrate() error {
    // 1. 현재 버전 확인
    currentVersion, dirty, err := m.Version()
    if err != nil && err != migrate.ErrNilVersion {
        return fmt.Errorf("버전 확인 실패: %v", err)
    }
    
    if dirty {
        return fmt.Errorf("데이터베이스가 dirty 상태입니다. 수동으로 정리하세요")
    }
    
    // 2. 백업 생성
    backupPath := fmt.Sprintf("/backup/pre_migration_%d_%s.sql", 
        currentVersion, time.Now().Format("20060102_150405"))
    
    if err := m.createBackup(backupPath); err != nil {
        return fmt.Errorf("백업 생성 실패: %v", err)
    }
    
    // 3. 마이그레이션 실행
    if err := m.Up(); err != nil {
        if err != migrate.ErrNoChange {
            return fmt.Errorf("마이그레이션 실패: %v", err)
        }
    }
    
    // 4. 마이그레이션 결과 확인
    newVersion, dirty, err := m.Version()
    if err != nil {
        return fmt.Errorf("마이그레이션 후 버전 확인 실패: %v", err)
    }
    
    if dirty {
        return fmt.Errorf("마이그레이션 후 데이터베이스가 dirty 상태입니다")
    }
    
    fmt.Printf("마이그레이션 완료: %d → %d\n", currentVersion, newVersion)
    return nil
}

func (m *Manager) createBackup(path string) error {
    // pg_dump를 사용한 백업 생성 로직
    // 실제 구현에서는 os/exec를 사용하여 pg_dump 실행
    return nil
}
```

### 4. 무중단 마이그레이션 전략

#### Blue-Green 배포를 활용한 마이그레이션
```bash
#!/bin/bash
# blue_green_migration.sh

BLUE_DB="aicli_blue"
GREEN_DB="aicli_green"
CURRENT_DB="aicli"

echo "Blue-Green 마이그레이션 시작..."

# 1. 현재 활성 DB 확인
ACTIVE_DB=$(psql -t -c "SELECT current_database();" -d ${CURRENT_DB} | xargs)

if [ "$ACTIVE_DB" = "$BLUE_DB" ]; then
    TARGET_DB=$GREEN_DB
    OLD_DB=$BLUE_DB
else
    TARGET_DB=$BLUE_DB
    OLD_DB=$GREEN_DB
fi

echo "활성 DB: $OLD_DB, 타겟 DB: $TARGET_DB"

# 2. 타겟 DB에 현재 데이터 복제
echo "데이터 복제 중..."
pg_dump -d $OLD_DB | psql -d $TARGET_DB

# 3. 타겟 DB에 마이그레이션 적용
echo "마이그레이션 적용 중..."
./aicli-web migrate up --database-url="postgres://user:pass@localhost/$TARGET_DB"

# 4. 데이터 무결성 검증
echo "데이터 무결성 검증 중..."
if ! ./scripts/verify_migration.sh $TARGET_DB; then
    echo "검증 실패 - 마이그레이션 중단"
    exit 1
fi

# 5. 트래픽 전환
echo "트래픽 전환 중..."
# 애플리케이션 설정에서 DB 연결을 타겟 DB로 변경
# 또는 프록시 설정 변경

echo "Blue-Green 마이그레이션 완료"
```

#### 온라인 스키마 변경 (pt-online-schema-change 스타일)
```sql
-- 대용량 테이블의 컬럼 추가 (무중단)
-- 1. 새 테이블 생성 (기존 스키마 + 새 컬럼)
CREATE TABLE users_new (LIKE users INCLUDING ALL);
ALTER TABLE users_new ADD COLUMN new_column TEXT;

-- 2. 트리거로 실시간 동기화
CREATE OR REPLACE FUNCTION sync_users_to_new()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO users_new SELECT NEW.*, NULL;
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        UPDATE users_new 
        SET (id, email, name, created_at, updated_at) = 
            (NEW.id, NEW.email, NEW.name, NEW.created_at, NEW.updated_at)
        WHERE id = NEW.id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM users_new WHERE id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sync_users
    AFTER INSERT OR UPDATE OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION sync_users_to_new();

-- 3. 기존 데이터 배치 복사
DO $$
DECLARE
    batch_size INTEGER := 1000;
    min_id INTEGER := 0;
    max_id INTEGER;
BEGIN
    SELECT COALESCE(MAX(id), 0) INTO max_id FROM users;
    
    WHILE min_id < max_id LOOP
        INSERT INTO users_new 
        SELECT *, NULL as new_column
        FROM users 
        WHERE id > min_id AND id <= min_id + batch_size
        ON CONFLICT (id) DO NOTHING;
        
        min_id := min_id + batch_size;
        PERFORM pg_sleep(0.1); -- 부하 분산
    END LOOP;
END $$;

-- 4. 검증 후 테이블 교체
-- 검증: SELECT count(*) FROM users; SELECT count(*) FROM users_new;
-- 교체: 
-- BEGIN;
-- DROP TRIGGER trigger_sync_users ON users;
-- DROP FUNCTION sync_users_to_new();
-- ALTER TABLE users RENAME TO users_old;
-- ALTER TABLE users_new RENAME TO users;
-- COMMIT;
```

## 버전 업그레이드

### 1. 패치 버전 업데이트 (1.0.1 → 1.0.2)

#### 간단한 롤링 업데이트
```bash
#!/bin/bash
# patch_update.sh

NEW_VERSION="1.0.2"
IMAGE_NAME="aicli-web"

echo "패치 버전 업데이트 시작: ${NEW_VERSION}"

# 1. 새 이미지 빌드
docker build -t ${IMAGE_NAME}:${NEW_VERSION} .
docker tag ${IMAGE_NAME}:${NEW_VERSION} ${IMAGE_NAME}:latest

# 2. 헬스체크 함수
wait_for_healthy() {
    local container_name=$1
    local max_attempts=30
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        if curl -f http://localhost:8080/health >/dev/null 2>&1; then
            echo "컨테이너 $container_name 가 정상적으로 시작됨"
            return 0
        fi
        echo "헬스체크 대기 중... ($((attempt+1))/$max_attempts)"
        sleep 10
        attempt=$((attempt+1))
    done
    
    echo "컨테이너 $container_name 헬스체크 실패"
    return 1
}

# 3. 롤링 업데이트 (다중 인스턴스인 경우)
for instance in api-1 api-2; do
    echo "인스턴스 $instance 업데이트 중..."
    
    # 새 컨테이너 시작
    docker run -d --name ${instance}_new \
        --env-file .env \
        -p 8081:8080 \
        ${IMAGE_NAME}:${NEW_VERSION}
    
    # 헬스체크 대기
    if wait_for_healthy ${instance}_new; then
        # 기존 컨테이너 중지
        docker stop $instance
        docker rm $instance
        
        # 새 컨테이너 이름 변경
        docker rename ${instance}_new $instance
        
        echo "인스턴스 $instance 업데이트 완료"
    else
        echo "인스턴스 $instance 업데이트 실패"
        docker stop ${instance}_new
        docker rm ${instance}_new
        exit 1
    fi
    
    sleep 30  # 안정화 대기
done

echo "패치 업데이트 완료"
```

### 2. 마이너 버전 업데이트 (1.0.x → 1.1.x)

#### 호환성 확인 및 단계적 업데이트
```yaml
# migration_plan_1_1.yml
version_upgrade:
  from: "1.0.x"
  to: "1.1.x"
  
  breaking_changes:
    - config_format: "YAML 설정 형식 일부 변경"
    - api_deprecation: "일부 API 엔드포인트 deprecated"
    - database_schema: "새로운 테이블 추가"
  
  compatibility_check:
    - config_validation: true
    - api_compatibility: true
    - database_migration: required
  
  steps:
    1: "기존 시스템 백업"
    2: "설정 파일 마이그레이션"
    3: "데이터베이스 스키마 업데이트"
    4: "애플리케이션 바이너리 교체"
    5: "호환성 검증"
    6: "서비스 재시작"
    7: "기능 테스트"
```

```bash
#!/bin/bash
# minor_update.sh

OLD_VERSION="1.0.5"
NEW_VERSION="1.1.0"

echo "마이너 버전 업데이트: $OLD_VERSION → $NEW_VERSION"

# 1. 호환성 사전 점검
echo "호환성 점검 중..."
./aicli-web check-compatibility --target-version $NEW_VERSION
if [ $? -ne 0 ]; then
    echo "호환성 점검 실패"
    exit 1
fi

# 2. 설정 파일 마이그레이션
echo "설정 파일 마이그레이션 중..."
./scripts/migrate_config.sh $OLD_VERSION $NEW_VERSION

# 3. 데이터베이스 스키마 업데이트 (드라이런)
echo "데이터베이스 마이그레이션 시뮬레이션 중..."
./aicli-web migrate dry-run --target-version $NEW_VERSION
if [ $? -ne 0 ]; then
    echo "마이그레이션 시뮬레이션 실패"
    exit 1
fi

# 4. 실제 업데이트 시작
read -p "계속 진행하시겠습니까? (y/N): " confirm
if [[ $confirm != [yY] ]]; then
    echo "업데이트 취소됨"
    exit 0
fi

# 5. 유지보수 모드 활성화
echo "유지보수 모드 활성화..."
./scripts/enable_maintenance_mode.sh

# 6. 서비스 중지
echo "서비스 중지 중..."
docker-compose stop

# 7. 백업 생성
echo "백업 생성 중..."
./scripts/backup.sh

# 8. 데이터베이스 마이그레이션 실행
echo "데이터베이스 마이그레이션 실행 중..."
./aicli-web migrate up
if [ $? -ne 0 ]; then
    echo "마이그레이션 실패 - 롤백 시작"
    ./scripts/rollback.sh $OLD_VERSION
    exit 1
fi

# 9. 애플리케이션 업데이트
echo "애플리케이션 업데이트 중..."
docker-compose up -d --build

# 10. 헬스체크
echo "헬스체크 중..."
./scripts/health_check.sh
if [ $? -ne 0 ]; then
    echo "헬스체크 실패 - 롤백 시작"
    ./scripts/rollback.sh $OLD_VERSION
    exit 1
fi

# 11. 기능 테스트
echo "기능 테스트 중..."
./scripts/integration_test.sh
if [ $? -ne 0 ]; then
    echo "기능 테스트 실패"
    read -p "계속 진행하시겠습니까? (y/N): " confirm
    if [[ $confirm != [yY] ]]; then
        ./scripts/rollback.sh $OLD_VERSION
        exit 1
    fi
fi

# 12. 유지보수 모드 비활성화
echo "유지보수 모드 비활성화..."
./scripts/disable_maintenance_mode.sh

echo "마이너 버전 업데이트 완료: $OLD_VERSION → $NEW_VERSION"
```

### 3. 메이저 버전 업데이트 (1.x → 2.x)

#### 복합적 마이그레이션 전략
```yaml
# major_migration_2_0.yml
major_upgrade:
  from: "1.x"
  to: "2.0"
  
  breaking_changes:
    - api_v1_removal: "API v1 완전 제거"
    - config_restructure: "설정 파일 구조 대폭 변경"
    - database_restructure: "데이터베이스 스키마 재설계"
    - authentication_change: "인증 시스템 변경"
    - docker_compose_v2: "Docker Compose v2 필수"
  
  migration_strategy:
    approach: "parallel_deployment"  # blue_green 또는 parallel_deployment
    rollback_time_limit: "4_hours"
    data_migration_time: "2_hours"
    
  prerequisites:
    - docker_compose_version: ">= 2.0"
    - postgresql_version: ">= 13"
    - redis_version: ">= 6.0"
    - disk_space: "10GB"  # 임시 데이터 저장용
    
  phases:
    preparation:
      - audit_current_system
      - export_user_data
      - backup_everything
      - prepare_new_environment
      
    migration:
      - deploy_v2_parallel
      - migrate_user_accounts
      - migrate_workspaces
      - migrate_projects_and_tasks
      - test_critical_paths
      
    cutover:
      - stop_v1_system
      - final_data_sync
      - switch_dns_traffic
      - monitor_systems
      
    cleanup:
      - remove_v1_components
      - cleanup_old_data
      - update_documentation
```

```bash
#!/bin/bash
# major_update_2_0.sh

set -euo pipefail

OLD_VERSION="1.8.3"
NEW_VERSION="2.0.0"

# 로깅 설정
LOG_FILE="/var/log/aicli/major_migration_$(date +%Y%m%d_%H%M%S).log"
mkdir -p $(dirname $LOG_FILE)

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

# 전제 조건 확인
check_prerequisites() {
    log "전제 조건 확인 중..."
    
    # Docker Compose 버전 확인
    compose_version=$(docker-compose --version | grep -oP '\d+\.\d+\.\d+')
    if ! version_ge $compose_version "2.0.0"; then
        log "ERROR: Docker Compose 2.0+ 필요 (현재: $compose_version)"
        exit 1
    fi
    
    # 디스크 공간 확인
    available_space=$(df /var/lib/docker --output=avail | tail -n1)
    required_space=$((10 * 1024 * 1024))  # 10GB in KB
    if [ $available_space -lt $required_space ]; then
        log "ERROR: 디스크 공간 부족 (필요: 10GB, 사용가능: $(($available_space / 1024 / 1024))GB)"
        exit 1
    fi
    
    # 데이터베이스 버전 확인
    pg_version=$(psql --version | grep -oP '\d+\.\d+')
    if ! version_ge $pg_version "13.0"; then
        log "ERROR: PostgreSQL 13+ 필요 (현재: $pg_version)"
        exit 1
    fi
    
    log "전제 조건 확인 완료"
}

# 버전 비교 함수
version_ge() {
    printf '%s\n%s' "$2" "$1" | sort -V -C
}

# Phase 1: 준비
prepare_migration() {
    log "=== Phase 1: 마이그레이션 준비 ==="
    
    # 현재 시스템 감사
    log "현재 시스템 감사..."
    ./scripts/audit_system.sh > /tmp/system_audit.json
    
    # 사용자 데이터 내보내기
    log "사용자 데이터 내보내기..."
    ./scripts/export_user_data.sh /backup/user_export_$(date +%Y%m%d).json
    
    # 전체 백업
    log "전체 시스템 백업..."
    ./scripts/full_backup.sh
    
    # 새 환경 준비
    log "새 환경 준비..."
    cp docker-compose.yml docker-compose.v1.yml
    cp docker-compose.v2.yml docker-compose.yml
    
    log "Phase 1 완료"
}

# Phase 2: 병렬 배포
parallel_deployment() {
    log "=== Phase 2: 병렬 배포 ==="
    
    # v2 시스템을 다른 포트에서 시작
    log "v2 시스템 배포..."
    export COMPOSE_PROJECT_NAME="aicli_v2"
    export API_PORT="8081"
    
    docker-compose up -d --build
    
    # v2 헬스체크
    log "v2 시스템 헬스체크..."
    wait_for_healthy "http://localhost:8081/health" 300
    
    log "Phase 2 완료"
}

# Phase 3: 데이터 마이그레이션
migrate_data() {
    log "=== Phase 3: 데이터 마이그레이션 ==="
    
    # 사용자 계정 마이그레이션
    log "사용자 계정 마이그레이션..."
    ./aicli-web-v2 migrate-users --from-version=1 --to-version=2
    
    # 워크스페이스 마이그레이션
    log "워크스페이스 마이그레이션..."
    ./aicli-web-v2 migrate-workspaces --batch-size=100
    
    # 프로젝트 및 태스크 마이그레이션
    log "프로젝트 및 태스크 마이그레이션..."
    ./aicli-web-v2 migrate-projects-tasks --parallel=4
    
    # 권한 및 역할 마이그레이션
    log "권한 및 역할 마이그레이션..."
    ./aicli-web-v2 migrate-rbac
    
    log "Phase 3 완료"
}

# Phase 4: 검증
verify_migration() {
    log "=== Phase 4: 마이그레이션 검증 ==="
    
    # 데이터 무결성 검증
    log "데이터 무결성 검증..."
    ./scripts/verify_data_integrity.sh v1 v2
    
    # 기능 테스트
    log "기능 테스트..."
    ./scripts/comprehensive_test.sh http://localhost:8081
    
    # 성능 테스트
    log "성능 테스트..."
    ./scripts/performance_test.sh http://localhost:8081
    
    log "Phase 4 완료"
}

# Phase 5: 트래픽 전환
cutover() {
    log "=== Phase 5: 트래픽 전환 ==="
    
    read -p "v2로 트래픽을 전환하시겠습니까? (y/N): " confirm
    if [[ $confirm != [yY] ]]; then
        log "트래픽 전환 취소됨"
        return 1
    fi
    
    # 유지보수 모드 활성화
    log "유지보수 모드 활성화..."
    ./scripts/enable_maintenance_mode.sh
    
    # 최종 데이터 동기화
    log "최종 데이터 동기화..."
    ./aicli-web-v2 sync-final-data
    
    # v1 시스템 중지
    log "v1 시스템 중지..."
    export COMPOSE_PROJECT_NAME="aicli"
    docker-compose stop
    
    # v2 시스템을 메인 포트로 전환
    log "v2 시스템을 메인 포트로 전환..."
    export COMPOSE_PROJECT_NAME="aicli_v2"
    export API_PORT="8080"
    docker-compose up -d --force-recreate
    
    # 헬스체크
    log "전환된 시스템 헬스체크..."
    wait_for_healthy "http://localhost:8080/health" 180
    
    # 유지보수 모드 비활성화
    log "유지보수 모드 비활성화..."
    ./scripts/disable_maintenance_mode.sh
    
    log "Phase 5 완료"
}

# 헬스체크 함수
wait_for_healthy() {
    local url=$1
    local timeout=${2:-120}
    local interval=10
    local elapsed=0
    
    while [ $elapsed -lt $timeout ]; do
        if curl -f "$url" >/dev/null 2>&1; then
            log "헬스체크 성공: $url"
            return 0
        fi
        
        log "헬스체크 대기 중... ($elapsed/${timeout}s)"
        sleep $interval
        elapsed=$((elapsed + interval))
    done
    
    log "헬스체크 실패: $url (timeout: ${timeout}s)"
    return 1
}

# 롤백 함수
rollback_major_migration() {
    log "=== 메이저 마이그레이션 롤백 ==="
    
    # v2 시스템 중지
    export COMPOSE_PROJECT_NAME="aicli_v2"
    docker-compose down
    
    # v1 백업에서 복원
    ./scripts/restore_from_backup.sh
    
    # v1 시스템 재시작
    export COMPOSE_PROJECT_NAME="aicli"
    cp docker-compose.v1.yml docker-compose.yml
    docker-compose up -d
    
    log "롤백 완료"
}

# 메인 실행 함수
main() {
    log "메이저 버전 업데이트 시작: $OLD_VERSION → $NEW_VERSION"
    
    # 에러 발생 시 롤백
    trap rollback_major_migration ERR
    
    check_prerequisites
    prepare_migration
    parallel_deployment
    migrate_data
    verify_migration
    cutover
    
    log "메이저 버전 업데이트 완료!"
    log "로그 파일: $LOG_FILE"
}

# 스크립트 실행
main "$@"
```

## 환경 이전

### 1. 개발 → 스테이징 환경 이전

```bash
#!/bin/bash
# deploy_to_staging.sh

SOURCE_ENV="development"
TARGET_ENV="staging"

echo "환경 이전: $SOURCE_ENV → $TARGET_ENV"

# 1. 환경별 설정 확인
if [ ! -f "configs/staging.yml" ]; then
    echo "스테이징 설정 파일이 없습니다"
    exit 1
fi

# 2. 스테이징 환경에서 사전 테스트
echo "스테이징 환경 사전 점검..."
ssh staging-server "docker system prune -f"
ssh staging-server "df -h"

# 3. 데이터 동기화 (필요한 경우)
echo "테스트 데이터 동기화..."
pg_dump -d development_db | ssh staging-server "psql -d staging_db"

# 4. 환경별 시크릿 업데이트
echo "스테이징 환경 시크릿 업데이트..."
scp .env.staging staging-server:/app/.env

# 5. 애플리케이션 배포
echo "애플리케이션 배포..."
ssh staging-server "cd /app && git pull origin main"
ssh staging-server "cd /app && docker-compose -f docker-compose.staging.yml up -d --build"

# 6. 배포 확인
echo "배포 확인..."
if curl -f https://staging.yourdomain.com/health; then
    echo "스테이징 배포 성공"
else
    echo "스테이징 배포 실패"
    exit 1
fi

echo "환경 이전 완료"
```

### 2. 온프레미스 → 클라우드 이전

```yaml
# cloud_migration_plan.yml
cloud_migration:
  source: "on_premises"
  target: "aws"
  
  strategy: "lift_and_shift_then_optimize"
  
  phases:
    assessment:
      - inventory_current_resources
      - estimate_cloud_costs
      - identify_dependencies
      - plan_network_architecture
      
    preparation:
      - setup_aws_account
      - configure_vpc_and_subnets
      - setup_rds_instance
      - configure_elasticache
      - setup_ecs_cluster
      
    migration:
      - migrate_database
      - migrate_application_code
      - migrate_static_assets
      - configure_load_balancer
      - setup_monitoring
      
    optimization:
      - implement_auto_scaling
      - optimize_costs
      - enhance_security
      - implement_backup_strategy
```

```bash
#!/bin/bash
# cloud_migration.sh

# AWS 클라우드 마이그레이션 스크립트

# 환경 변수
AWS_REGION="us-west-2"
VPC_ID="vpc-xxxxxxxx"
SUBNET_ID="subnet-xxxxxxxx"
RDS_ENDPOINT="aicli.xxxxxxxx.us-west-2.rds.amazonaws.com"

echo "온프레미스 → AWS 클라우드 마이그레이션 시작"

# 1. AWS 리소스 상태 확인
check_aws_resources() {
    echo "AWS 리소스 상태 확인..."
    
    # RDS 인스턴스 상태 확인
    aws rds describe-db-instances --db-instance-identifier aicli-prod \
        --query 'DBInstances[0].DBInstanceStatus' --output text
    
    # ECS 클러스터 상태 확인
    aws ecs describe-clusters --clusters aicli-cluster \
        --query 'clusters[0].status' --output text
    
    # 로드 밸런서 상태 확인
    aws elbv2 describe-load-balancers --names aicli-alb \
        --query 'LoadBalancers[0].State.Code' --output text
}

# 2. 데이터베이스 마이그레이션
migrate_database() {
    echo "데이터베이스 마이그레이션 시작..."
    
    # 온프레미스 DB에서 덤프 생성
    pg_dump -h localhost -U aicli_user aicli \
        --format=custom --compress=9 \
        --file=/tmp/aicli_migration.dump
    
    # AWS S3에 업로드
    aws s3 cp /tmp/aicli_migration.dump s3://aicli-migration-bucket/
    
    # RDS에서 복원
    pg_restore --host=$RDS_ENDPOINT --username=aicli_user --dbname=aicli \
        --no-owner --no-privileges /tmp/aicli_migration.dump
    
    echo "데이터베이스 마이그레이션 완료"
}

# 3. 애플리케이션 배포
deploy_to_ecs() {
    echo "ECS에 애플리케이션 배포..."
    
    # Docker 이미지를 ECR에 푸시
    aws ecr get-login-password --region $AWS_REGION | \
        docker login --username AWS --password-stdin \
        $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com
    
    docker build -t aicli-web .
    docker tag aicli-web:latest \
        $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/aicli-web:latest
    docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/aicli-web:latest
    
    # ECS 서비스 업데이트
    aws ecs update-service \
        --cluster aicli-cluster \
        --service aicli-service \
        --force-new-deployment
    
    echo "ECS 배포 완료"
}

# 4. 설정 마이그레이션
migrate_configuration() {
    echo "설정 마이그레이션..."
    
    # AWS Systems Manager Parameter Store에 설정 저장
    aws ssm put-parameter \
        --name "/aicli/database/url" \
        --value "postgres://user:pass@$RDS_ENDPOINT:5432/aicli" \
        --type "SecureString"
    
    aws ssm put-parameter \
        --name "/aicli/jwt/secret" \
        --value "$JWT_SECRET_KEY" \
        --type "SecureString"
    
    aws ssm put-parameter \
        --name "/aicli/redis/url" \
        --value "$ELASTICACHE_ENDPOINT" \
        --type "String"
    
    echo "설정 마이그레이션 완료"
}

# 5. DNS 전환
switch_dns() {
    echo "DNS 전환..."
    
    # Route 53에서 DNS 레코드 업데이트
    aws route53 change-resource-record-sets \
        --hosted-zone-id Z1PA6795UKMFR9 \
        --change-batch '{
            "Comment": "Migrate to AWS",
            "Changes": [{
                "Action": "UPSERT",
                "ResourceRecordSet": {
                    "Name": "api.yourdomain.com",
                    "Type": "A",
                    "AliasTarget": {
                        "DNSName": "aicli-alb-1234567890.us-west-2.elb.amazonaws.com",
                        "EvaluateTargetHealth": false,
                        "HostedZoneId": "Z1H1FL5HABSF5"
                    }
                }
            }]
        }'
    
    echo "DNS 전환 완료"
}

# 6. 마이그레이션 검증
verify_migration() {
    echo "마이그레이션 검증..."
    
    # 헬스체크
    if curl -f https://api.yourdomain.com/health; then
        echo "애플리케이션 헬스체크 성공"
    else
        echo "애플리케이션 헬스체크 실패"
        return 1
    fi
    
    # 데이터베이스 연결 테스트
    if psql -h $RDS_ENDPOINT -U aicli_user -d aicli -c "SELECT 1;"; then
        echo "데이터베이스 연결 성공"
    else
        echo "데이터베이스 연결 실패"
        return 1
    fi
    
    # 기능 테스트
    ./scripts/integration_test.sh https://api.yourdomain.com
    
    echo "마이그레이션 검증 완료"
}

# 메인 실행
main() {
    check_aws_resources
    migrate_database
    migrate_configuration
    deploy_to_ecs
    
    read -p "DNS를 전환하시겠습니까? (y/N): " confirm
    if [[ $confirm == [yY] ]]; then
        switch_dns
        sleep 60  # DNS 전파 대기
        verify_migration
        echo "클라우드 마이그레이션 완료!"
    else
        echo "DNS 전환이 취소되었습니다. 수동으로 진행하세요."
    fi
}

main "$@"
```

## 설정 마이그레이션

### 1. 설정 파일 형식 변경

```go
// internal/config/migration.go
package config

import (
    "fmt"
    "gopkg.in/yaml.v3"
)

// 설정 마이그레이션 관리자
type ConfigMigrator struct {
    migrations []Migration
}

type Migration struct {
    Version string
    Up      func(map[string]interface{}) error
    Down    func(map[string]interface{}) error
}

func NewConfigMigrator() *ConfigMigrator {
    return &ConfigMigrator{
        migrations: []Migration{
            {
                Version: "1.1.0",
                Up:      migrateToV1_1_0,
                Down:    rollbackFromV1_1_0,
            },
            {
                Version: "2.0.0",
                Up:      migrateToV2_0_0,
                Down:    rollbackFromV2_0_0,
            },
        },
    }
}

// v1.1.0 마이그레이션: 로깅 설정 구조화
func migrateToV1_1_0(config map[string]interface{}) error {
    // 기존 단순 로그 레벨을 구조화된 로깅 설정으로 변경
    if logLevel, exists := config["log_level"]; exists {
        delete(config, "log_level")
        
        config["logging"] = map[string]interface{}{
            "level":  logLevel,
            "format": "json",
            "output": "file",
            "file_path": "/var/log/aicli/app.log",
        }
    }
    
    // 데이터베이스 연결 문자열을 구조화된 설정으로 변경
    if dbUrl, exists := config["database_url"]; exists {
        delete(config, "database_url")
        
        // URL 파싱 로직 (간단화)
        config["database"] = map[string]interface{}{
            "host":     "localhost",
            "port":     5432,
            "user":     "aicli_user",
            "password": "${DB_PASSWORD}",
            "database": "aicli",
            "ssl_mode": "disable",
        }
    }
    
    return nil
}

func rollbackFromV1_1_0(config map[string]interface{}) error {
    // 구조화된 로깅 설정을 단순 로그 레벨로 롤백
    if logging, exists := config["logging"]; exists {
        if loggingMap, ok := logging.(map[string]interface{}); ok {
            if level, exists := loggingMap["level"]; exists {
                config["log_level"] = level
            }
        }
        delete(config, "logging")
    }
    
    // 구조화된 데이터베이스 설정을 연결 문자열로 롤백
    if database, exists := config["database"]; exists {
        if dbMap, ok := database.(map[string]interface{}); ok {
            dbUrl := fmt.Sprintf("postgres://%s:%s@%s:%v/%s?sslmode=%s",
                dbMap["user"], "${DB_PASSWORD}", dbMap["host"], 
                dbMap["port"], dbMap["database"], dbMap["ssl_mode"])
            config["database_url"] = dbUrl
        }
        delete(config, "database")
    }
    
    return nil
}

// v2.0.0 마이그레이션: 보안 설정 대폭 변경
func migrateToV2_0_0(config map[string]interface{}) error {
    // 기존 JWT 설정을 새로운 인증 구조로 변경
    if jwtSecret, exists := config["jwt_secret"]; exists {
        delete(config, "jwt_secret")
        
        config["security"] = map[string]interface{}{
            "jwt": map[string]interface{}{
                "secret_key": jwtSecret,
                "expiry":     "24h",
                "algorithm":  "HS256",
            },
            "oauth2": map[string]interface{}{
                "google": map[string]interface{}{
                    "client_id":     "${GOOGLE_CLIENT_ID}",
                    "client_secret": "${GOOGLE_CLIENT_SECRET}",
                },
            },
            "rbac": map[string]interface{}{
                "enabled": true,
                "cache_ttl": "5m",
            },
        }
    }
    
    return nil
}

func rollbackFromV2_0_0(config map[string]interface{}) error {
    // 새로운 보안 구조를 기존 JWT 설정으로 롤백
    if security, exists := config["security"]; exists {
        if secMap, ok := security.(map[string]interface{}); ok {
            if jwt, exists := secMap["jwt"]; exists {
                if jwtMap, ok := jwt.(map[string]interface{}); ok {
                    if secretKey, exists := jwtMap["secret_key"]; exists {
                        config["jwt_secret"] = secretKey
                    }
                }
            }
        }
        delete(config, "security")
    }
    
    return nil
}

// 설정 마이그레이션 실행
func (cm *ConfigMigrator) MigrateUp(configPath, targetVersion string) error {
    // 현재 설정 읽기
    data, err := os.ReadFile(configPath)
    if err != nil {
        return err
    }
    
    var config map[string]interface{}
    if err := yaml.Unmarshal(data, &config); err != nil {
        return err
    }
    
    // 현재 버전 확인
    currentVersion := config["version"].(string)
    
    // 타겟 버전까지 순차적 마이그레이션
    for _, migration := range cm.migrations {
        if version.Compare(migration.Version, currentVersion) > 0 &&
           version.Compare(migration.Version, targetVersion) <= 0 {
            
            if err := migration.Up(config); err != nil {
                return fmt.Errorf("마이그레이션 %s 실패: %v", migration.Version, err)
            }
            
            config["version"] = migration.Version
        }
    }
    
    // 마이그레이션된 설정 저장
    return cm.saveConfig(configPath, config)
}

func (cm *ConfigMigrator) saveConfig(path string, config map[string]interface{}) error {
    data, err := yaml.Marshal(config)
    if err != nil {
        return err
    }
    
    return os.WriteFile(path, data, 0644)
}
```

### 2. 환경 변수 마이그레이션

```bash
#!/bin/bash
# migrate_env_vars.sh

OLD_ENV_FILE=".env.old"
NEW_ENV_FILE=".env"

echo "환경 변수 마이그레이션 시작..."

# 백업 생성
cp $NEW_ENV_FILE $OLD_ENV_FILE

# 변경된 환경 변수 매핑
declare -A ENV_MAPPING=(
    ["DATABASE_URL"]="DATABASE_HOST DATABASE_PORT DATABASE_USER DATABASE_PASSWORD DATABASE_NAME"
    ["JWT_SECRET"]="JWT_SECRET_KEY"
    ["LOG_LEVEL"]="LOGGING_LEVEL"
    ["REDIS_URL"]="REDIS_HOST REDIS_PORT REDIS_PASSWORD"
)

# 새로운 환경 변수 파일 생성
cat > $NEW_ENV_FILE << EOF
# AICode Manager v2.0 Configuration
# Generated on $(date)

# Database Configuration
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_USER=aicli_user
DATABASE_PASSWORD=${DATABASE_PASSWORD:-$(openssl rand -base64 32)}
DATABASE_NAME=aicli
DATABASE_SSL_MODE=disable

# JWT Configuration
JWT_SECRET_KEY=${JWT_SECRET:-$(openssl rand -base64 64)}
JWT_EXPIRY=24h
JWT_ALGORITHM=HS256

# OAuth2 Configuration
GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID:-}
GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET:-}
GITHUB_CLIENT_ID=${GITHUB_CLIENT_ID:-}
GITHUB_CLIENT_SECRET=${GITHUB_CLIENT_SECRET:-}

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=${REDIS_PASSWORD:-}
REDIS_DB=0

# Logging Configuration
LOGGING_LEVEL=${LOG_LEVEL:-info}
LOGGING_FORMAT=json
LOGGING_OUTPUT=file

# Security Configuration
CSRF_SECRET_KEY=${CSRF_SECRET_KEY:-$(openssl rand -base64 32)}
SESSION_SECRET_KEY=${SESSION_SECRET_KEY:-$(openssl rand -base64 32)}

# Rate Limiting
RATE_LIMIT_GLOBAL=1000
RATE_LIMIT_IP=100
RATE_LIMIT_USER=500

EOF

echo "환경 변수 마이그레이션 완료"
echo "이전 설정은 $OLD_ENV_FILE에 백업되었습니다"
```

## 롤백 절차

### 1. 자동 롤백 시스템

```bash
#!/bin/bash
# rollback_system.sh

set -euo pipefail

ROLLBACK_REASON=${1:-"manual"}
TARGET_VERSION=${2:-""}

# 롤백 상황 분류
case $ROLLBACK_REASON in
    "migration_failed")
        echo "마이그레이션 실패로 인한 롤백"
        rollback_migration
        ;;
    "health_check_failed")
        echo "헬스체크 실패로 인한 롤백"
        rollback_deployment
        ;;
    "performance_degradation")
        echo "성능 저하로 인한 롤백"
        rollback_with_analysis
        ;;
    "manual")
        echo "수동 롤백"
        rollback_interactive
        ;;
    *)
        echo "알 수 없는 롤백 사유: $ROLLBACK_REASON"
        exit 1
        ;;
esac

# 마이그레이션 롤백
rollback_migration() {
    echo "데이터베이스 마이그레이션 롤백 중..."
    
    # 현재 마이그레이션 버전 확인
    current_version=$(./aicli-web migrate version)
    
    if [ -n "$TARGET_VERSION" ]; then
        echo "타겟 버전 $TARGET_VERSION 으로 롤백"
        ./aicli-web migrate down --target-version $TARGET_VERSION
    else
        echo "이전 버전으로 롤백"
        ./aicli-web migrate down --steps 1
    fi
    
    # 마이그레이션 상태 확인
    ./aicli-web migrate status
}

# 배포 롤백
rollback_deployment() {
    echo "애플리케이션 배포 롤백 중..."
    
    # 이전 Docker 이미지로 롤백
    if docker images | grep -q "aicli-web:previous"; then
        docker tag aicli-web:previous aicli-web:latest
        docker-compose up -d --no-deps api
        
        # 헬스체크
        wait_for_healthy "http://localhost:8080/health" 60
    else
        echo "이전 이미지를 찾을 수 없습니다"
        exit 1
    fi
}

# 분석과 함께 롤백
rollback_with_analysis() {
    echo "성능 분석과 함께 롤백 진행..."
    
    # 현재 성능 메트릭 수집
    collect_performance_metrics
    
    # 롤백 실행
    rollback_deployment
    
    # 롤백 후 성능 비교
    sleep 60  # 안정화 대기
    compare_performance_metrics
}

# 대화형 롤백
rollback_interactive() {
    echo "=== 대화형 롤백 메뉴 ==="
    echo "1. 데이터베이스 마이그레이션 롤백"
    echo "2. 애플리케이션 배포 롤백"
    echo "3. 전체 시스템 롤백"
    echo "4. 특정 버전으로 롤백"
    echo "5. 취소"
    
    read -p "선택하세요 (1-5): " choice
    
    case $choice in
        1) rollback_migration ;;
        2) rollback_deployment ;;
        3) rollback_full_system ;;
        4) 
            read -p "타겟 버전을 입력하세요: " version
            rollback_to_specific_version $version
            ;;
        5) echo "롤백 취소됨"; exit 0 ;;
        *) echo "잘못된 선택"; exit 1 ;;
    esac
}

# 전체 시스템 롤백
rollback_full_system() {
    echo "전체 시스템 롤백 시작..."
    
    # 1. 서비스 중지
    echo "서비스 중지 중..."
    docker-compose stop
    
    # 2. 데이터베이스 백업에서 복원
    echo "데이터베이스 복원 중..."
    restore_database_from_backup
    
    # 3. 설정 파일 복원
    echo "설정 파일 복원 중..."
    restore_config_from_backup
    
    # 4. 이전 버전 애플리케이션 시작
    echo "이전 버전 애플리케이션 시작 중..."
    docker-compose -f docker-compose.backup.yml up -d
    
    # 5. 시스템 확인
    echo "시스템 상태 확인 중..."
    verify_rollback_success
    
    echo "전체 시스템 롤백 완료"
}

# 특정 버전으로 롤백
rollback_to_specific_version() {
    local target_version=$1
    
    echo "버전 $target_version 으로 롤백 중..."
    
    # 버전 유효성 검사
    if ! validate_version $target_version; then
        echo "유효하지 않은 버전: $target_version"
        exit 1
    fi
    
    # 해당 버전의 백업 확인
    backup_path="/backup/aicli_${target_version}_*.sql"
    if ! ls $backup_path 1> /dev/null 2>&1; then
        echo "버전 $target_version 의 백업을 찾을 수 없습니다"
        exit 1
    fi
    
    # 롤백 실행
    restore_specific_version $target_version
    
    echo "버전 $target_version 으로 롤백 완료"
}

# 데이터베이스 백업 복원
restore_database_from_backup() {
    local backup_file=$(ls -t /backup/aicli_*.sql | head -n1)
    
    if [ -z "$backup_file" ]; then
        echo "백업 파일을 찾을 수 없습니다"
        exit 1
    fi
    
    echo "백업 파일에서 복원: $backup_file"
    
    # 기존 데이터베이스 삭제 및 재생성
    dropdb aicli 2>/dev/null || true
    createdb aicli
    
    # 백업에서 복원
    pg_restore -d aicli $backup_file
    
    echo "데이터베이스 복원 완료"
}

# 설정 파일 백업 복원
restore_config_from_backup() {
    local config_backup=$(ls -t /backup/config_*.tar.gz | head -n1)
    
    if [ -z "$config_backup" ]; then
        echo "설정 백업 파일을 찾을 수 없습니다"
        exit 1
    fi
    
    echo "설정 파일 복원: $config_backup"
    
    # 현재 설정 백업
    tar -czf /backup/current_config_$(date +%Y%m%d_%H%M%S).tar.gz \
        config.yml docker-compose.yml .env 2>/dev/null || true
    
    # 백업에서 복원
    tar -xzf $config_backup
    
    echo "설정 파일 복원 완료"
}

# 롤백 성공 확인
verify_rollback_success() {
    echo "롤백 성공 확인 중..."
    
    # 헬스체크
    if ! curl -f http://localhost:8080/health; then
        echo "헬스체크 실패"
        return 1
    fi
    
    # 데이터베이스 연결 확인
    if ! psql -d aicli -c "SELECT 1;"; then
        echo "데이터베이스 연결 실패"
        return 1
    fi
    
    # 기본 기능 테스트
    if ! ./scripts/smoke_test.sh; then
        echo "기본 기능 테스트 실패"
        return 1
    fi
    
    echo "롤백 성공 확인 완료"
    return 0
}

# 성능 메트릭 수집
collect_performance_metrics() {
    echo "성능 메트릭 수집 중..."
    
    # CPU, 메모리, 네트워크 사용량 수집
    {
        echo "=== System Metrics ==="
        echo "Timestamp: $(date)"
        echo "CPU Usage:"
        top -bn1 | grep "Cpu(s)"
        echo "Memory Usage:"
        free -h
        echo "Network Connections:"
        netstat -an | wc -l
        echo "Docker Stats:"
        docker stats --no-stream
    } > /tmp/rollback_metrics_before.txt
}

# 성능 메트릭 비교
compare_performance_metrics() {
    echo "성능 메트릭 비교 중..."
    
    # 롤백 후 메트릭 수집
    collect_performance_metrics
    mv /tmp/rollback_metrics_before.txt /tmp/rollback_metrics_after.txt
    
    # 비교 결과 출력
    echo "=== 롤백 전후 성능 비교 ==="
    echo "Before rollback:"
    cat /tmp/rollback_metrics_before.txt
    echo -e "\nAfter rollback:"
    cat /tmp/rollback_metrics_after.txt
}

# 헬스체크 대기 함수
wait_for_healthy() {
    local url=$1
    local timeout=${2:-60}
    local interval=5
    local elapsed=0
    
    while [ $elapsed -lt $timeout ]; do
        if curl -f "$url" >/dev/null 2>&1; then
            echo "헬스체크 성공"
            return 0
        fi
        
        echo "헬스체크 대기 중... ($elapsed/${timeout}s)"
        sleep $interval
        elapsed=$((elapsed + interval))
    done
    
    echo "헬스체크 실패 (timeout: ${timeout}s)"
    return 1
}

# 버전 유효성 검사
validate_version() {
    local version=$1
    # 간단한 버전 형식 검사 (x.y.z)
    [[ $version =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]
}

# 메인 실행
echo "롤백 시작: 사유=$ROLLBACK_REASON"
```

### 2. 롤백 검증

```bash
#!/bin/bash
# verify_rollback.sh

echo "롤백 검증 시작..."

# 1. 시스템 상태 확인
check_system_status() {
    echo "시스템 상태 확인..."
    
    # 프로세스 확인
    if ! pgrep -f "aicli-web" > /dev/null; then
        echo "ERROR: aicli-web 프로세스가 실행되지 않음"
        return 1
    fi
    
    # 포트 확인
    if ! netstat -tlnp | grep -q ":8080"; then
        echo "ERROR: 포트 8080이 열려있지 않음"
        return 1
    fi
    
    echo "시스템 상태 정상"
    return 0
}

# 2. 데이터베이스 무결성 확인
check_database_integrity() {
    echo "데이터베이스 무결성 확인..."
    
    # 테이블 존재 확인
    local tables=("users" "workspaces" "projects" "tasks")
    for table in "${tables[@]}"; do
        if ! psql -d aicli -t -c "SELECT to_regclass('$table');" | grep -q "$table"; then
            echo "ERROR: 테이블 $table 이 존재하지 않음"
            return 1
        fi
    done
    
    # 데이터 개수 확인
    local user_count=$(psql -d aicli -t -c "SELECT COUNT(*) FROM users;" | xargs)
    if [ "$user_count" -eq 0 ]; then
        echo "WARNING: users 테이블이 비어있음"
    fi
    
    echo "데이터베이스 무결성 확인 완료"
    return 0
}

# 3. 기능 테스트
run_functional_tests() {
    echo "기능 테스트 실행..."
    
    # API 엔드포인트 테스트
    local endpoints=(
        "/health"
        "/api/v1/auth/me"
        "/api/v1/workspaces"
        "/api/v1/users/profile"
    )
    
    for endpoint in "${endpoints[@]}"; do
        if ! curl -f "http://localhost:8080$endpoint" >/dev/null 2>&1; then
            echo "WARNING: 엔드포인트 $endpoint 응답 없음"
        fi
    done
    
    echo "기능 테스트 완료"
    return 0
}

# 4. 성능 테스트
run_performance_tests() {
    echo "성능 테스트 실행..."
    
    # 응답 시간 테스트
    local response_time=$(curl -o /dev/null -s -w '%{time_total}' http://localhost:8080/health)
    local max_response_time=5.0
    
    if (( $(echo "$response_time > $max_response_time" | bc -l) )); then
        echo "WARNING: 응답 시간이 느림 (${response_time}s > ${max_response_time}s)"
    else
        echo "응답 시간 정상: ${response_time}s"
    fi
    
    echo "성능 테스트 완료"
    return 0
}

# 5. 로그 확인
check_logs() {
    echo "로그 확인..."
    
    local log_file="/var/log/aicli/app.log"
    
    if [ -f "$log_file" ]; then
        local error_count=$(tail -n 100 "$log_file" | grep -i error | wc -l)
        if [ "$error_count" -gt 5 ]; then
            echo "WARNING: 최근 로그에 에러가 많음 ($error_count 건)"
            echo "최근 에러 로그:"
            tail -n 100 "$log_file" | grep -i error | tail -n 5
        else
            echo "로그 상태 정상 (에러: $error_count 건)"
        fi
    else
        echo "WARNING: 로그 파일을 찾을 수 없음: $log_file"
    fi
    
    return 0
}

# 6. 종합 보고서 생성
generate_report() {
    local report_file="/tmp/rollback_verification_$(date +%Y%m%d_%H%M%S).txt"
    
    {
        echo "=== 롤백 검증 보고서 ==="
        echo "생성 시간: $(date)"
        echo "검증 대상: AICode Manager"
        echo
        echo "=== 검증 결과 ==="
        
        if check_system_status; then
            echo "✓ 시스템 상태: 정상"
        else
            echo "✗ 시스템 상태: 이상"
        fi
        
        if check_database_integrity; then
            echo "✓ 데이터베이스 무결성: 정상"
        else
            echo "✗ 데이터베이스 무결성: 이상"
        fi
        
        run_functional_tests
        echo "✓ 기능 테스트: 완료"
        
        run_performance_tests
        echo "✓ 성능 테스트: 완료"
        
        check_logs
        echo "✓ 로그 확인: 완료"
        
        echo
        echo "=== 권장 사항 ==="
        echo "- 24시간 동안 시스템 모니터링 지속"
        echo "- 사용자 피드백 수집"
        echo "- 성능 메트릭 관찰"
        echo "- 롤백 원인 분석 및 문서화"
        
    } | tee "$report_file"
    
    echo "검증 보고서 생성됨: $report_file"
}

# 메인 실행
main() {
    generate_report
    
    echo
    echo "롤백 검증 완료"
    echo "추가 문제가 발생하면 즉시 시스템 관리자에게 연락하세요"
}

main "$@"
```

이상으로 마이그레이션 가이드를 완성했습니다. 이제 마지막 서브태스크인 "문서 사이트 구축 (선택적)"을 진행하겠습니다.