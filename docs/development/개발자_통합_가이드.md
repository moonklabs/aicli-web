# AICode Manager 개발자 통합 가이드

## 📖 목차

1. [개발 환경 설정](#개발-환경-설정)
2. [프로젝트 구조](#프로젝트-구조)
3. [API 통합](#api-통합)
4. [인증 시스템 연동](#인증-시스템-연동)
5. [SDK 및 라이브러리](#sdk-및-라이브러리)
6. [코드 예제](#코드-예제)
7. [테스팅](#테스팅)
8. [디버깅](#디버깅)
9. [베스트 프랙티스](#베스트-프랙티스)
10. [FAQ](#faq)

---

## 🔧 개발 환경 설정

### 필수 요구사항

#### 시스템 요구사항
- **Go**: 1.21+ (권장: 1.24+)
- **Node.js**: 18+ (프론트엔드 개발 시)
- **PostgreSQL**: 13+
- **Redis**: 6+
- **Git**: 2.30+

#### 개발 도구
- **IDE**: VSCode / GoLand / Vim
- **API 도구**: Postman / Insomnia / cURL
- **DB 도구**: pgAdmin / DBeaver
- **터미널**: zsh / bash

### 프로젝트 설정

#### 1. 저장소 클론
```bash
git clone https://github.com/aicli/aicli-web.git
cd aicli-web
```

#### 2. 의존성 설치
```bash
# Go 모듈 의존성
go mod download

# 개발 도구 설치
go install github.com/swaggo/swag/cmd/swag@latest
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install github.com/golang/mock/mockgen@latest
```

#### 3. 개발 환경 설정
```bash
# 환경 변수 설정
cp .env.example .env.development
# .env.development 파일 편집

# 데이터베이스 설정
make db-setup-dev

# 개발 서버 실행
make dev
```

#### 4. VSCode 설정
```json
// .vscode/settings.json
{
  "go.toolsManagement.checkForUpdates": "local",
  "go.useLanguageServer": true,
  "go.lintTool": "golangci-lint",
  "go.lintFlags": [
    "--fast"
  ],
  "go.testFlags": [
    "-v",
    "-race"
  ],
  "go.testTimeout": "30s",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": true
  }
}
```

---

## 🏗️ 프로젝트 구조

### 디렉토리 구조 상세

```
aicli-web/
├── cmd/                           # 애플리케이션 엔트리포인트
│   └── api/
│       └── main.go               # API 서버 메인 함수
├── internal/                     # 내부 패키지 (외부 노출 안됨)
│   ├── auth/                     # 인증 시스템
│   │   ├── jwt.go               # JWT 관리
│   │   ├── oauth.go             # OAuth 통합
│   │   ├── rbac.go              # 역할 기반 접근 제어
│   │   └── session.go           # 세션 관리
│   ├── middleware/               # HTTP 미들웨어
│   │   ├── auth.go              # 인증 미들웨어
│   │   ├── cors.go              # CORS 처리
│   │   ├── ratelimit.go         # Rate Limiting
│   │   └── security.go          # 보안 헤더
│   ├── services/                 # 비즈니스 로직
│   │   ├── user.go              # 사용자 서비스
│   │   ├── project.go           # 프로젝트 서비스
│   │   └── workspace.go         # 워크스페이스 서비스
│   ├── storage/                  # 데이터 저장소
│   │   ├── interface.go         # 저장소 인터페이스
│   │   ├── postgres/            # PostgreSQL 구현
│   │   └── memory/              # 메모리 구현 (테스트용)
│   ├── api/                      # API 핸들러
│   │   ├── handlers/            # HTTP 핸들러
│   │   └── websocket/           # WebSocket 핸들러
│   ├── config/                   # 설정 관리
│   │   ├── config.go            # 설정 구조체
│   │   └── loader.go            # 설정 로더
│   └── models/                   # 데이터 모델
│       ├── user.go              # 사용자 모델
│       ├── project.go           # 프로젝트 모델
│       └── auth.go              # 인증 모델
├── pkg/                          # 외부 패키지 (재사용 가능)
│   ├── logger/                  # 로깅 유틸리티
│   ├── validator/               # 입력 검증
│   └── errors/                  # 에러 처리
├── test/                         # 테스트 파일
│   ├── integration/             # 통합 테스트
│   ├── unit/                    # 단위 테스트
│   └── fixtures/                # 테스트 데이터
├── docs/                         # 문서
│   ├── api/                     # API 문서
│   ├── development/             # 개발 가이드
│   └── operations/              # 운영 가이드
├── scripts/                      # 유틸리티 스크립트
│   ├── build.sh                # 빌드 스크립트
│   ├── migrate.sh              # 마이그레이션 스크립트
│   └── test.sh                 # 테스트 스크립트
├── deploy/                       # 배포 관련 파일
│   ├── docker/                 # Docker 파일
│   ├── k8s/                    # Kubernetes 매니페스트
│   └── nginx/                  # Nginx 설정
├── Makefile                      # 빌드 자동화
├── go.mod                        # Go 모듈 정의
├── go.sum                        # 의존성 체크섬
└── README.md                     # 프로젝트 개요
```

### 패키지 의존성 규칙

#### Import 규칙
```go
// 올바른 import 순서
import (
    // 1. 표준 라이브러리
    "context"
    "fmt"
    "net/http"
    
    // 2. 외부 의존성
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    
    // 3. 내부 패키지
    "github.com/aicli/aicli-web/internal/auth"
    "github.com/aicli/aicli-web/internal/models"
    "github.com/aicli/aicli-web/pkg/logger"
)
```

#### 순환 의존성 방지
- `internal/` 패키지는 외부에서 import 불가
- `pkg/` 패키지는 `internal/`을 import 불가
- 인터페이스를 통한 의존성 역전 사용

---

## 🔌 API 통합

### REST API 기본 사용법

#### 1. 인증 토큰 획득
```bash
# 일반 로그인
curl -X POST "http://localhost:8080/api/v1/auth/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "password123"
  }'
```

응답:
```json
{
  "user": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "email": "user@example.com",
    "name": "홍길동"
  },
  "tokens": {
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "token_type": "Bearer",
    "expires_in": 3600
  }
}
```

#### 2. API 호출 시 인증 헤더 포함
```bash
curl -X GET "http://localhost:8080/api/v1/users/me" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

#### 3. 토큰 갱신
```bash
curl -X POST "http://localhost:8080/api/v1/auth/refresh" \
  -H "Content-Type: application/json" \
  -d '{
    "refresh_token": "YOUR_REFRESH_TOKEN"
  }'
```

### HTTP 클라이언트 예제

#### Go 클라이언트
```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type APIClient struct {
    BaseURL     string
    AccessToken string
    HTTPClient  *http.Client
}

type LoginRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type LoginResponse struct {
    User   User   `json:"user"`
    Tokens Tokens `json:"tokens"`
}

type User struct {
    ID    string `json:"id"`
    Email string `json:"email"`
    Name  string `json:"name"`
}

type Tokens struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
    TokenType    string `json:"token_type"`
    ExpiresIn    int    `json:"expires_in"`
}

func NewAPIClient(baseURL string) *APIClient {
    return &APIClient{
        BaseURL:    baseURL,
        HTTPClient: &http.Client{},
    }
}

func (c *APIClient) Login(email, password string) (*LoginResponse, error) {
    loginReq := LoginRequest{
        Email:    email,
        Password: password,
    }
    
    reqBody, err := json.Marshal(loginReq)
    if err != nil {
        return nil, err
    }
    
    resp, err := c.HTTPClient.Post(
        c.BaseURL+"/api/v1/auth/login",
        "application/json",
        bytes.NewBuffer(reqBody),
    )
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var loginResp LoginResponse
    if err := json.NewDecoder(resp.Body).Decode(&loginResp); err != nil {
        return nil, err
    }
    
    // 토큰 저장
    c.AccessToken = loginResp.Tokens.AccessToken
    
    return &loginResp, nil
}

func (c *APIClient) GetCurrentUser() (*User, error) {
    req, err := http.NewRequest("GET", c.BaseURL+"/api/v1/users/me", nil)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", "Bearer "+c.AccessToken)
    
    resp, err := c.HTTPClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}

// 사용 예제
func main() {
    client := NewAPIClient("http://localhost:8080")
    
    // 로그인
    loginResp, err := client.Login("user@example.com", "password123")
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("로그인 성공: %s\n", loginResp.User.Name)
    
    // 현재 사용자 정보 조회
    user, err := client.GetCurrentUser()
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("현재 사용자: %s (%s)\n", user.Name, user.Email)
}
```

#### JavaScript/TypeScript 클라이언트
```typescript
// types.ts
export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  user: User;
  tokens: Tokens;
}

export interface User {
  id: string;
  email: string;
  name: string;
  avatar_url?: string;
  roles: Role[];
}

export interface Tokens {
  access_token: string;
  refresh_token: string;
  token_type: string;
  expires_in: number;
}

export interface Role {
  id: string;
  name: string;
  display_name: string;
}

// api-client.ts
class APIClient {
  private baseURL: string;
  private accessToken: string | null = null;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  async login(email: string, password: string): Promise<LoginResponse> {
    const response = await fetch(`${this.baseURL}/api/v1/auth/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      throw new Error(`로그인 실패: ${response.statusText}`);
    }

    const data: LoginResponse = await response.json();
    this.accessToken = data.tokens.access_token;
    
    return data;
  }

  async getCurrentUser(): Promise<User> {
    if (!this.accessToken) {
      throw new Error('로그인이 필요합니다');
    }

    const response = await fetch(`${this.baseURL}/api/v1/users/me`, {
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`사용자 정보 조회 실패: ${response.statusText}`);
    }

    return response.json();
  }

  async getProjects(page: number = 1, limit: number = 20): Promise<Project[]> {
    if (!this.accessToken) {
      throw new Error('로그인이 필요합니다');
    }

    const params = new URLSearchParams({
      page: page.toString(),
      limit: limit.toString(),
    });

    const response = await fetch(`${this.baseURL}/api/v1/projects?${params}`, {
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`프로젝트 목록 조회 실패: ${response.statusText}`);
    }

    const data = await response.json();
    return data.projects;
  }

  async createProject(name: string, description?: string): Promise<Project> {
    if (!this.accessToken) {
      throw new Error('로그인이 필요합니다');
    }

    const response = await fetch(`${this.baseURL}/api/v1/projects`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.accessToken}`,
      },
      body: JSON.stringify({ name, description }),
    });

    if (!response.ok) {
      throw new Error(`프로젝트 생성 실패: ${response.statusText}`);
    }

    return response.json();
  }
}

// 사용 예제
async function example() {
  const client = new APIClient('http://localhost:8080');
  
  try {
    // 로그인
    const loginResponse = await client.login('user@example.com', 'password123');
    console.log('로그인 성공:', loginResponse.user.name);
    
    // 현재 사용자 정보
    const user = await client.getCurrentUser();
    console.log('현재 사용자:', user);
    
    // 프로젝트 목록 조회
    const projects = await client.getProjects();
    console.log('프로젝트 목록:', projects);
    
    // 새 프로젝트 생성
    const newProject = await client.createProject('My New Project', '새로운 프로젝트입니다');
    console.log('생성된 프로젝트:', newProject);
  } catch (error) {
    console.error('에러:', error);
  }
}
```

---

## 🔐 인증 시스템 연동

### JWT 토큰 처리

#### 토큰 구조 이해
```bash
# JWT 토큰 디코딩 (헤더)
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d
# {"alg":"HS256","typ":"JWT"}

# JWT 토큰 디코딩 (페이로드)
echo "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ" | base64 -d
# {"sub":"1234567890","name":"John Doe","iat":1516239022}
```

#### Go에서 JWT 검증
```go
package main

import (
    "fmt"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
    UserID   string   `json:"user_id"`
    Email    string   `json:"email"`
    Provider string   `json:"provider"`
    Roles    []string `json:"roles"`
    jwt.RegisteredClaims
}

func validateJWT(tokenString, secret string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // 알고리즘 검증
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("예상치 못한 서명 알고리즘: %v", token.Header["alg"])
        }
        return []byte(secret), nil
    })
    
    if err != nil {
        return nil, err
    }
    
    claims, ok := token.Claims.(*Claims)
    if !ok || !token.Valid {
        return nil, fmt.Errorf("유효하지 않은 토큰")
    }
    
    // 만료 시간 확인
    if claims.ExpiresAt.Time.Before(time.Now()) {
        return nil, fmt.Errorf("토큰이 만료되었습니다")
    }
    
    return claims, nil
}

// 미들웨어에서 사용
func AuthMiddleware(secret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization 헤더가 필요합니다"})
            c.Abort()
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := validateJWT(tokenString, secret)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
            c.Abort()
            return
        }
        
        // 컨텍스트에 사용자 정보 저장
        c.Set("user_id", claims.UserID)
        c.Set("user_email", claims.Email)
        c.Set("user_roles", claims.Roles)
        
        c.Next()
    }
}
```

### OAuth 통합

#### Google OAuth 플로우
```go
package auth

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/google"
)

type GoogleOAuthConfig struct {
    ClientID     string
    ClientSecret string
    RedirectURL  string
}

type GoogleUserInfo struct {
    ID            string `json:"id"`
    Email         string `json:"email"`
    VerifiedEmail bool   `json:"verified_email"`
    Name          string `json:"name"`
    Picture       string `json:"picture"`
}

func NewGoogleOAuthConfig(config GoogleOAuthConfig) *oauth2.Config {
    return &oauth2.Config{
        ClientID:     config.ClientID,
        ClientSecret: config.ClientSecret,
        RedirectURL:  config.RedirectURL,
        Scopes: []string{
            "https://www.googleapis.com/auth/userinfo.email",
            "https://www.googleapis.com/auth/userinfo.profile",
        },
        Endpoint: google.Endpoint,
    }
}

func (s *AuthService) HandleGoogleLogin(c *gin.Context) {
    state := generateRandomState() // CSRF 방지를 위한 state 생성
    
    // 세션에 state 저장
    session := sessions.Default(c)
    session.Set("oauth_state", state)
    session.Save()
    
    url := s.googleOAuth.AuthCodeURL(state)
    c.Redirect(http.StatusTemporaryRedirect, url)
}

func (s *AuthService) HandleGoogleCallback(c *gin.Context) {
    // State 검증
    session := sessions.Default(c)
    savedState := session.Get("oauth_state")
    if savedState != c.Query("state") {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid state"})
        return
    }
    
    // Authorization Code로 토큰 교환
    code := c.Query("code")
    token, err := s.googleOAuth.Exchange(context.Background(), code)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to exchange token"})
        return
    }
    
    // 사용자 정보 가져오기
    userInfo, err := s.getGoogleUserInfo(token.AccessToken)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user info"})
        return
    }
    
    // 사용자 등록/로그인 처리
    user, err := s.processOAuthUser(userInfo.Email, userInfo.Name, "google")
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process user"})
        return
    }
    
    // JWT 토큰 생성
    jwtTokens, err := s.jwtManager.GenerateTokens(&Claims{
        UserID:   user.ID,
        Email:    user.Email,
        Provider: "google",
    })
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate tokens"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "user":   user,
        "tokens": jwtTokens,
    })
}

func (s *AuthService) getGoogleUserInfo(accessToken string) (*GoogleUserInfo, error) {
    resp, err := http.Get("https://www.googleapis.com/oauth2/v2/userinfo?access_token=" + accessToken)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var userInfo GoogleUserInfo
    if err := json.NewDecoder(resp.Body).Decode(&userInfo); err != nil {
        return nil, err
    }
    
    return &userInfo, nil
}
```

### RBAC (역할 기반 접근 제어)

#### 권한 확인 미들웨어
```go
package middleware

import (
    "net/http"
    "strings"
    
    "github.com/gin-gonic/gin"
)

// RequirePermission 특정 권한이 필요한 엔드포인트를 보호
func RequirePermission(resource, action string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, exists := c.Get("user_id")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "인증이 필요합니다"})
            c.Abort()
            return
        }
        
        // RBAC 서비스에서 권한 확인
        rbacService := c.MustGet("rbac_service").(RBACService)
        hasPermission, err := rbacService.CheckPermission(
            c.Request.Context(),
            userID.(string),
            resource,
            action,
            nil, // 추가 컨텍스트
        )
        
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "권한 확인 중 오류가 발생했습니다"})
            c.Abort()
            return
        }
        
        if !hasPermission {
            c.JSON(http.StatusForbidden, gin.H{"error": "권한이 없습니다"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// RequireRole 특정 역할이 필요한 엔드포인트를 보호
func RequireRole(roles ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userRoles, exists := c.Get("user_roles")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "인증이 필요합니다"})
            c.Abort()
            return
        }
        
        userRolesList := userRoles.([]string)
        hasRole := false
        
        for _, requiredRole := range roles {
            for _, userRole := range userRolesList {
                if userRole == requiredRole {
                    hasRole = true
                    break
                }
            }
            if hasRole {
                break
            }
        }
        
        if !hasRole {
            c.JSON(http.StatusForbidden, gin.H{
                "error": fmt.Sprintf("다음 역할 중 하나가 필요합니다: %s", 
                    strings.Join(roles, ", ")),
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// 사용 예제
func setupRoutes(r *gin.Engine) {
    api := r.Group("/api/v1")
    api.Use(AuthMiddleware("your-secret"))
    
    // 관리자만 접근 가능
    admin := api.Group("/admin")
    admin.Use(RequireRole("admin"))
    {
        admin.GET("/users", listAllUsers)
        admin.DELETE("/users/:id", deleteUser)
    }
    
    // 특정 권한이 필요한 엔드포인트
    api.GET("/projects", RequirePermission("projects", "read"), listProjects)
    api.POST("/projects", RequirePermission("projects", "create"), createProject)
    api.PUT("/projects/:id", RequirePermission("projects", "update"), updateProject)
    api.DELETE("/projects/:id", RequirePermission("projects", "delete"), deleteProject)
}
```

---

## 📚 SDK 및 라이브러리

### Go SDK

#### 설치
```bash
go get github.com/aicli/aicli-web-sdk-go
```

#### 사용법
```go
package main

import (
    "context"
    "log"
    
    "github.com/aicli/aicli-web-sdk-go"
)

func main() {
    // 클라이언트 생성
    client := aicli.NewClient(&aicli.Config{
        BaseURL: "http://localhost:8080",
        APIKey:  "your-api-key", // 또는 OAuth 토큰
    })
    
    ctx := context.Background()
    
    // 사용자 인증
    loginResp, err := client.Auth.Login(ctx, &aicli.LoginRequest{
        Email:    "user@example.com",
        Password: "password123",
    })
    if err != nil {
        log.Fatal(err)
    }
    
    // 토큰 설정
    client.SetAccessToken(loginResp.Tokens.AccessToken)
    
    // 현재 사용자 정보
    user, err := client.Users.GetCurrent(ctx)
    if err != nil {
        log.Fatal(err)
    }
    log.Printf("Current user: %s (%s)", user.Name, user.Email)
    
    // 프로젝트 목록
    projects, err := client.Projects.List(ctx, &aicli.ListProjectsRequest{
        Page:  1,
        Limit: 20,
    })
    if err != nil {
        log.Fatal(err)
    }
    log.Printf("Found %d projects", len(projects.Projects))
    
    // 새 프로젝트 생성
    newProject, err := client.Projects.Create(ctx, &aicli.CreateProjectRequest{
        Name:        "My SDK Project",
        Description: "SDK로 생성한 프로젝트",
    })
    if err != nil {
        log.Fatal(err)
    }
    log.Printf("Created project: %s (ID: %s)", newProject.Name, newProject.ID)
}
```

### JavaScript/TypeScript SDK

#### 설치
```bash
npm install @aicli/web-sdk
# 또는
yarn add @aicli/web-sdk
```

#### 사용법
```typescript
import { AICodeClient } from '@aicli/web-sdk';

// 클라이언트 생성
const client = new AICodeClient({
  baseURL: 'http://localhost:8080',
  apiKey: 'your-api-key', // 선택적
});

async function example() {
  try {
    // 로그인
    const loginResponse = await client.auth.login({
      email: 'user@example.com',
      password: 'password123',
    });
    
    console.log('로그인 성공:', loginResponse.user.name);
    
    // 자동으로 토큰 설정됨
    
    // 현재 사용자 정보
    const currentUser = await client.users.getCurrent();
    console.log('현재 사용자:', currentUser);
    
    // 프로젝트 목록
    const projects = await client.projects.list({
      page: 1,
      limit: 20,
    });
    console.log('프로젝트 목록:', projects.projects);
    
    // 새 프로젝트 생성
    const newProject = await client.projects.create({
      name: 'My SDK Project',
      description: 'SDK로 생성한 프로젝트',
    });
    console.log('생성된 프로젝트:', newProject);
    
    // WebSocket 연결
    const ws = client.websocket.connect();
    
    ws.on('project.updated', (data) => {
      console.log('프로젝트 업데이트:', data);
    });
    
    ws.on('user.notification', (notification) => {
      console.log('알림:', notification);
    });
    
  } catch (error) {
    console.error('오류:', error);
  }
}

example();
```

### React Hook

#### 설치
```bash
npm install @aicli/react-hooks
```

#### 사용법
```tsx
import React from 'react';
import { AICodeProvider, useAuth, useProjects } from '@aicli/react-hooks';

// App 루트에서 Provider 설정
function App() {
  return (
    <AICodeProvider
      config={{
        baseURL: 'http://localhost:8080',
      }}
    >
      <Dashboard />
    </AICodeProvider>
  );
}

// 컴포넌트에서 hooks 사용
function Dashboard() {
  const { user, login, logout, isAuthenticated } = useAuth();
  const { 
    projects, 
    loading, 
    error, 
    createProject, 
    updateProject, 
    deleteProject 
  } = useProjects();

  const handleLogin = async () => {
    try {
      await login({
        email: 'user@example.com',
        password: 'password123',
      });
    } catch (error) {
      console.error('로그인 실패:', error);
    }
  };

  const handleCreateProject = async () => {
    try {
      await createProject({
        name: '새 프로젝트',
        description: '설명',
      });
    } catch (error) {
      console.error('프로젝트 생성 실패:', error);
    }
  };

  if (!isAuthenticated) {
    return (
      <div>
        <button onClick={handleLogin}>로그인</button>
      </div>
    );
  }

  return (
    <div>
      <h1>안녕하세요, {user?.name}님!</h1>
      
      <button onClick={logout}>로그아웃</button>
      
      <h2>프로젝트 목록</h2>
      {loading && <p>로딩 중...</p>}
      {error && <p>오류: {error.message}</p>}
      
      <button onClick={handleCreateProject}>새 프로젝트 생성</button>
      
      <ul>
        {projects?.map((project) => (
          <li key={project.id}>
            {project.name} - {project.description}
            <button onClick={() => updateProject(project.id, { name: '수정된 이름' })}>
              수정
            </button>
            <button onClick={() => deleteProject(project.id)}>
              삭제
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## 💡 코드 예제

### WebSocket 실시간 통신

#### 서버 측 (Go)
```go
package websocket

import (
    "encoding/json"
    "log"
    "net/http"
    
    "github.com/gin-gonic/gin"
    "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // 프로덕션에서는 적절한 검증 필요
    },
}

type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    hub    *Hub
    conn   *websocket.Conn
    send   chan []byte
    userID string
}

type Message struct {
    Type    string      `json:"type"`
    Payload interface{} `json:"payload"`
    UserID  string      `json:"user_id,omitempty"`
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client] = true
            log.Printf("클라이언트 연결: %s", client.userID)
            
        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
                log.Printf("클라이언트 해제: %s", client.userID)
            }
            
        case message := <-h.broadcast:
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
        }
    }
}

func (h *Hub) HandleWebSocket(c *gin.Context) {
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "인증이 필요합니다"})
        return
    }
    
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        log.Printf("WebSocket 업그레이드 실패: %v", err)
        return
    }
    
    client := &Client{
        hub:    h,
        conn:   conn,
        send:   make(chan []byte, 256),
        userID: userID.(string),
    }
    
    client.hub.register <- client
    
    go client.writePump()
    go client.readPump()
}

func (c *Client) readPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()
    
    for {
        _, messageBytes, err := c.conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                log.Printf("WebSocket 에러: %v", err)
            }
            break
        }
        
        var msg Message
        if err := json.Unmarshal(messageBytes, &msg); err != nil {
            log.Printf("메시지 파싱 에러: %v", err)
            continue
        }
        
        msg.UserID = c.userID
        
        // 메시지 처리 로직
        c.handleMessage(&msg)
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()
    
    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            
            c.conn.WriteMessage(websocket.TextMessage, message)
        }
    }
}

func (c *Client) handleMessage(msg *Message) {
    switch msg.Type {
    case "project.subscribe":
        // 프로젝트 구독 처리
        projectID := msg.Payload.(string)
        log.Printf("사용자 %s가 프로젝트 %s를 구독했습니다", c.userID, projectID)
        
    case "project.unsubscribe":
        // 프로젝트 구독 해제 처리
        projectID := msg.Payload.(string)
        log.Printf("사용자 %s가 프로젝트 %s 구독을 해제했습니다", c.userID, projectID)
        
    default:
        log.Printf("알 수 없는 메시지 타입: %s", msg.Type)
    }
}

// 특정 사용자에게 메시지 전송
func (h *Hub) SendToUser(userID string, message *Message) {
    messageBytes, err := json.Marshal(message)
    if err != nil {
        log.Printf("메시지 직렬화 에러: %v", err)
        return
    }
    
    for client := range h.clients {
        if client.userID == userID {
            select {
            case client.send <- messageBytes:
            default:
                close(client.send)
                delete(h.clients, client)
            }
        }
    }
}

// 모든 클라이언트에게 브로드캐스트
func (h *Hub) Broadcast(message *Message) {
    messageBytes, err := json.Marshal(message)
    if err != nil {
        log.Printf("메시지 직렬화 에러: %v", err)
        return
    }
    
    h.broadcast <- messageBytes
}
```

#### 클라이언트 측 (JavaScript)
```javascript
class WebSocketClient {
  constructor(url, token) {
    this.url = url;
    this.token = token;
    this.ws = null;
    this.reconnectInterval = 5000;
    this.maxReconnectAttempts = 5;
    this.reconnectAttempts = 0;
    this.listeners = new Map();
  }

  connect() {
    try {
      this.ws = new WebSocket(`${this.url}?token=${this.token}`);
      
      this.ws.onopen = (event) => {
        console.log('WebSocket 연결됨');
        this.reconnectAttempts = 0;
        this.emit('connected', event);
      };
      
      this.ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          this.emit(message.type, message.payload);
        } catch (error) {
          console.error('메시지 파싱 에러:', error);
        }
      };
      
      this.ws.onclose = (event) => {
        console.log('WebSocket 연결 종료:', event.code, event.reason);
        this.emit('disconnected', event);
        this.handleReconnect();
      };
      
      this.ws.onerror = (error) => {
        console.error('WebSocket 에러:', error);
        this.emit('error', error);
      };
      
    } catch (error) {
      console.error('WebSocket 연결 실패:', error);
      this.handleReconnect();
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  send(type, payload) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type, payload }));
    } else {
      console.warn('WebSocket이 연결되지 않음');
    }
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  off(event, callback) {
    if (this.listeners.has(event)) {
      const callbacks = this.listeners.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error('이벤트 핸들러 에러:', error);
        }
      });
    }
  }

  handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`재연결 시도 ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
      
      setTimeout(() => {
        this.connect();
      }, this.reconnectInterval);
    } else {
      console.error('최대 재연결 시도 횟수 초과');
      this.emit('max_reconnect_attempts_reached');
    }
  }

  // 프로젝트 구독
  subscribeToProject(projectId) {
    this.send('project.subscribe', projectId);
  }

  // 프로젝트 구독 해제
  unsubscribeFromProject(projectId) {
    this.send('project.unsubscribe', projectId);
  }
}

// 사용 예제
const wsClient = new WebSocketClient('ws://localhost:8080/ws', 'your-jwt-token');

// 이벤트 리스너 등록
wsClient.on('connected', () => {
  console.log('WebSocket 연결 성공');
  
  // 프로젝트 구독
  wsClient.subscribeToProject('project-123');
});

wsClient.on('project.updated', (data) => {
  console.log('프로젝트 업데이트:', data);
  // UI 업데이트 로직
});

wsClient.on('user.notification', (notification) => {
  console.log('알림:', notification);
  // 알림 표시 로직
});

wsClient.on('disconnected', () => {
  console.log('WebSocket 연결 해제');
});

wsClient.on('error', (error) => {
  console.error('WebSocket 에러:', error);
});

// 연결 시작
wsClient.connect();

// 페이지 종료 시 연결 해제
window.addEventListener('beforeunload', () => {
  wsClient.disconnect();
});
```

---

## 🧪 테스팅

### 단위 테스트

#### 서비스 레이어 테스트
```go
package services_test

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
    
    "github.com/aicli/aicli-web/internal/models"
    "github.com/aicli/aicli-web/internal/services"
    "github.com/aicli/aicli-web/internal/storage/mocks"
)

func TestUserService_CreateUser(t *testing.T) {
    // Given
    mockStorage := &mocks.Storage{}
    userService := services.NewUserService(mockStorage)
    
    ctx := context.Background()
    newUser := &models.User{
        Email: "test@example.com",
        Name:  "테스트 사용자",
    }
    
    expectedUser := &models.User{
        ID:    "user-123",
        Email: "test@example.com",
        Name:  "테스트 사용자",
    }
    
    // Mock 설정
    mockStorage.On("CreateUser", ctx, mock.AnythingOfType("*models.User")).
        Return(expectedUser, nil)
    
    // When
    result, err := userService.CreateUser(ctx, newUser)
    
    // Then
    require.NoError(t, err)
    assert.Equal(t, expectedUser.ID, result.ID)
    assert.Equal(t, expectedUser.Email, result.Email)
    assert.Equal(t, expectedUser.Name, result.Name)
    
    mockStorage.AssertExpectations(t)
}

func TestUserService_GetUserByEmail(t *testing.T) {
    tests := []struct {
        name          string
        email         string
        mockUser      *models.User
        mockError     error
        expectedUser  *models.User
        expectedError string
    }{
        {
            name:  "성공적인 사용자 조회",
            email: "test@example.com",
            mockUser: &models.User{
                ID:    "user-123",
                Email: "test@example.com",
                Name:  "테스트 사용자",
            },
            mockError:    nil,
            expectedUser: &models.User{
                ID:    "user-123",
                Email: "test@example.com",
                Name:  "테스트 사용자",
            },
            expectedError: "",
        },
        {
            name:          "존재하지 않는 사용자",
            email:         "notfound@example.com",
            mockUser:      nil,
            mockError:     storage.ErrUserNotFound,
            expectedUser:  nil,
            expectedError: "user not found",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Given
            mockStorage := &mocks.Storage{}
            userService := services.NewUserService(mockStorage)
            
            ctx := context.Background()
            
            mockStorage.On("GetUserByEmail", ctx, tt.email).
                Return(tt.mockUser, tt.mockError)
            
            // When
            result, err := userService.GetUserByEmail(ctx, tt.email)
            
            // Then
            if tt.expectedError != "" {
                require.Error(t, err)
                assert.Contains(t, err.Error(), tt.expectedError)
                assert.Nil(t, result)
            } else {
                require.NoError(t, err)
                assert.Equal(t, tt.expectedUser, result)
            }
            
            mockStorage.AssertExpectations(t)
        })
    }
}
```

### 통합 테스트

#### API 엔드포인트 테스트
```go
package integration_test

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/suite"
    
    "github.com/aicli/aicli-web/internal/api"
    "github.com/aicli/aicli-web/internal/config"
    "github.com/aicli/aicli-web/internal/storage/memory"
)

type APITestSuite struct {
    suite.Suite
    router      *gin.Engine
    storage     storage.Storage
    accessToken string
}

func (suite *APITestSuite) SetupSuite() {
    gin.SetMode(gin.TestMode)
    
    // 테스트용 설정
    cfg := &config.Config{
        Database: config.DatabaseConfig{
            Driver: "memory",
        },
        JWT: config.JWTConfig{
            Secret: "test-secret",
        },
    }
    
    // 메모리 스토리지 사용
    suite.storage = memory.NewMemoryStorage()
    
    // 라우터 설정
    suite.router = api.SetupRouter(cfg, suite.storage)
    
    // 테스트용 사용자 생성 및 토큰 획득
    suite.setupTestUser()
}

func (suite *APITestSuite) setupTestUser() {
    // 테스트 사용자 생성
    user := &models.User{
        Email: "test@example.com",
        Name:  "테스트 사용자",
    }
    
    createdUser, err := suite.storage.CreateUser(context.Background(), user)
    require.NoError(suite.T(), err)
    
    // 로그인하여 토큰 획득
    loginReq := map[string]string{
        "email":    "test@example.com",
        "password": "password123",
    }
    
    body, _ := json.Marshal(loginReq)
    req := httptest.NewRequest("POST", "/api/v1/auth/login", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    suite.router.ServeHTTP(w, req)
    
    require.Equal(suite.T(), http.StatusOK, w.Code)
    
    var loginResp map[string]interface{}
    err = json.Unmarshal(w.Body.Bytes(), &loginResp)
    require.NoError(suite.T(), err)
    
    tokens := loginResp["tokens"].(map[string]interface{})
    suite.accessToken = tokens["access_token"].(string)
}

func (suite *APITestSuite) TestGetCurrentUser() {
    // Given
    req := httptest.NewRequest("GET", "/api/v1/users/me", nil)
    req.Header.Set("Authorization", "Bearer "+suite.accessToken)
    
    // When
    w := httptest.NewRecorder()
    suite.router.ServeHTTP(w, req)
    
    // Then
    assert.Equal(suite.T(), http.StatusOK, w.Code)
    
    var user models.User
    err := json.Unmarshal(w.Body.Bytes(), &user)
    require.NoError(suite.T(), err)
    
    assert.Equal(suite.T(), "test@example.com", user.Email)
    assert.Equal(suite.T(), "테스트 사용자", user.Name)
}

func (suite *APITestSuite) TestCreateProject() {
    // Given
    projectReq := map[string]string{
        "name":        "테스트 프로젝트",
        "description": "테스트용 프로젝트입니다",
    }
    
    body, _ := json.Marshal(projectReq)
    req := httptest.NewRequest("POST", "/api/v1/projects", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+suite.accessToken)
    
    // When
    w := httptest.NewRecorder()
    suite.router.ServeHTTP(w, req)
    
    // Then
    assert.Equal(suite.T(), http.StatusCreated, w.Code)
    
    var project models.Project
    err := json.Unmarshal(w.Body.Bytes(), &project)
    require.NoError(suite.T(), err)
    
    assert.Equal(suite.T(), "테스트 프로젝트", project.Name)
    assert.Equal(suite.T(), "테스트용 프로젝트입니다", project.Description)
    assert.NotEmpty(suite.T(), project.ID)
}

func (suite *APITestSuite) TestUnauthorizedAccess() {
    // Given
    req := httptest.NewRequest("GET", "/api/v1/users/me", nil)
    // Authorization 헤더 없음
    
    // When
    w := httptest.NewRecorder()
    suite.router.ServeHTTP(w, req)
    
    // Then
    assert.Equal(suite.T(), http.StatusUnauthorized, w.Code)
    
    var response map[string]interface{}
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(suite.T(), err)
    
    assert.Contains(suite.T(), response["error"], "Authorization")
}

func TestAPITestSuite(t *testing.T) {
    suite.Run(t, new(APITestSuite))
}
```

### E2E 테스트

#### Postman/Newman 컬렉션
```json
{
  "info": {
    "name": "AICode Manager API Tests",
    "description": "E2E API 테스트 컬렉션",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "variable": [
    {
      "key": "baseUrl",
      "value": "http://localhost:8080"
    },
    {
      "key": "accessToken",
      "value": ""
    }
  ],
  "item": [
    {
      "name": "Authentication",
      "item": [
        {
          "name": "Login",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('로그인 성공', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test('토큰 반환됨', function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property('tokens');",
                  "    pm.expect(jsonData.tokens).to.have.property('access_token');",
                  "    ",
                  "    // 환경 변수에 토큰 저장",
                  "    pm.collectionVariables.set('accessToken', jsonData.tokens.access_token);",
                  "});",
                  "",
                  "pm.test('사용자 정보 반환됨', function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property('user');",
                  "    pm.expect(jsonData.user).to.have.property('email');",
                  "    pm.expect(jsonData.user).to.have.property('name');",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"test@example.com\",\n  \"password\": \"password123\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/api/v1/auth/login",
              "host": ["{{baseUrl}}"],
              "path": ["api", "v1", "auth", "login"]
            }
          }
        }
      ]
    },
    {
      "name": "Users",
      "item": [
        {
          "name": "Get Current User",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('사용자 정보 조회 성공', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test('사용자 정보 형식 확인', function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property('id');",
                  "    pm.expect(jsonData).to.have.property('email');",
                  "    pm.expect(jsonData).to.have.property('name');",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{accessToken}}"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/api/v1/users/me",
              "host": ["{{baseUrl}}"],
              "path": ["api", "v1", "users", "me"]
            }
          }
        }
      ]
    }
  ]
}
```

#### 테스트 실행 스크립트
```bash
#!/bin/bash
# e2e-test.sh

# 서버 시작
echo "서버 시작 중..."
make dev &
SERVER_PID=$!

# 서버가 준비될 때까지 대기
echo "서버 준비 대기 중..."
while ! curl -f http://localhost:8080/health > /dev/null 2>&1; do
    sleep 1
done

echo "E2E 테스트 실행 중..."

# Newman으로 Postman 컬렉션 실행
newman run tests/postman/aicli-api-tests.json \
    --environment tests/postman/environments/local.json \
    --reporters cli,json \
    --reporter-json-export test-results.json

TEST_RESULT=$?

# 서버 종료
echo "서버 종료 중..."
kill $SERVER_PID

# 결과 출력
if [ $TEST_RESULT -eq 0 ]; then
    echo "✅ 모든 E2E 테스트 통과"
else
    echo "❌ E2E 테스트 실패"
fi

exit $TEST_RESULT
```

---

## 🐛 디버깅

### 로깅 및 디버깅 설정

#### 구조화된 로깅
```go
package logger

import (
    "context"
    "os"
    
    "github.com/sirupsen/logrus"
)

type Logger struct {
    *logrus.Logger
}

type Fields map[string]interface{}

func NewLogger(level string, format string) *Logger {
    log := logrus.New()
    
    // 로그 레벨 설정
    lvl, err := logrus.ParseLevel(level)
    if err != nil {
        log.SetLevel(logrus.InfoLevel)
    } else {
        log.SetLevel(lvl)
    }
    
    // 포맷 설정
    if format == "json" {
        log.SetFormatter(&logrus.JSONFormatter{
            TimestampFormat: "2006-01-02T15:04:05.000Z07:00",
        })
    } else {
        log.SetFormatter(&logrus.TextFormatter{
            FullTimestamp:   true,
            TimestampFormat: "2006-01-02 15:04:05",
        })
    }
    
    log.SetOutput(os.Stdout)
    
    return &Logger{log}
}

func (l *Logger) WithFields(fields Fields) *logrus.Entry {
    return l.Logger.WithFields(logrus.Fields(fields))
}

func (l *Logger) WithContext(ctx context.Context) *logrus.Entry {
    entry := l.Logger.WithContext(ctx)
    
    // 컨텍스트에서 추가 정보 추출
    if userID, ok := ctx.Value("user_id").(string); ok {
        entry = entry.WithField("user_id", userID)
    }
    
    if requestID, ok := ctx.Value("request_id").(string); ok {
        entry = entry.WithField("request_id", requestID)
    }
    
    return entry
}

// 사용 예제
func (s *UserService) CreateUser(ctx context.Context, user *models.User) (*models.User, error) {
    logger := s.logger.WithContext(ctx).WithFields(Fields{
        "operation": "CreateUser",
        "email":     user.Email,
    })
    
    logger.Info("사용자 생성 시작")
    
    // 비즈니스 로직
    createdUser, err := s.storage.CreateUser(ctx, user)
    if err != nil {
        logger.WithError(err).Error("사용자 생성 실패")
        return nil, err
    }
    
    logger.WithField("user_id", createdUser.ID).Info("사용자 생성 완료")
    return createdUser, nil
}
```

#### 디버깅 미들웨어
```go
package middleware

import (
    "bytes"
    "io"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
)

type responseWriter struct {
    gin.ResponseWriter
    body *bytes.Buffer
}

func (w *responseWriter) Write(b []byte) (int, error) {
    w.body.Write(b)
    return w.ResponseWriter.Write(b)
}

func DebugMiddleware(logger Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        if gin.Mode() != gin.DebugMode {
            c.Next()
            return
        }
        
        start := time.Now()
        requestID := uuid.New().String()
        
        // Request ID 설정
        c.Set("request_id", requestID)
        c.Header("X-Request-ID", requestID)
        
        // 요청 본문 캡처
        var requestBody []byte
        if c.Request.Body != nil {
            requestBody, _ = io.ReadAll(c.Request.Body)
            c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
        }
        
        // 응답 본문 캡처
        responseWriter := &responseWriter{
            ResponseWriter: c.Writer,
            body:          bytes.NewBuffer([]byte{}),
        }
        c.Writer = responseWriter
        
        // 요청 로깅
        logger.WithFields(Fields{
            "request_id":     requestID,
            "method":         c.Request.Method,
            "path":           c.Request.URL.Path,
            "query":          c.Request.URL.RawQuery,
            "user_agent":     c.Request.UserAgent(),
            "remote_addr":    c.ClientIP(),
            "request_body":   string(requestBody),
            "request_headers": c.Request.Header,
        }).Debug("요청 시작")
        
        c.Next()
        
        // 응답 로깅
        duration := time.Since(start)
        
        logEntry := logger.WithFields(Fields{
            "request_id":      requestID,
            "method":          c.Request.Method,
            "path":            c.Request.URL.Path,
            "status":          c.Writer.Status(),
            "duration_ms":     duration.Milliseconds(),
            "response_body":   responseWriter.body.String(),
            "response_headers": c.Writer.Header(),
        })
        
        if c.Writer.Status() >= 400 {
            logEntry.Error("요청 완료 (에러)")
        } else {
            logEntry.Debug("요청 완료")
        }
    }
}
```

### 성능 프로파일링

#### pprof 설정
```go
package main

import (
    _ "net/http/pprof"
    "net/http"
    
    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    
    // 개발 환경에서만 pprof 활성화
    if gin.Mode() == gin.DebugMode {
        // pprof 엔드포인트
        r.GET("/debug/pprof/", gin.WrapH(http.DefaultServeMux))
        r.GET("/debug/pprof/cmdline", gin.WrapH(http.DefaultServeMux))
        r.GET("/debug/pprof/profile", gin.WrapH(http.DefaultServeMux))
        r.GET("/debug/pprof/symbol", gin.WrapH(http.DefaultServeMux))
        r.GET("/debug/pprof/trace", gin.WrapH(http.DefaultServeMux))
    }
    
    // 일반 라우트 설정
    setupRoutes(r)
    
    r.Run(":8080")
}
```

#### 프로파일링 명령어
```bash
# CPU 프로파일링 (30초)
go tool pprof http://localhost:8080/debug/pprof/profile?seconds=30

# 메모리 프로파일링
go tool pprof http://localhost:8080/debug/pprof/heap

# 고루틴 프로파일링
go tool pprof http://localhost:8080/debug/pprof/goroutine

# 웹 인터페이스로 분석
go tool pprof -http=:8081 http://localhost:8080/debug/pprof/profile?seconds=30
```

### 에러 추적

#### Sentry 통합
```go
package errors

import (
    "context"
    "fmt"
    
    "github.com/getsentry/sentry-go"
    sentrygin "github.com/getsentry/sentry-go/gin"
    "github.com/gin-gonic/gin"
)

func InitSentry(dsn string, environment string) error {
    return sentry.Init(sentry.ClientOptions{
        Dsn:         dsn,
        Environment: environment,
        BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event {
            // 민감한 정보 필터링
            if event.Request != nil {
                // Authorization 헤더 제거
                if event.Request.Headers != nil {
                    delete(event.Request.Headers, "Authorization")
                }
            }
            return event
        },
    })
}

func SentryMiddleware() gin.HandlerFunc {
    return sentrygin.New(sentrygin.Options{
        Repanic: true,
    })
}

// 커스텀 에러 리포팅
func ReportError(ctx context.Context, err error, extra map[string]interface{}) {
    hub := sentry.GetHubFromContext(ctx)
    if hub == nil {
        hub = sentry.CurrentHub()
    }
    
    // 사용자 컨텍스트 설정
    if userID, ok := ctx.Value("user_id").(string); ok {
        hub.ConfigureScope(func(scope *sentry.Scope) {
            scope.SetUser(sentry.User{
                ID: userID,
            })
        })
    }
    
    // 추가 정보 설정
    hub.ConfigureScope(func(scope *sentry.Scope) {
        for key, value := range extra {
            scope.SetExtra(key, value)
        }
    })
    
    hub.CaptureException(err)
}

// 사용 예제
func (s *UserService) CreateUser(ctx context.Context, user *models.User) (*models.User, error) {
    createdUser, err := s.storage.CreateUser(ctx, user)
    if err != nil {
        ReportError(ctx, err, map[string]interface{}{
            "operation": "CreateUser",
            "email":     user.Email,
        })
        return nil, fmt.Errorf("사용자 생성 실패: %w", err)
    }
    
    return createdUser, nil
}
```

---

## ✨ 베스트 프랙티스

### 코딩 규칙

#### 1. 네이밍 컨벤션
```go
// 패키지명: 소문자, 짧고 명확하게
package auth

// 구조체명: PascalCase
type UserService struct {
    storage Storage
    logger  Logger
}

// 인터페이스명: PascalCase, 행동을 나타내는 -er 접미사
type UserRepository interface {
    CreateUser(ctx context.Context, user *User) (*User, error)
    GetUserByID(ctx context.Context, id string) (*User, error)
}

// 함수명: PascalCase (public), camelCase (private)
func (s *UserService) CreateUser(ctx context.Context, user *User) (*User, error) {
    return s.createUserInternal(ctx, user)
}

func (s *UserService) createUserInternal(ctx context.Context, user *User) (*User, error) {
    // 내부 구현
}

// 상수: SCREAMING_SNAKE_CASE
const (
    DEFAULT_PAGE_SIZE = 20
    MAX_PAGE_SIZE     = 100
    JWT_ISSUER       = "aicli-web"
)

// 변수: camelCase
var (
    defaultConfig = &Config{}
    errUserNotFound = errors.New("user not found")
)
```

#### 2. 에러 처리
```go
// 커스텀 에러 타입 정의
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}

// 에러 래핑 사용
func (s *UserService) CreateUser(ctx context.Context, user *User) (*User, error) {
    if err := s.validateUser(user); err != nil {
        return nil, fmt.Errorf("user validation failed: %w", err)
    }
    
    createdUser, err := s.storage.CreateUser(ctx, user)
    if err != nil {
        return nil, fmt.Errorf("failed to create user in storage: %w", err)
    }
    
    return createdUser, nil
}

// 에러 검사 및 처리
func (h *UserHandler) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        h.logger.WithError(err).Error("Invalid request body")
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
        return
    }
    
    user, err := h.userService.CreateUser(c.Request.Context(), &req.User)
    if err != nil {
        var validationErr *ValidationError
        if errors.As(err, &validationErr) {
            c.JSON(http.StatusBadRequest, gin.H{"error": validationErr.Error()})
            return
        }
        
        h.logger.WithError(err).Error("Failed to create user")
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
        return
    }
    
    c.JSON(http.StatusCreated, user)
}
```

#### 3. 컨텍스트 사용
```go
// 컨텍스트에 값 저장/조회를 위한 키 타입
type contextKey string

const (
    userIDKey    contextKey = "user_id"
    requestIDKey contextKey = "request_id"
)

// 컨텍스트 헬퍼 함수
func WithUserID(ctx context.Context, userID string) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

func GetUserID(ctx context.Context) (string, bool) {
    userID, ok := ctx.Value(userIDKey).(string)
    return userID, ok
}

// 타임아웃 설정
func (s *UserService) CreateUser(ctx context.Context, user *User) (*User, error) {
    // 최대 5초 타임아웃
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    return s.storage.CreateUser(ctx, user)
}

// 컨텍스트 전파
func (h *UserHandler) CreateUser(c *gin.Context) {
    ctx := c.Request.Context()
    
    // 사용자 ID 추가
    if userID, exists := c.Get("user_id"); exists {
        ctx = WithUserID(ctx, userID.(string))
    }
    
    user, err := h.userService.CreateUser(ctx, &req.User)
    // ...
}
```

### 성능 최적화

#### 1. 데이터베이스 최적화
```go
// 연결 풀 설정
func setupDatabase(cfg *DatabaseConfig) (*sql.DB, error) {
    db, err := sql.Open(cfg.Driver, cfg.ConnectionString)
    if err != nil {
        return nil, err
    }
    
    // 연결 풀 설정
    db.SetMaxOpenConns(cfg.MaxOpenConns)     // 최대 연결 수
    db.SetMaxIdleConns(cfg.MaxIdleConns)     // 최대 유휴 연결 수
    db.SetConnMaxLifetime(cfg.ConnMaxLifetime) // 연결 최대 수명
    
    return db, nil
}

// 배치 처리
func (r *PostgresRepository) CreateUsers(ctx context.Context, users []*User) error {
    query := `
        INSERT INTO users (id, email, name, created_at) 
        VALUES ($1, $2, $3, $4)`
    
    tx, err := r.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    stmt, err := tx.PrepareContext(ctx, query)
    if err != nil {
        return err
    }
    defer stmt.Close()
    
    for _, user := range users {
        _, err = stmt.ExecContext(ctx, user.ID, user.Email, user.Name, time.Now())
        if err != nil {
            return err
        }
    }
    
    return tx.Commit()
}

// 인덱스 활용을 위한 쿼리 최적화
func (r *PostgresRepository) GetUsersByRole(ctx context.Context, role string, limit, offset int) ([]*User, error) {
    query := `
        SELECT u.id, u.email, u.name, u.created_at
        FROM users u
        JOIN user_roles ur ON u.id = ur.user_id
        JOIN roles r ON ur.role_id = r.id
        WHERE r.name = $1
        ORDER BY u.created_at DESC
        LIMIT $2 OFFSET $3`
    
    rows, err := r.db.QueryContext(ctx, query, role, limit, offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []*User
    for rows.Next() {
        user := &User{}
        err := rows.Scan(&user.ID, &user.Email, &user.Name, &user.CreatedAt)
        if err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    
    return users, rows.Err()
}
```

#### 2. 캐싱 전략
```go
package cache

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/go-redis/redis/v8"
)

type RedisCache struct {
    client *redis.Client
}

func NewRedisCache(addr, password string, db int) *RedisCache {
    client := redis.NewClient(&redis.Options{
        Addr:     addr,
        Password: password,
        DB:       db,
    })
    
    return &RedisCache{client: client}
}

// 제네릭 캐시 메소드
func (c *RedisCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    
    return c.client.Set(ctx, key, data, expiration).Err()
}

func (c *RedisCache) Get(ctx context.Context, key string, dest interface{}) error {
    data, err := c.client.Get(ctx, key).Bytes()
    if err != nil {
        return err
    }
    
    return json.Unmarshal(data, dest)
}

// 캐시를 활용한 서비스 구현
type CachedUserService struct {
    userService UserService
    cache       *RedisCache
}

func (s *CachedUserService) GetUserByID(ctx context.Context, id string) (*User, error) {
    cacheKey := fmt.Sprintf("user:%s", id)
    
    // 캐시에서 조회
    var user User
    err := s.cache.Get(ctx, cacheKey, &user)
    if err == nil {
        return &user, nil
    }
    
    // 캐시 미스, 원본 서비스에서 조회
    user, err = s.userService.GetUserByID(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // 캐시에 저장 (5분)
    s.cache.Set(ctx, cacheKey, user, 5*time.Minute)
    
    return user, nil
}

// Write-through 캐시
func (s *CachedUserService) UpdateUser(ctx context.Context, id string, updates *UserUpdates) (*User, error) {
    // 원본 업데이트
    user, err := s.userService.UpdateUser(ctx, id, updates)
    if err != nil {
        return nil, err
    }
    
    // 캐시 업데이트
    cacheKey := fmt.Sprintf("user:%s", id)
    s.cache.Set(ctx, cacheKey, user, 5*time.Minute)
    
    return user, nil
}
```

### 보안 모범 사례

#### 1. 입력 검증
```go
package validator

import (
    "regexp"
    "strings"
    "unicode"
)

type UserValidator struct{}

func (v *UserValidator) ValidateEmail(email string) error {
    if email == "" {
        return &ValidationError{Field: "email", Message: "이메일은 필수입니다"}
    }
    
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(email) {
        return &ValidationError{Field: "email", Message: "유효한 이메일 형식이 아닙니다"}
    }
    
    return nil
}

func (v *UserValidator) ValidatePassword(password string) error {
    if len(password) < 8 {
        return &ValidationError{Field: "password", Message: "비밀번호는 최소 8자 이상이어야 합니다"}
    }
    
    if len(password) > 128 {
        return &ValidationError{Field: "password", Message: "비밀번호는 최대 128자까지 허용됩니다"}
    }
    
    var (
        hasUpper   = false
        hasLower   = false
        hasNumber  = false
        hasSpecial = false
    )
    
    for _, char := range password {
        switch {
        case unicode.IsUpper(char):
            hasUpper = true
        case unicode.IsLower(char):
            hasLower = true
        case unicode.IsNumber(char):
            hasNumber = true
        case unicode.IsPunct(char) || unicode.IsSymbol(char):
            hasSpecial = true
        }
    }
    
    if !hasUpper || !hasLower || !hasNumber || !hasSpecial {
        return &ValidationError{
            Field:   "password",
            Message: "비밀번호는 대문자, 소문자, 숫자, 특수문자를 각각 최소 1개씩 포함해야 합니다",
        }
    }
    
    return nil
}

// SQL Injection 방지
func (v *UserValidator) ValidateSearchQuery(query string) error {
    // SQL 키워드 필터링
    sqlKeywords := []string{
        "SELECT", "INSERT", "UPDATE", "DELETE", "DROP", "CREATE", "ALTER",
        "UNION", "OR", "AND", "WHERE", "EXEC", "EXECUTE",
    }
    
    upperQuery := strings.ToUpper(query)
    for _, keyword := range sqlKeywords {
        if strings.Contains(upperQuery, keyword) {
            return &ValidationError{
                Field:   "query",
                Message: "검색어에 허용되지 않는 문자가 포함되어 있습니다",
            }
        }
    }
    
    return nil
}

// XSS 방지
func (v *UserValidator) SanitizeHTML(input string) string {
    // HTML 태그 제거
    htmlRegex := regexp.MustCompile(`<[^>]*>`)
    cleaned := htmlRegex.ReplaceAllString(input, "")
    
    // 스크립트 관련 문자열 제거
    scriptRegex := regexp.MustCompile(`(?i)(javascript|vbscript|onload|onerror|onclick)`)
    cleaned = scriptRegex.ReplaceAllString(cleaned, "")
    
    return cleaned
}
```

#### 2. Rate Limiting
```go
package ratelimit

import (
    "context"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
    "golang.org/x/time/rate"
)

type RateLimiter struct {
    redis  *redis.Client
    window time.Duration
    limit  int
}

func NewRateLimiter(redis *redis.Client, window time.Duration, limit int) *RateLimiter {
    return &RateLimiter{
        redis:  redis,
        window: window,
        limit:  limit,
    }
}

func (rl *RateLimiter) Allow(ctx context.Context, key string) (bool, error) {
    now := time.Now().Unix()
    window := int64(rl.window.Seconds())
    windowStart := now - window
    
    pipe := rl.redis.Pipeline()
    
    // 현재 윈도우의 요청 수 확인
    countCmd := pipe.ZCount(ctx, key, fmt.Sprintf("%d", windowStart), fmt.Sprintf("%d", now))
    
    // 현재 요청 추가
    pipe.ZAdd(ctx, key, &redis.Z{Score: float64(now), Member: now})
    
    // 오래된 요청 제거
    pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart))
    
    // TTL 설정
    pipe.Expire(ctx, key, rl.window)
    
    _, err := pipe.Exec(ctx)
    if err != nil {
        return false, err
    }
    
    count := countCmd.Val()
    return count < int64(rl.limit), nil
}

// 미들웨어로 사용
func RateLimitMiddleware(limiter *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        key := fmt.Sprintf("rate_limit:%s", c.ClientIP())
        
        allowed, err := limiter.Allow(c.Request.Context(), key)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Rate limit check failed"})
            c.Abort()
            return
        }
        
        if !allowed {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Rate limit exceeded",
                "retry_after": int(limiter.window.Seconds()),
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

---

## ❓ FAQ

### Q1: API 호출 시 401 Unauthorized 에러가 발생합니다.

**A1**: 다음 사항들을 확인해보세요:

1. **토큰 형식 확인**:
   ```bash
   # 올바른 형식
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   
   # 잘못된 형식
   Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...  # Bearer 누락
   ```

2. **토큰 만료 확인**:
   ```javascript
   // JWT 토큰 디코딩하여 만료 시간 확인
   const payload = JSON.parse(atob(token.split('.')[1]));
   const isExpired = payload.exp * 1000 < Date.now();
   ```

3. **토큰 갱신**:
   ```bash
   curl -X POST "http://localhost:8080/api/v1/auth/refresh" \
     -H "Content-Type: application/json" \
     -d '{"refresh_token": "YOUR_REFRESH_TOKEN"}'
   ```

### Q2: CORS 에러가 발생합니다.

**A2**: 서버에서 CORS 설정을 확인하세요:

```go
// CORS 미들웨어 설정
func CORSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "http://localhost:3000")
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Authorization, Content-Type")
        c.Header("Access-Control-Allow-Credentials", "true")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}
```

### Q3: WebSocket 연결이 자주 끊어집니다.

**A3**: 다음과 같은 방법으로 해결할 수 있습니다:

1. **Ping/Pong 구현**:
   ```javascript
   setInterval(() => {
       if (ws.readyState === WebSocket.OPEN) {
           ws.send(JSON.stringify({ type: 'ping' }));
       }
   }, 30000); // 30초마다 ping 전송
   ```

2. **재연결 로직**:
   ```javascript
   ws.onclose = function(event) {
       console.log('WebSocket 연결 종료:', event.code);
       setTimeout(() => {
           console.log('재연결 시도...');
           connect();
       }, 5000);
   };
   ```

### Q4: 데이터베이스 연결 에러가 발생합니다.

**A4**: 연결 설정을 확인해보세요:

1. **연결 문자열 확인**:
   ```yaml
   database:
     host: "localhost"
     port: 5432
     name: "aicli_web"
     user: "aicli_user"
     password: "your_password"
     ssl_mode: "disable"  # 개발 환경에서는 disable
   ```

2. **연결 테스트**:
   ```bash
   psql -h localhost -U aicli_user -d aicli_web -c "SELECT 1;"
   ```

### Q5: Rate Limiting에 자주 걸립니다.

**A5**: Rate Limit 설정을 조정하거나 요청을 최적화하세요:

1. **설정 조정**:
   ```yaml
   security:
     rate_limit:
       requests_per_second: 200  # 증가
       burst_size: 400          # 증가
   ```

2. **요청 최적화**:
   ```javascript
   // 불필요한 중복 요청 방지
   const debounce = (func, wait) => {
       let timeout;
       return function executedFunction(...args) {
           const later = () => {
               clearTimeout(timeout);
               func(...args);
           };
           clearTimeout(timeout);
           timeout = setTimeout(later, wait);
       };
   };
   ```

### Q6: 성능이 느립니다.

**A6**: 다음과 같은 최적화를 시도해보세요:

1. **데이터베이스 인덱스 확인**:
   ```sql
   EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';
   ```

2. **캐싱 구현**:
   ```go
   // 자주 조회되는 데이터 캐싱
   func (s *UserService) GetUserByID(ctx context.Context, id string) (*User, error) {
       if user := s.cache.Get("user:" + id); user != nil {
           return user, nil
       }
       
       user, err := s.storage.GetUserByID(ctx, id)
       if err == nil {
           s.cache.Set("user:"+id, user, 5*time.Minute)
       }
       
       return user, err
   }
   ```

3. **연결 풀 튜닝**:
   ```go
   db.SetMaxOpenConns(25)
   db.SetMaxIdleConns(5)
   db.SetConnMaxLifetime(5 * time.Minute)
   ```

### Q7: 메모리 사용량이 계속 증가합니다.

**A7**: 메모리 누수를 확인하고 최적화하세요:

1. **pprof로 메모리 분석**:
   ```bash
   go tool pprof http://localhost:8080/debug/pprof/heap
   ```

2. **고루틴 누수 확인**:
   ```bash
   go tool pprof http://localhost:8080/debug/pprof/goroutine
   ```

3. **리소스 해제 확인**:
   ```go
   // 파일, 연결 등 리소스 적절히 해제
   defer file.Close()
   defer rows.Close()
   defer resp.Body.Close()
   ```

---

*이 가이드는 지속적으로 업데이트됩니다. 추가 질문이나 개선 사항이 있으면 GitHub Issues를 통해 알려주세요.*