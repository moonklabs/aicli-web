# AICode Manager ê°œë°œì í†µí•© ê°€ì´ë“œ

## ğŸ“– ëª©ì°¨

1. [ê°œë°œ í™˜ê²½ ì„¤ì •](#ê°œë°œ-í™˜ê²½-ì„¤ì •)
2. [í”„ë¡œì íŠ¸ êµ¬ì¡°](#í”„ë¡œì íŠ¸-êµ¬ì¡°)
3. [API í†µí•©](#api-í†µí•©)
4. [ì¸ì¦ ì‹œìŠ¤í…œ ì—°ë™](#ì¸ì¦-ì‹œìŠ¤í…œ-ì—°ë™)
5. [SDK ë° ë¼ì´ë¸ŒëŸ¬ë¦¬](#sdk-ë°-ë¼ì´ë¸ŒëŸ¬ë¦¬)
6. [ì½”ë“œ ì˜ˆì œ](#ì½”ë“œ-ì˜ˆì œ)
7. [í…ŒìŠ¤íŒ…](#í…ŒìŠ¤íŒ…)
8. [ë””ë²„ê¹…](#ë””ë²„ê¹…)
9. [ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤](#ë² ìŠ¤íŠ¸-í”„ë™í‹°ìŠ¤)
10. [FAQ](#faq)

---

## ğŸ”§ ê°œë°œ í™˜ê²½ ì„¤ì •

### í•„ìˆ˜ ìš”êµ¬ì‚¬í•­

#### ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­
- **Go**: 1.21+ (ê¶Œì¥: 1.24+)
- **Node.js**: 18+ (í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ ì‹œ)
- **PostgreSQL**: 13+
- **Redis**: 6+
- **Git**: 2.30+

#### ê°œë°œ ë„êµ¬
- **IDE**: VSCode / GoLand / Vim
- **API ë„êµ¬**: Postman / Insomnia / cURL
- **DB ë„êµ¬**: pgAdmin / DBeaver
- **í„°ë¯¸ë„**: zsh / bash

### í”„ë¡œì íŠ¸ ì„¤ì •

#### 1. ì €ì¥ì†Œ í´ë¡ 
```bash
git clone https://github.com/aicli/aicli-web.git
cd aicli-web
```

#### 2. ì˜ì¡´ì„± ì„¤ì¹˜
```bash
# Go ëª¨ë“ˆ ì˜ì¡´ì„±
go mod download

# ê°œë°œ ë„êµ¬ ì„¤ì¹˜
go install github.com/swaggo/swag/cmd/swag@latest
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
go install github.com/golang/mock/mockgen@latest
```

#### 3. ê°œë°œ í™˜ê²½ ì„¤ì •
```bash
# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
cp .env.example .env.development
# .env.development íŒŒì¼ í¸ì§‘

# ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
make db-setup-dev

# ê°œë°œ ì„œë²„ ì‹¤í–‰
make dev
```

#### 4. VSCode ì„¤ì •
```json
// .vscode/settings.json
{
  "go.toolsManagement.checkForUpdates": "local",
  "go.useLanguageServer": true,
  "go.lintTool": "golangci-lint",
  "go.lintFlags": [
    "--fast"
  ],
  "go.testFlags": [
    "-v",
    "-race"
  ],
  "go.testTimeout": "30s",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": true
  }
}
```

---

## ğŸ—ï¸ í”„ë¡œì íŠ¸ êµ¬ì¡°

### ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„¸

```
aicli-web/
â”œâ”€â”€ cmd/                           # ì• í”Œë¦¬ì¼€ì´ì…˜ ì—”íŠ¸ë¦¬í¬ì¸íŠ¸
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ main.go               # API ì„œë²„ ë©”ì¸ í•¨ìˆ˜
â”œâ”€â”€ internal/                     # ë‚´ë¶€ íŒ¨í‚¤ì§€ (ì™¸ë¶€ ë…¸ì¶œ ì•ˆë¨)
â”‚   â”œâ”€â”€ auth/                     # ì¸ì¦ ì‹œìŠ¤í…œ
â”‚   â”‚   â”œâ”€â”€ jwt.go               # JWT ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ oauth.go             # OAuth í†µí•©
â”‚   â”‚   â”œâ”€â”€ rbac.go              # ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
â”‚   â”‚   â””â”€â”€ session.go           # ì„¸ì…˜ ê´€ë¦¬
â”‚   â”œâ”€â”€ middleware/               # HTTP ë¯¸ë“¤ì›¨ì–´
â”‚   â”‚   â”œâ”€â”€ auth.go              # ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
â”‚   â”‚   â”œâ”€â”€ cors.go              # CORS ì²˜ë¦¬
â”‚   â”‚   â”œâ”€â”€ ratelimit.go         # Rate Limiting
â”‚   â”‚   â””â”€â”€ security.go          # ë³´ì•ˆ í—¤ë”
â”‚   â”œâ”€â”€ services/                 # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ user.go              # ì‚¬ìš©ì ì„œë¹„ìŠ¤
â”‚   â”‚   â”œâ”€â”€ project.go           # í”„ë¡œì íŠ¸ ì„œë¹„ìŠ¤
â”‚   â”‚   â””â”€â”€ workspace.go         # ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ì„œë¹„ìŠ¤
â”‚   â”œâ”€â”€ storage/                  # ë°ì´í„° ì €ì¥ì†Œ
â”‚   â”‚   â”œâ”€â”€ interface.go         # ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â”œâ”€â”€ postgres/            # PostgreSQL êµ¬í˜„
â”‚   â”‚   â””â”€â”€ memory/              # ë©”ëª¨ë¦¬ êµ¬í˜„ (í…ŒìŠ¤íŠ¸ìš©)
â”‚   â”œâ”€â”€ api/                      # API í•¸ë“¤ëŸ¬
â”‚   â”‚   â”œâ”€â”€ handlers/            # HTTP í•¸ë“¤ëŸ¬
â”‚   â”‚   â””â”€â”€ websocket/           # WebSocket í•¸ë“¤ëŸ¬
â”‚   â”œâ”€â”€ config/                   # ì„¤ì • ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ config.go            # ì„¤ì • êµ¬ì¡°ì²´
â”‚   â”‚   â””â”€â”€ loader.go            # ì„¤ì • ë¡œë”
â”‚   â””â”€â”€ models/                   # ë°ì´í„° ëª¨ë¸
â”‚       â”œâ”€â”€ user.go              # ì‚¬ìš©ì ëª¨ë¸
â”‚       â”œâ”€â”€ project.go           # í”„ë¡œì íŠ¸ ëª¨ë¸
â”‚       â””â”€â”€ auth.go              # ì¸ì¦ ëª¨ë¸
â”œâ”€â”€ pkg/                          # ì™¸ë¶€ íŒ¨í‚¤ì§€ (ì¬ì‚¬ìš© ê°€ëŠ¥)
â”‚   â”œâ”€â”€ logger/                  # ë¡œê¹… ìœ í‹¸ë¦¬í‹°
â”‚   â”œâ”€â”€ validator/               # ì…ë ¥ ê²€ì¦
â”‚   â””â”€â”€ errors/                  # ì—ëŸ¬ ì²˜ë¦¬
â”œâ”€â”€ test/                         # í…ŒìŠ¤íŠ¸ íŒŒì¼
â”‚   â”œâ”€â”€ integration/             # í†µí•© í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ unit/                    # ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ fixtures/                # í…ŒìŠ¤íŠ¸ ë°ì´í„°
â”œâ”€â”€ docs/                         # ë¬¸ì„œ
â”‚   â”œâ”€â”€ api/                     # API ë¬¸ì„œ
â”‚   â”œâ”€â”€ development/             # ê°œë°œ ê°€ì´ë“œ
â”‚   â””â”€â”€ operations/              # ìš´ì˜ ê°€ì´ë“œ
â”œâ”€â”€ scripts/                      # ìœ í‹¸ë¦¬í‹° ìŠ¤í¬ë¦½íŠ¸
â”‚   â”œâ”€â”€ build.sh                # ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸
â”‚   â”œâ”€â”€ migrate.sh              # ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸
â”‚   â””â”€â”€ test.sh                 # í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ deploy/                       # ë°°í¬ ê´€ë ¨ íŒŒì¼
â”‚   â”œâ”€â”€ docker/                 # Docker íŒŒì¼
â”‚   â”œâ”€â”€ k8s/                    # Kubernetes ë§¤ë‹ˆí˜ìŠ¤íŠ¸
â”‚   â””â”€â”€ nginx/                  # Nginx ì„¤ì •
â”œâ”€â”€ Makefile                      # ë¹Œë“œ ìë™í™”
â”œâ”€â”€ go.mod                        # Go ëª¨ë“ˆ ì •ì˜
â”œâ”€â”€ go.sum                        # ì˜ì¡´ì„± ì²´í¬ì„¬
â””â”€â”€ README.md                     # í”„ë¡œì íŠ¸ ê°œìš”
```

### íŒ¨í‚¤ì§€ ì˜ì¡´ì„± ê·œì¹™

#### Import ê·œì¹™
```go
// ì˜¬ë°”ë¥¸ import ìˆœì„œ
import (
    // 1. í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬
    "context"
    "fmt"
    "net/http"
    
    // 2. ì™¸ë¶€ ì˜ì¡´ì„±
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    
    // 3. ë‚´ë¶€ íŒ¨í‚¤ì§€
    "github.com/aicli/aicli-web/internal/auth"
    "github.com/aicli/aicli-web/internal/models"
    "github.com/aicli/aicli-web/pkg/logger"
)
```

#### ìˆœí™˜ ì˜ì¡´ì„± ë°©ì§€
- `internal/` íŒ¨í‚¤ì§€ëŠ” ì™¸ë¶€ì—ì„œ import ë¶ˆê°€
- `pkg/` íŒ¨í‚¤ì§€ëŠ” `internal/`ì„ import ë¶ˆê°€
- ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•œ ì˜ì¡´ì„± ì—­ì „ ì‚¬ìš©

---

## ğŸ”Œ API í†µí•©

### REST API ê¸°ë³¸ ì‚¬ìš©ë²•

#### 1. ì¸ì¦ í† í° íšë“
```bash
# ì¼ë°˜ ë¡œê·¸ì¸
curl -X POST "http://localhost:8080/api/v1/auth/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "password123"
  }'
```

ì‘ë‹µ:
```json
{
  "user": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "email": "user@example.com",
    "name": "í™ê¸¸ë™"
  },
  "tokens": {
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "token_type": "Bearer",
    "expires_in": 3600
  }
}
```

#### 2. API í˜¸ì¶œ ì‹œ ì¸ì¦ í—¤ë” í¬í•¨
```bash
curl -X GET "http://localhost:8080/api/v1/users/me" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

#### 3. í† í° ê°±ì‹ 
```bash
curl -X POST "http://localhost:8080/api/v1/auth/refresh" \
  -H "Content-Type: application/json" \
  -d '{
    "refresh_token": "YOUR_REFRESH_TOKEN"
  }'
```

### HTTP í´ë¼ì´ì–¸íŠ¸ ì˜ˆì œ

#### Go í´ë¼ì´ì–¸íŠ¸
```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type APIClient struct {
    BaseURL     string
    AccessToken string
    HTTPClient  *http.Client
}

type LoginRequest struct {
    Email    string `json:"email"`
    Password string `json:"password"`
}

type LoginResponse struct {
    User   User   `json:"user"`
    Tokens Tokens `json:"tokens"`
}

type User struct {
    ID    string `json:"id"`
    Email string `json:"email"`
    Name  string `json:"name"`
}

type Tokens struct {
    AccessToken  string `json:"access_token"`
    RefreshToken string `json:"refresh_token"`
    TokenType    string `json:"token_type"`
    ExpiresIn    int    `json:"expires_in"`
}

func NewAPIClient(baseURL string) *APIClient {
    return &APIClient{
        BaseURL:    baseURL,
        HTTPClient: &http.Client{},
    }
}

func (c *APIClient) Login(email, password string) (*LoginResponse, error) {
    loginReq := LoginRequest{
        Email:    email,
        Password: password,
    }
    
    reqBody, err := json.Marshal(loginReq)
    if err != nil {
        return nil, err
    }
    
    resp, err := c.HTTPClient.Post(
        c.BaseURL+"/api/v1/auth/login",
        "application/json",
        bytes.NewBuffer(reqBody),
    )
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var loginResp LoginResponse
    if err := json.NewDecoder(resp.Body).Decode(&loginResp); err != nil {
        return nil, err
    }
    
    // í† í° ì €ì¥
    c.AccessToken = loginResp.Tokens.AccessToken
    
    return &loginResp, nil
}

func (c *APIClient) GetCurrentUser() (*User, error) {
    req, err := http.NewRequest("GET", c.BaseURL+"/api/v1/users/me", nil)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", "Bearer "+c.AccessToken)
    
    resp, err := c.HTTPClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}

// ì‚¬ìš© ì˜ˆì œ
func main() {
    client := NewAPIClient("http://localhost:8080")
    
    // ë¡œê·¸ì¸
    loginResp, err := client.Login("user@example.com", "password123")
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("ë¡œê·¸ì¸ ì„±ê³µ: %s\n", loginResp.User.Name)
    
    // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    user, err := client.GetCurrentUser()
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("í˜„ì¬ ì‚¬ìš©ì: %s (%s)\n", user.Name, user.Email)
}
```

#### JavaScript/TypeScript í´ë¼ì´ì–¸íŠ¸
```typescript
// types.ts
export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  user: User;
  tokens: Tokens;
}

export interface User {
  id: string;
  email: string;
  name: string;
  avatar_url?: string;
  roles: Role[];
}

export interface Tokens {
  access_token: string;
  refresh_token: string;
  token_type: string;
  expires_in: number;
}

export interface Role {
  id: string;
  name: string;
  display_name: string;
}

// api-client.ts
class APIClient {
  private baseURL: string;
  private accessToken: string | null = null;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  async login(email: string, password: string): Promise<LoginResponse> {
    const response = await fetch(`${this.baseURL}/api/v1/auth/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      throw new Error(`ë¡œê·¸ì¸ ì‹¤íŒ¨: ${response.statusText}`);
    }

    const data: LoginResponse = await response.json();
    this.accessToken = data.tokens.access_token;
    
    return data;
  }

  async getCurrentUser(): Promise<User> {
    if (!this.accessToken) {
      throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
    }

    const response = await fetch(`${this.baseURL}/api/v1/users/me`, {
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: ${response.statusText}`);
    }

    return response.json();
  }

  async getProjects(page: number = 1, limit: number = 20): Promise<Project[]> {
    if (!this.accessToken) {
      throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
    }

    const params = new URLSearchParams({
      page: page.toString(),
      limit: limit.toString(),
    });

    const response = await fetch(`${this.baseURL}/api/v1/projects?${params}`, {
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
      },
    });

    if (!response.ok) {
      throw new Error(`í”„ë¡œì íŠ¸ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨: ${response.statusText}`);
    }

    const data = await response.json();
    return data.projects;
  }

  async createProject(name: string, description?: string): Promise<Project> {
    if (!this.accessToken) {
      throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
    }

    const response = await fetch(`${this.baseURL}/api/v1/projects`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.accessToken}`,
      },
      body: JSON.stringify({ name, description }),
    });

    if (!response.ok) {
      throw new Error(`í”„ë¡œì íŠ¸ ìƒì„± ì‹¤íŒ¨: ${response.statusText}`);
    }

    return response.json();
  }
}

// ì‚¬ìš© ì˜ˆì œ
async function example() {
  const client = new APIClient('http://localhost:8080');
  
  try {
    // ë¡œê·¸ì¸
    const loginResponse = await client.login('user@example.com', 'password123');
    console.log('ë¡œê·¸ì¸ ì„±ê³µ:', loginResponse.user.name);
    
    // í˜„ì¬ ì‚¬ìš©ì ì •ë³´
    const user = await client.getCurrentUser();
    console.log('í˜„ì¬ ì‚¬ìš©ì:', user);
    
    // í”„ë¡œì íŠ¸ ëª©ë¡ ì¡°íšŒ
    const projects = await client.getProjects();
    console.log('í”„ë¡œì íŠ¸ ëª©ë¡:', projects);
    
    // ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±
    const newProject = await client.createProject('My New Project', 'ìƒˆë¡œìš´ í”„ë¡œì íŠ¸ì…ë‹ˆë‹¤');
    console.log('ìƒì„±ëœ í”„ë¡œì íŠ¸:', newProject);
  } catch (error) {
    console.error('ì—ëŸ¬:', error);
  }
}
```

---

## ğŸ” ì¸ì¦ ì‹œìŠ¤í…œ ì—°ë™

### JWT í† í° ì²˜ë¦¬

#### í† í° êµ¬ì¡° ì´í•´
```bash
# JWT í† í° ë””ì½”ë”© (í—¤ë”)
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d
# {"alg":"HS256","typ":"JWT"}

# JWT í† í° ë””ì½”ë”© (í˜ì´ë¡œë“œ)
echo "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ" | base64 -d
# {"sub":"1234567890","name":"John Doe","iat":1516239022}
```

#### Goì—ì„œ JWT ê²€ì¦
```go
package main

import (
    "fmt"
    "time"
    
    "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
    UserID   string   `json:"user_id"`
    Email    string   `json:"email"`
    Provider string   `json:"provider"`
    Roles    []string `json:"roles"`
    jwt.RegisteredClaims
}

func validateJWT(tokenString, secret string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // ì•Œê³ ë¦¬ì¦˜ ê²€ì¦
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("ì˜ˆìƒì¹˜ ëª»í•œ ì„œëª… ì•Œê³ ë¦¬ì¦˜: %v", token.Header["alg"])
        }
        return []byte(secret), nil
    })
    
    if err != nil {
        return nil, err
    }
    
    claims, ok := token.Claims.(*Claims)
    if !ok || !token.Valid {
        return nil, fmt.Errorf("ìœ íš¨í•˜ì§€ ì•Šì€ í† í°")
    }
    
    // ë§Œë£Œ ì‹œê°„ í™•ì¸
    if claims.ExpiresAt.Time.Before(time.Now()) {
        return nil, fmt.Errorf("í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
    }
    
    return claims, nil
}

// ë¯¸ë“¤ì›¨ì–´ì—ì„œ ì‚¬ìš©
func AuthMiddleware(secret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization í—¤ë”ê°€ í•„ìš”í•©ë‹ˆë‹¤"})
            c.Abort()
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := validateJWT(tokenString, secret)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
            c.Abort()
            return
        }
        
        // ì»¨í…ìŠ¤íŠ¸ì— ì‚¬ìš©ì ì •ë³´ ì €ì¥
        c.Set("user_id", claims.UserID)
        c.Set("user_email", claims.Email)
        c.Set("user_roles", claims.Roles)
        
        c.Next()
    }
}
```

### OAuth í†µí•©

#### Google OAuth í”Œë¡œìš°
```go
package auth

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/google"
)

type GoogleOAuthConfig struct {
    ClientID     string
    ClientSecret string
    RedirectURL  string
}

type GoogleUserInfo struct {
    ID            string `json:"id"`
    Email         string `json:"email"`
    VerifiedEmail bool   `json:"verified_email"`
    Name          string `json:"name"`
    Picture       string `json:"picture"`
}

func NewGoogleOAuthConfig(config GoogleOAuthConfig) *oauth2.Config {
    return &oauth2.Config{
        ClientID:     config.ClientID,
        ClientSecret: config.ClientSecret,
        RedirectURL:  config.RedirectURL,
        Scopes: []string{
            "https://www.googleapis.com/auth/userinfo.email",
            "https://www.googleapis.com/auth/userinfo.profile",
        },
        Endpoint: google.Endpoint,
    }
}

func (s *AuthService) HandleGoogleLogin(c *gin.Context) {
    state := generateRandomState() // CSRF ë°©ì§€ë¥¼ ìœ„í•œ state ìƒì„±
    
    // ì„¸ì…˜ì— state ì €ì¥
    session := sessions.Default(c)
    session.Set("oauth_state", state)
    session.Save()
    
    url := s.googleOAuth.AuthCodeURL(state)
    c.Redirect(http.StatusTemporaryRedirect, url)
}

func (s *AuthService) HandleGoogleCallback(c *gin.Context) {
    // State ê²€ì¦
    session := sessions.Default(c)
    savedState := session.Get("oauth_state")
    if savedState != c.Query("state") {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid state"})
        return
    }
    
    // Authorization Codeë¡œ í† í° êµí™˜
    code := c.Query("code")
    token, err := s.googleOAuth.Exchange(context.Background(), code)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to exchange token"})
        return
    }
    
    // ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    userInfo, err := s.getGoogleUserInfo(token.AccessToken)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user info"})
        return
    }
    
    // ì‚¬ìš©ì ë“±ë¡/ë¡œê·¸ì¸ ì²˜ë¦¬
    user, err := s.processOAuthUser(userInfo.Email, userInfo.Name, "google")
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process user"})
        return
    }
    
    // JWT í† í° ìƒì„±
    jwtTokens, err := s.jwtManager.GenerateTokens(&Claims{
        UserID:   user.ID,
        Email:    user.Email,
        Provider: "google",
    })
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate tokens"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "user":   user,
        "tokens": jwtTokens,
    })
}

func (s *AuthService) getGoogleUserInfo(accessToken string) (*GoogleUserInfo, error) {
    resp, err := http.Get("https://www.googleapis.com/oauth2/v2/userinfo?access_token=" + accessToken)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var userInfo GoogleUserInfo
    if err := json.NewDecoder(resp.Body).Decode(&userInfo); err != nil {
        return nil, err
    }
    
    return &userInfo, nil
}
```

### RBAC (ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´)

#### ê¶Œí•œ í™•ì¸ ë¯¸ë“¤ì›¨ì–´
```go
package middleware

import (
    "net/http"
    "strings"
    
    "github.com/gin-gonic/gin"
)

// RequirePermission íŠ¹ì • ê¶Œí•œì´ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸ë¥¼ ë³´í˜¸
func RequirePermission(resource, action string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, exists := c.Get("user_id")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤"})
            c.Abort()
            return
        }
        
        // RBAC ì„œë¹„ìŠ¤ì—ì„œ ê¶Œí•œ í™•ì¸
        rbacService := c.MustGet("rbac_service").(RBACService)
        hasPermission, err := rbacService.CheckPermission(
            c.Request.Context(),
            userID.(string),
            resource,
            action,
            nil, // ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸
        )
        
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "ê¶Œí•œ í™•ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤"})
            c.Abort()
            return
        }
        
        if !hasPermission {
            c.JSON(http.StatusForbidden, gin.H{"error": "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// RequireRole íŠ¹ì • ì—­í• ì´ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸ë¥¼ ë³´í˜¸
func RequireRole(roles ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userRoles, exists := c.Get("user_roles")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤"})
            c.Abort()
            return
        }
        
        userRolesList := userRoles.([]string)
        hasRole := false
        
        for _, requiredRole := range roles {
            for _, userRole := range userRolesList {
                if userRole == requiredRole {
                    hasRole = true
                    break
                }
            }
            if hasRole {
                break
            }
        }
        
        if !hasRole {
            c.JSON(http.StatusForbidden, gin.H{
                "error": fmt.Sprintf("ë‹¤ìŒ ì—­í•  ì¤‘ í•˜ë‚˜ê°€ í•„ìš”í•©ë‹ˆë‹¤: %s", 
                    strings.Join(roles, ", ")),
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// ì‚¬ìš© ì˜ˆì œ
func setupRoutes(r *gin.Engine) {
    api := r.Group("/api/v1")
    api.Use(AuthMiddleware("your-secret"))
    
    // ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥
    admin := api.Group("/admin")
    admin.Use(RequireRole("admin"))
    {
        admin.GET("/users", listAllUsers)
        admin.DELETE("/users/:id", deleteUser)
    }
    
    // íŠ¹ì • ê¶Œí•œì´ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸
    api.GET("/projects", RequirePermission("projects", "read"), listProjects)
    api.POST("/projects", RequirePermission("projects", "create"), createProject)
    api.PUT("/projects/:id", RequirePermission("projects", "update"), updateProject)
    api.DELETE("/projects/:id", RequirePermission("projects", "delete"), deleteProject)
}
```

---

## ğŸ“š SDK ë° ë¼ì´ë¸ŒëŸ¬ë¦¬

### Go SDK

#### ì„¤ì¹˜
```bash
go get github.com/aicli/aicli-web-sdk-go
```

#### ì‚¬ìš©ë²•
```go
package main

import (
    "context"
    "log"
    
    "github.com/aicli/aicli-web-sdk-go"
)

func main() {
    // í´ë¼ì´ì–¸íŠ¸ ìƒì„±
    client := aicli.NewClient(&aicli.Config{
        BaseURL: "http://localhost:8080",
        APIKey:  "your-api-key", // ë˜ëŠ” OAuth í† í°
    })
    
    ctx := context.Background()
    
    // ì‚¬ìš©ì ì¸ì¦
    loginResp, err := client.Auth.Login(ctx, &aicli.LoginRequest{
        Email:    "user@example.com",
        Password: "password123",
    })
    if err != nil {
        log.Fatal(err)
    }
    
    // í† í° ì„¤ì •
    client.SetAccessToken(loginResp.Tokens.AccessToken)
    
    // í˜„ì¬ ì‚¬ìš©ì ì •ë³´
    user, err := client.Users.GetCurrent(ctx)
    if err != nil {
        log.Fatal(err)
    }
    log.Printf("Current user: %s (%s)", user.Name, user.Email)
    
    // í”„ë¡œì íŠ¸ ëª©ë¡
    projects, err := client.Projects.List(ctx, &aicli.ListProjectsRequest{
        Page:  1,
        Limit: 20,
    })
    if err != nil {
        log.Fatal(err)
    }
    log.Printf("Found %d projects", len(projects.Projects))
    
    // ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±
    newProject, err := client.Projects.Create(ctx, &aicli.CreateProjectRequest{
        Name:        "My SDK Project",
        Description: "SDKë¡œ ìƒì„±í•œ í”„ë¡œì íŠ¸",
    })
    if err != nil {
        log.Fatal(err)
    }
    log.Printf("Created project: %s (ID: %s)", newProject.Name, newProject.ID)
}
```

### JavaScript/TypeScript SDK

#### ì„¤ì¹˜
```bash
npm install @aicli/web-sdk
# ë˜ëŠ”
yarn add @aicli/web-sdk
```

#### ì‚¬ìš©ë²•
```typescript
import { AICodeClient } from '@aicli/web-sdk';

// í´ë¼ì´ì–¸íŠ¸ ìƒì„±
const client = new AICodeClient({
  baseURL: 'http://localhost:8080',
  apiKey: 'your-api-key', // ì„ íƒì 
});

async function example() {
  try {
    // ë¡œê·¸ì¸
    const loginResponse = await client.auth.login({
      email: 'user@example.com',
      password: 'password123',
    });
    
    console.log('ë¡œê·¸ì¸ ì„±ê³µ:', loginResponse.user.name);
    
    // ìë™ìœ¼ë¡œ í† í° ì„¤ì •ë¨
    
    // í˜„ì¬ ì‚¬ìš©ì ì •ë³´
    const currentUser = await client.users.getCurrent();
    console.log('í˜„ì¬ ì‚¬ìš©ì:', currentUser);
    
    // í”„ë¡œì íŠ¸ ëª©ë¡
    const projects = await client.projects.list({
      page: 1,
      limit: 20,
    });
    console.log('í”„ë¡œì íŠ¸ ëª©ë¡:', projects.projects);
    
    // ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±
    const newProject = await client.projects.create({
      name: 'My SDK Project',
      description: 'SDKë¡œ ìƒì„±í•œ í”„ë¡œì íŠ¸',
    });
    console.log('ìƒì„±ëœ í”„ë¡œì íŠ¸:', newProject);
    
    // WebSocket ì—°ê²°
    const ws = client.websocket.connect();
    
    ws.on('project.updated', (data) => {
      console.log('í”„ë¡œì íŠ¸ ì—…ë°ì´íŠ¸:', data);
    });
    
    ws.on('user.notification', (notification) => {
      console.log('ì•Œë¦¼:', notification);
    });
    
  } catch (error) {
    console.error('ì˜¤ë¥˜:', error);
  }
}

example();
```

### React Hook

#### ì„¤ì¹˜
```bash
npm install @aicli/react-hooks
```

#### ì‚¬ìš©ë²•
```tsx
import React from 'react';
import { AICodeProvider, useAuth, useProjects } from '@aicli/react-hooks';

// App ë£¨íŠ¸ì—ì„œ Provider ì„¤ì •
function App() {
  return (
    <AICodeProvider
      config={{
        baseURL: 'http://localhost:8080',
      }}
    >
      <Dashboard />
    </AICodeProvider>
  );
}

// ì»´í¬ë„ŒíŠ¸ì—ì„œ hooks ì‚¬ìš©
function Dashboard() {
  const { user, login, logout, isAuthenticated } = useAuth();
  const { 
    projects, 
    loading, 
    error, 
    createProject, 
    updateProject, 
    deleteProject 
  } = useProjects();

  const handleLogin = async () => {
    try {
      await login({
        email: 'user@example.com',
        password: 'password123',
      });
    } catch (error) {
      console.error('ë¡œê·¸ì¸ ì‹¤íŒ¨:', error);
    }
  };

  const handleCreateProject = async () => {
    try {
      await createProject({
        name: 'ìƒˆ í”„ë¡œì íŠ¸',
        description: 'ì„¤ëª…',
      });
    } catch (error) {
      console.error('í”„ë¡œì íŠ¸ ìƒì„± ì‹¤íŒ¨:', error);
    }
  };

  if (!isAuthenticated) {
    return (
      <div>
        <button onClick={handleLogin}>ë¡œê·¸ì¸</button>
      </div>
    );
  }

  return (
    <div>
      <h1>ì•ˆë…•í•˜ì„¸ìš”, {user?.name}ë‹˜!</h1>
      
      <button onClick={logout}>ë¡œê·¸ì•„ì›ƒ</button>
      
      <h2>í”„ë¡œì íŠ¸ ëª©ë¡</h2>
      {loading && <p>ë¡œë”© ì¤‘...</p>}
      {error && <p>ì˜¤ë¥˜: {error.message}</p>}
      
      <button onClick={handleCreateProject}>ìƒˆ í”„ë¡œì íŠ¸ ìƒì„±</button>
      
      <ul>
        {projects?.map((project) => (
          <li key={project.id}>
            {project.name} - {project.description}
            <button onClick={() => updateProject(project.id, { name: 'ìˆ˜ì •ëœ ì´ë¦„' })}>
              ìˆ˜ì •
            </button>
            <button onClick={() => deleteProject(project.id)}>
              ì‚­ì œ
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## ğŸ’¡ ì½”ë“œ ì˜ˆì œ

### WebSocket ì‹¤ì‹œê°„ í†µì‹ 

#### ì„œë²„ ì¸¡ (Go)
```go
package websocket

import (
    "encoding/json"
    "log"
    "net/http"
    
    "github.com/gin-gonic/gin"
    "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // í”„ë¡œë•ì…˜ì—ì„œëŠ” ì ì ˆí•œ ê²€ì¦ í•„ìš”
    },
}

type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    hub    *Hub
    conn   *websocket.Conn
    send   chan []byte
    userID string
}

type Message struct {
    Type    string      `json:"type"`
    Payload interface{} `json:"payload"`
    UserID  string      `json:"user_id,omitempty"`
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client] = true
            log.Printf("í´ë¼ì´ì–¸íŠ¸ ì—°ê²°: %s", client.userID)
            
        case client := <-h.unregister:
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
                log.Printf("í´ë¼ì´ì–¸íŠ¸ í•´ì œ: %s", client.userID)
            }
            
        case message := <-h.broadcast:
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
        }
    }
}

func (h *Hub) HandleWebSocket(c *gin.Context) {
    userID, exists := c.Get("user_id")
    if !exists {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤"})
        return
    }
    
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        log.Printf("WebSocket ì—…ê·¸ë ˆì´ë“œ ì‹¤íŒ¨: %v", err)
        return
    }
    
    client := &Client{
        hub:    h,
        conn:   conn,
        send:   make(chan []byte, 256),
        userID: userID.(string),
    }
    
    client.hub.register <- client
    
    go client.writePump()
    go client.readPump()
}

func (c *Client) readPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()
    
    for {
        _, messageBytes, err := c.conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                log.Printf("WebSocket ì—ëŸ¬: %v", err)
            }
            break
        }
        
        var msg Message
        if err := json.Unmarshal(messageBytes, &msg); err != nil {
            log.Printf("ë©”ì‹œì§€ íŒŒì‹± ì—ëŸ¬: %v", err)
            continue
        }
        
        msg.UserID = c.userID
        
        // ë©”ì‹œì§€ ì²˜ë¦¬ ë¡œì§
        c.handleMessage(&msg)
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()
    
    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            
            c.conn.WriteMessage(websocket.TextMessage, message)
        }
    }
}

func (c *Client) handleMessage(msg *Message) {
    switch msg.Type {
    case "project.subscribe":
        // í”„ë¡œì íŠ¸ êµ¬ë… ì²˜ë¦¬
        projectID := msg.Payload.(string)
        log.Printf("ì‚¬ìš©ì %sê°€ í”„ë¡œì íŠ¸ %së¥¼ êµ¬ë…í–ˆìŠµë‹ˆë‹¤", c.userID, projectID)
        
    case "project.unsubscribe":
        // í”„ë¡œì íŠ¸ êµ¬ë… í•´ì œ ì²˜ë¦¬
        projectID := msg.Payload.(string)
        log.Printf("ì‚¬ìš©ì %sê°€ í”„ë¡œì íŠ¸ %s êµ¬ë…ì„ í•´ì œí–ˆìŠµë‹ˆë‹¤", c.userID, projectID)
        
    default:
        log.Printf("ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…: %s", msg.Type)
    }
}

// íŠ¹ì • ì‚¬ìš©ìì—ê²Œ ë©”ì‹œì§€ ì „ì†¡
func (h *Hub) SendToUser(userID string, message *Message) {
    messageBytes, err := json.Marshal(message)
    if err != nil {
        log.Printf("ë©”ì‹œì§€ ì§ë ¬í™” ì—ëŸ¬: %v", err)
        return
    }
    
    for client := range h.clients {
        if client.userID == userID {
            select {
            case client.send <- messageBytes:
            default:
                close(client.send)
                delete(h.clients, client)
            }
        }
    }
}

// ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
func (h *Hub) Broadcast(message *Message) {
    messageBytes, err := json.Marshal(message)
    if err != nil {
        log.Printf("ë©”ì‹œì§€ ì§ë ¬í™” ì—ëŸ¬: %v", err)
        return
    }
    
    h.broadcast <- messageBytes
}
```

#### í´ë¼ì´ì–¸íŠ¸ ì¸¡ (JavaScript)
```javascript
class WebSocketClient {
  constructor(url, token) {
    this.url = url;
    this.token = token;
    this.ws = null;
    this.reconnectInterval = 5000;
    this.maxReconnectAttempts = 5;
    this.reconnectAttempts = 0;
    this.listeners = new Map();
  }

  connect() {
    try {
      this.ws = new WebSocket(`${this.url}?token=${this.token}`);
      
      this.ws.onopen = (event) => {
        console.log('WebSocket ì—°ê²°ë¨');
        this.reconnectAttempts = 0;
        this.emit('connected', event);
      };
      
      this.ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          this.emit(message.type, message.payload);
        } catch (error) {
          console.error('ë©”ì‹œì§€ íŒŒì‹± ì—ëŸ¬:', error);
        }
      };
      
      this.ws.onclose = (event) => {
        console.log('WebSocket ì—°ê²° ì¢…ë£Œ:', event.code, event.reason);
        this.emit('disconnected', event);
        this.handleReconnect();
      };
      
      this.ws.onerror = (error) => {
        console.error('WebSocket ì—ëŸ¬:', error);
        this.emit('error', error);
      };
      
    } catch (error) {
      console.error('WebSocket ì—°ê²° ì‹¤íŒ¨:', error);
      this.handleReconnect();
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  send(type, payload) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type, payload }));
    } else {
      console.warn('WebSocketì´ ì—°ê²°ë˜ì§€ ì•ŠìŒ');
    }
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  off(event, callback) {
    if (this.listeners.has(event)) {
      const callbacks = this.listeners.get(event);
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
    }
  }

  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error('ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì—ëŸ¬:', error);
        }
      });
    }
  }

  handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`ì¬ì—°ê²° ì‹œë„ ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
      
      setTimeout(() => {
        this.connect();
      }, this.reconnectInterval);
    } else {
      console.error('ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ ì´ˆê³¼');
      this.emit('max_reconnect_attempts_reached');
    }
  }

  // í”„ë¡œì íŠ¸ êµ¬ë…
  subscribeToProject(projectId) {
    this.send('project.subscribe', projectId);
  }

  // í”„ë¡œì íŠ¸ êµ¬ë… í•´ì œ
  unsubscribeFromProject(projectId) {
    this.send('project.unsubscribe', projectId);
  }
}

// ì‚¬ìš© ì˜ˆì œ
const wsClient = new WebSocketClient('ws://localhost:8080/ws', 'your-jwt-token');

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
wsClient.on('connected', () => {
  console.log('WebSocket ì—°ê²° ì„±ê³µ');
  
  // í”„ë¡œì íŠ¸ êµ¬ë…
  wsClient.subscribeToProject('project-123');
});

wsClient.on('project.updated', (data) => {
  console.log('í”„ë¡œì íŠ¸ ì—…ë°ì´íŠ¸:', data);
  // UI ì—…ë°ì´íŠ¸ ë¡œì§
});

wsClient.on('user.notification', (notification) => {
  console.log('ì•Œë¦¼:', notification);
  // ì•Œë¦¼ í‘œì‹œ ë¡œì§
});

wsClient.on('disconnected', () => {
  console.log('WebSocket ì—°ê²° í•´ì œ');
});

wsClient.on('error', (error) => {
  console.error('WebSocket ì—ëŸ¬:', error);
});

// ì—°ê²° ì‹œì‘
wsClient.connect();

// í˜ì´ì§€ ì¢…ë£Œ ì‹œ ì—°ê²° í•´ì œ
window.addEventListener('beforeunload', () => {
  wsClient.disconnect();
});
```

---

## ğŸ§ª í…ŒìŠ¤íŒ…

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

#### ì„œë¹„ìŠ¤ ë ˆì´ì–´ í…ŒìŠ¤íŠ¸
```go
package services_test

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/stretchr/testify/require"
    
    "github.com/aicli/aicli-web/internal/models"
    "github.com/aicli/aicli-web/internal/services"
    "github.com/aicli/aicli-web/internal/storage/mocks"
)

func TestUserService_CreateUser(t *testing.T) {
    // Given
    mockStorage := &mocks.Storage{}
    userService := services.NewUserService(mockStorage)
    
    ctx := context.Background()
    newUser := &models.User{
        Email: "test@example.com",
        Name:  "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì",
    }
    
    expectedUser := &models.User{
        ID:    "user-123",
        Email: "test@example.com",
        Name:  "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì",
    }
    
    // Mock ì„¤ì •
    mockStorage.On("CreateUser", ctx, mock.AnythingOfType("*models.User")).
        Return(expectedUser, nil)
    
    // When
    result, err := userService.CreateUser(ctx, newUser)
    
    // Then
    require.NoError(t, err)
    assert.Equal(t, expectedUser.ID, result.ID)
    assert.Equal(t, expectedUser.Email, result.Email)
    assert.Equal(t, expectedUser.Name, result.Name)
    
    mockStorage.AssertExpectations(t)
}

func TestUserService_GetUserByEmail(t *testing.T) {
    tests := []struct {
        name          string
        email         string
        mockUser      *models.User
        mockError     error
        expectedUser  *models.User
        expectedError string
    }{
        {
            name:  "ì„±ê³µì ì¸ ì‚¬ìš©ì ì¡°íšŒ",
            email: "test@example.com",
            mockUser: &models.User{
                ID:    "user-123",
                Email: "test@example.com",
                Name:  "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì",
            },
            mockError:    nil,
            expectedUser: &models.User{
                ID:    "user-123",
                Email: "test@example.com",
                Name:  "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì",
            },
            expectedError: "",
        },
        {
            name:          "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì‚¬ìš©ì",
            email:         "notfound@example.com",
            mockUser:      nil,
            mockError:     storage.ErrUserNotFound,
            expectedUser:  nil,
            expectedError: "user not found",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Given
            mockStorage := &mocks.Storage{}
            userService := services.NewUserService(mockStorage)
            
            ctx := context.Background()
            
            mockStorage.On("GetUserByEmail", ctx, tt.email).
                Return(tt.mockUser, tt.mockError)
            
            // When
            result, err := userService.GetUserByEmail(ctx, tt.email)
            
            // Then
            if tt.expectedError != "" {
                require.Error(t, err)
                assert.Contains(t, err.Error(), tt.expectedError)
                assert.Nil(t, result)
            } else {
                require.NoError(t, err)
                assert.Equal(t, tt.expectedUser, result)
            }
            
            mockStorage.AssertExpectations(t)
        })
    }
}
```

### í†µí•© í…ŒìŠ¤íŠ¸

#### API ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸
```go
package integration_test

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
    "github.com/stretchr/testify/suite"
    
    "github.com/aicli/aicli-web/internal/api"
    "github.com/aicli/aicli-web/internal/config"
    "github.com/aicli/aicli-web/internal/storage/memory"
)

type APITestSuite struct {
    suite.Suite
    router      *gin.Engine
    storage     storage.Storage
    accessToken string
}

func (suite *APITestSuite) SetupSuite() {
    gin.SetMode(gin.TestMode)
    
    // í…ŒìŠ¤íŠ¸ìš© ì„¤ì •
    cfg := &config.Config{
        Database: config.DatabaseConfig{
            Driver: "memory",
        },
        JWT: config.JWTConfig{
            Secret: "test-secret",
        },
    }
    
    // ë©”ëª¨ë¦¬ ìŠ¤í† ë¦¬ì§€ ì‚¬ìš©
    suite.storage = memory.NewMemoryStorage()
    
    // ë¼ìš°í„° ì„¤ì •
    suite.router = api.SetupRouter(cfg, suite.storage)
    
    // í…ŒìŠ¤íŠ¸ìš© ì‚¬ìš©ì ìƒì„± ë° í† í° íšë“
    suite.setupTestUser()
}

func (suite *APITestSuite) setupTestUser() {
    // í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ìƒì„±
    user := &models.User{
        Email: "test@example.com",
        Name:  "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì",
    }
    
    createdUser, err := suite.storage.CreateUser(context.Background(), user)
    require.NoError(suite.T(), err)
    
    // ë¡œê·¸ì¸í•˜ì—¬ í† í° íšë“
    loginReq := map[string]string{
        "email":    "test@example.com",
        "password": "password123",
    }
    
    body, _ := json.Marshal(loginReq)
    req := httptest.NewRequest("POST", "/api/v1/auth/login", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    suite.router.ServeHTTP(w, req)
    
    require.Equal(suite.T(), http.StatusOK, w.Code)
    
    var loginResp map[string]interface{}
    err = json.Unmarshal(w.Body.Bytes(), &loginResp)
    require.NoError(suite.T(), err)
    
    tokens := loginResp["tokens"].(map[string]interface{})
    suite.accessToken = tokens["access_token"].(string)
}

func (suite *APITestSuite) TestGetCurrentUser() {
    // Given
    req := httptest.NewRequest("GET", "/api/v1/users/me", nil)
    req.Header.Set("Authorization", "Bearer "+suite.accessToken)
    
    // When
    w := httptest.NewRecorder()
    suite.router.ServeHTTP(w, req)
    
    // Then
    assert.Equal(suite.T(), http.StatusOK, w.Code)
    
    var user models.User
    err := json.Unmarshal(w.Body.Bytes(), &user)
    require.NoError(suite.T(), err)
    
    assert.Equal(suite.T(), "test@example.com", user.Email)
    assert.Equal(suite.T(), "í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì", user.Name)
}

func (suite *APITestSuite) TestCreateProject() {
    // Given
    projectReq := map[string]string{
        "name":        "í…ŒìŠ¤íŠ¸ í”„ë¡œì íŠ¸",
        "description": "í…ŒìŠ¤íŠ¸ìš© í”„ë¡œì íŠ¸ì…ë‹ˆë‹¤",
    }
    
    body, _ := json.Marshal(projectReq)
    req := httptest.NewRequest("POST", "/api/v1/projects", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+suite.accessToken)
    
    // When
    w := httptest.NewRecorder()
    suite.router.ServeHTTP(w, req)
    
    // Then
    assert.Equal(suite.T(), http.StatusCreated, w.Code)
    
    var project models.Project
    err := json.Unmarshal(w.Body.Bytes(), &project)
    require.NoError(suite.T(), err)
    
    assert.Equal(suite.T(), "í…ŒìŠ¤íŠ¸ í”„ë¡œì íŠ¸", project.Name)
    assert.Equal(suite.T(), "í…ŒìŠ¤íŠ¸ìš© í”„ë¡œì íŠ¸ì…ë‹ˆë‹¤", project.Description)
    assert.NotEmpty(suite.T(), project.ID)
}

func (suite *APITestSuite) TestUnauthorizedAccess() {
    // Given
    req := httptest.NewRequest("GET", "/api/v1/users/me", nil)
    // Authorization í—¤ë” ì—†ìŒ
    
    // When
    w := httptest.NewRecorder()
    suite.router.ServeHTTP(w, req)
    
    // Then
    assert.Equal(suite.T(), http.StatusUnauthorized, w.Code)
    
    var response map[string]interface{}
    err := json.Unmarshal(w.Body.Bytes(), &response)
    require.NoError(suite.T(), err)
    
    assert.Contains(suite.T(), response["error"], "Authorization")
}

func TestAPITestSuite(t *testing.T) {
    suite.Run(t, new(APITestSuite))
}
```

### E2E í…ŒìŠ¤íŠ¸

#### Postman/Newman ì»¬ë ‰ì…˜
```json
{
  "info": {
    "name": "AICode Manager API Tests",
    "description": "E2E API í…ŒìŠ¤íŠ¸ ì»¬ë ‰ì…˜",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "variable": [
    {
      "key": "baseUrl",
      "value": "http://localhost:8080"
    },
    {
      "key": "accessToken",
      "value": ""
    }
  ],
  "item": [
    {
      "name": "Authentication",
      "item": [
        {
          "name": "Login",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('ë¡œê·¸ì¸ ì„±ê³µ', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test('í† í° ë°˜í™˜ë¨', function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property('tokens');",
                  "    pm.expect(jsonData.tokens).to.have.property('access_token');",
                  "    ",
                  "    // í™˜ê²½ ë³€ìˆ˜ì— í† í° ì €ì¥",
                  "    pm.collectionVariables.set('accessToken', jsonData.tokens.access_token);",
                  "});",
                  "",
                  "pm.test('ì‚¬ìš©ì ì •ë³´ ë°˜í™˜ë¨', function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property('user');",
                  "    pm.expect(jsonData.user).to.have.property('email');",
                  "    pm.expect(jsonData.user).to.have.property('name');",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"test@example.com\",\n  \"password\": \"password123\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/api/v1/auth/login",
              "host": ["{{baseUrl}}"],
              "path": ["api", "v1", "auth", "login"]
            }
          }
        }
      ]
    },
    {
      "name": "Users",
      "item": [
        {
          "name": "Get Current User",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ ì„±ê³µ', function () {",
                  "    pm.response.to.have.status(200);",
                  "});",
                  "",
                  "pm.test('ì‚¬ìš©ì ì •ë³´ í˜•ì‹ í™•ì¸', function () {",
                  "    const jsonData = pm.response.json();",
                  "    pm.expect(jsonData).to.have.property('id');",
                  "    pm.expect(jsonData).to.have.property('email');",
                  "    pm.expect(jsonData).to.have.property('name');",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "method": "GET",
            "header": [
              {
                "key": "Authorization",
                "value": "Bearer {{accessToken}}"
              }
            ],
            "url": {
              "raw": "{{baseUrl}}/api/v1/users/me",
              "host": ["{{baseUrl}}"],
              "path": ["api", "v1", "users", "me"]
            }
          }
        }
      ]
    }
  ]
}
```

#### í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
```bash
#!/bin/bash
# e2e-test.sh

# ì„œë²„ ì‹œì‘
echo "ì„œë²„ ì‹œì‘ ì¤‘..."
make dev &
SERVER_PID=$!

# ì„œë²„ê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ ëŒ€ê¸°
echo "ì„œë²„ ì¤€ë¹„ ëŒ€ê¸° ì¤‘..."
while ! curl -f http://localhost:8080/health > /dev/null 2>&1; do
    sleep 1
done

echo "E2E í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘..."

# Newmanìœ¼ë¡œ Postman ì»¬ë ‰ì…˜ ì‹¤í–‰
newman run tests/postman/aicli-api-tests.json \
    --environment tests/postman/environments/local.json \
    --reporters cli,json \
    --reporter-json-export test-results.json

TEST_RESULT=$?

# ì„œë²„ ì¢…ë£Œ
echo "ì„œë²„ ì¢…ë£Œ ì¤‘..."
kill $SERVER_PID

# ê²°ê³¼ ì¶œë ¥
if [ $TEST_RESULT -eq 0 ]; then
    echo "âœ… ëª¨ë“  E2E í…ŒìŠ¤íŠ¸ í†µê³¼"
else
    echo "âŒ E2E í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨"
fi

exit $TEST_RESULT
```

---

## ğŸ› ë””ë²„ê¹…

### ë¡œê¹… ë° ë””ë²„ê¹… ì„¤ì •

#### êµ¬ì¡°í™”ëœ ë¡œê¹…
```go
package logger

import (
    "context"
    "os"
    
    "github.com/sirupsen/logrus"
)

type Logger struct {
    *logrus.Logger
}

type Fields map[string]interface{}

func NewLogger(level string, format string) *Logger {
    log := logrus.New()
    
    // ë¡œê·¸ ë ˆë²¨ ì„¤ì •
    lvl, err := logrus.ParseLevel(level)
    if err != nil {
        log.SetLevel(logrus.InfoLevel)
    } else {
        log.SetLevel(lvl)
    }
    
    // í¬ë§· ì„¤ì •
    if format == "json" {
        log.SetFormatter(&logrus.JSONFormatter{
            TimestampFormat: "2006-01-02T15:04:05.000Z07:00",
        })
    } else {
        log.SetFormatter(&logrus.TextFormatter{
            FullTimestamp:   true,
            TimestampFormat: "2006-01-02 15:04:05",
        })
    }
    
    log.SetOutput(os.Stdout)
    
    return &Logger{log}
}

func (l *Logger) WithFields(fields Fields) *logrus.Entry {
    return l.Logger.WithFields(logrus.Fields(fields))
}

func (l *Logger) WithContext(ctx context.Context) *logrus.Entry {
    entry := l.Logger.WithContext(ctx)
    
    // ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì¶”ê°€ ì •ë³´ ì¶”ì¶œ
    if userID, ok := ctx.Value("user_id").(string); ok {
        entry = entry.WithField("user_id", userID)
    }
    
    if requestID, ok := ctx.Value("request_id").(string); ok {
        entry = entry.WithField("request_id", requestID)
    }
    
    return entry
}

// ì‚¬ìš© ì˜ˆì œ
func (s *UserService) CreateUser(ctx context.Context, user *models.User) (*models.User, error) {
    logger := s.logger.WithContext(ctx).WithFields(Fields{
        "operation": "CreateUser",
        "email":     user.Email,
    })
    
    logger.Info("ì‚¬ìš©ì ìƒì„± ì‹œì‘")
    
    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    createdUser, err := s.storage.CreateUser(ctx, user)
    if err != nil {
        logger.WithError(err).Error("ì‚¬ìš©ì ìƒì„± ì‹¤íŒ¨")
        return nil, err
    }
    
    logger.WithField("user_id", createdUser.ID).Info("ì‚¬ìš©ì ìƒì„± ì™„ë£Œ")
    return createdUser, nil
}
```

#### ë””ë²„ê¹… ë¯¸ë“¤ì›¨ì–´
```go
package middleware

import (
    "bytes"
    "io"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
)

type responseWriter struct {
    gin.ResponseWriter
    body *bytes.Buffer
}

func (w *responseWriter) Write(b []byte) (int, error) {
    w.body.Write(b)
    return w.ResponseWriter.Write(b)
}

func DebugMiddleware(logger Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        if gin.Mode() != gin.DebugMode {
            c.Next()
            return
        }
        
        start := time.Now()
        requestID := uuid.New().String()
        
        // Request ID ì„¤ì •
        c.Set("request_id", requestID)
        c.Header("X-Request-ID", requestID)
        
        // ìš”ì²­ ë³¸ë¬¸ ìº¡ì²˜
        var requestBody []byte
        if c.Request.Body != nil {
            requestBody, _ = io.ReadAll(c.Request.Body)
            c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
        }
        
        // ì‘ë‹µ ë³¸ë¬¸ ìº¡ì²˜
        responseWriter := &responseWriter{
            ResponseWriter: c.Writer,
            body:          bytes.NewBuffer([]byte{}),
        }
        c.Writer = responseWriter
        
        // ìš”ì²­ ë¡œê¹…
        logger.WithFields(Fields{
            "request_id":     requestID,
            "method":         c.Request.Method,
            "path":           c.Request.URL.Path,
            "query":          c.Request.URL.RawQuery,
            "user_agent":     c.Request.UserAgent(),
            "remote_addr":    c.ClientIP(),
            "request_body":   string(requestBody),
            "request_headers": c.Request.Header,
        }).Debug("ìš”ì²­ ì‹œì‘")
        
        c.Next()
        
        // ì‘ë‹µ ë¡œê¹…
        duration := time.Since(start)
        
        logEntry := logger.WithFields(Fields{
            "request_id":      requestID,
            "method":          c.Request.Method,
            "path":            c.Request.URL.Path,
            "status":          c.Writer.Status(),
            "duration_ms":     duration.Milliseconds(),
            "response_body":   responseWriter.body.String(),
            "response_headers": c.Writer.Header(),
        })
        
        if c.Writer.Status() >= 400 {
            logEntry.Error("ìš”ì²­ ì™„ë£Œ (ì—ëŸ¬)")
        } else {
            logEntry.Debug("ìš”ì²­ ì™„ë£Œ")
        }
    }
}
```

### ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§

#### pprof ì„¤ì •
```go
package main

import (
    _ "net/http/pprof"
    "net/http"
    
    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()
    
    // ê°œë°œ í™˜ê²½ì—ì„œë§Œ pprof í™œì„±í™”
    if gin.Mode() == gin.DebugMode {
        // pprof ì—”ë“œí¬ì¸íŠ¸
        r.GET("/debug/pprof/", gin.WrapH(http.DefaultServeMux))
        r.GET("/debug/pprof/cmdline", gin.WrapH(http.DefaultServeMux))
        r.GET("/debug/pprof/profile", gin.WrapH(http.DefaultServeMux))
        r.GET("/debug/pprof/symbol", gin.WrapH(http.DefaultServeMux))
        r.GET("/debug/pprof/trace", gin.WrapH(http.DefaultServeMux))
    }
    
    // ì¼ë°˜ ë¼ìš°íŠ¸ ì„¤ì •
    setupRoutes(r)
    
    r.Run(":8080")
}
```

#### í”„ë¡œíŒŒì¼ë§ ëª…ë ¹ì–´
```bash
# CPU í”„ë¡œíŒŒì¼ë§ (30ì´ˆ)
go tool pprof http://localhost:8080/debug/pprof/profile?seconds=30

# ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§
go tool pprof http://localhost:8080/debug/pprof/heap

# ê³ ë£¨í‹´ í”„ë¡œíŒŒì¼ë§
go tool pprof http://localhost:8080/debug/pprof/goroutine

# ì›¹ ì¸í„°í˜ì´ìŠ¤ë¡œ ë¶„ì„
go tool pprof -http=:8081 http://localhost:8080/debug/pprof/profile?seconds=30
```

### ì—ëŸ¬ ì¶”ì 

#### Sentry í†µí•©
```go
package errors

import (
    "context"
    "fmt"
    
    "github.com/getsentry/sentry-go"
    sentrygin "github.com/getsentry/sentry-go/gin"
    "github.com/gin-gonic/gin"
)

func InitSentry(dsn string, environment string) error {
    return sentry.Init(sentry.ClientOptions{
        Dsn:         dsn,
        Environment: environment,
        BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event {
            // ë¯¼ê°í•œ ì •ë³´ í•„í„°ë§
            if event.Request != nil {
                // Authorization í—¤ë” ì œê±°
                if event.Request.Headers != nil {
                    delete(event.Request.Headers, "Authorization")
                }
            }
            return event
        },
    })
}

func SentryMiddleware() gin.HandlerFunc {
    return sentrygin.New(sentrygin.Options{
        Repanic: true,
    })
}

// ì»¤ìŠ¤í…€ ì—ëŸ¬ ë¦¬í¬íŒ…
func ReportError(ctx context.Context, err error, extra map[string]interface{}) {
    hub := sentry.GetHubFromContext(ctx)
    if hub == nil {
        hub = sentry.CurrentHub()
    }
    
    // ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
    if userID, ok := ctx.Value("user_id").(string); ok {
        hub.ConfigureScope(func(scope *sentry.Scope) {
            scope.SetUser(sentry.User{
                ID: userID,
            })
        })
    }
    
    // ì¶”ê°€ ì •ë³´ ì„¤ì •
    hub.ConfigureScope(func(scope *sentry.Scope) {
        for key, value := range extra {
            scope.SetExtra(key, value)
        }
    })
    
    hub.CaptureException(err)
}

// ì‚¬ìš© ì˜ˆì œ
func (s *UserService) CreateUser(ctx context.Context, user *models.User) (*models.User, error) {
    createdUser, err := s.storage.CreateUser(ctx, user)
    if err != nil {
        ReportError(ctx, err, map[string]interface{}{
            "operation": "CreateUser",
            "email":     user.Email,
        })
        return nil, fmt.Errorf("ì‚¬ìš©ì ìƒì„± ì‹¤íŒ¨: %w", err)
    }
    
    return createdUser, nil
}
```

---

## âœ¨ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### ì½”ë”© ê·œì¹™

#### 1. ë„¤ì´ë° ì»¨ë²¤ì…˜
```go
// íŒ¨í‚¤ì§€ëª…: ì†Œë¬¸ì, ì§§ê³  ëª…í™•í•˜ê²Œ
package auth

// êµ¬ì¡°ì²´ëª…: PascalCase
type UserService struct {
    storage Storage
    logger  Logger
}

// ì¸í„°í˜ì´ìŠ¤ëª…: PascalCase, í–‰ë™ì„ ë‚˜íƒ€ë‚´ëŠ” -er ì ‘ë¯¸ì‚¬
type UserRepository interface {
    CreateUser(ctx context.Context, user *User) (*User, error)
    GetUserByID(ctx context.Context, id string) (*User, error)
}

// í•¨ìˆ˜ëª…: PascalCase (public), camelCase (private)
func (s *UserService) CreateUser(ctx context.Context, user *User) (*User, error) {
    return s.createUserInternal(ctx, user)
}

func (s *UserService) createUserInternal(ctx context.Context, user *User) (*User, error) {
    // ë‚´ë¶€ êµ¬í˜„
}

// ìƒìˆ˜: SCREAMING_SNAKE_CASE
const (
    DEFAULT_PAGE_SIZE = 20
    MAX_PAGE_SIZE     = 100
    JWT_ISSUER       = "aicli-web"
)

// ë³€ìˆ˜: camelCase
var (
    defaultConfig = &Config{}
    errUserNotFound = errors.New("user not found")
)
```

#### 2. ì—ëŸ¬ ì²˜ë¦¬
```go
// ì»¤ìŠ¤í…€ ì—ëŸ¬ íƒ€ì… ì •ì˜
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}

// ì—ëŸ¬ ë˜í•‘ ì‚¬ìš©
func (s *UserService) CreateUser(ctx context.Context, user *User) (*User, error) {
    if err := s.validateUser(user); err != nil {
        return nil, fmt.Errorf("user validation failed: %w", err)
    }
    
    createdUser, err := s.storage.CreateUser(ctx, user)
    if err != nil {
        return nil, fmt.Errorf("failed to create user in storage: %w", err)
    }
    
    return createdUser, nil
}

// ì—ëŸ¬ ê²€ì‚¬ ë° ì²˜ë¦¬
func (h *UserHandler) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        h.logger.WithError(err).Error("Invalid request body")
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
        return
    }
    
    user, err := h.userService.CreateUser(c.Request.Context(), &req.User)
    if err != nil {
        var validationErr *ValidationError
        if errors.As(err, &validationErr) {
            c.JSON(http.StatusBadRequest, gin.H{"error": validationErr.Error()})
            return
        }
        
        h.logger.WithError(err).Error("Failed to create user")
        c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal server error"})
        return
    }
    
    c.JSON(http.StatusCreated, user)
}
```

#### 3. ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©
```go
// ì»¨í…ìŠ¤íŠ¸ì— ê°’ ì €ì¥/ì¡°íšŒë¥¼ ìœ„í•œ í‚¤ íƒ€ì…
type contextKey string

const (
    userIDKey    contextKey = "user_id"
    requestIDKey contextKey = "request_id"
)

// ì»¨í…ìŠ¤íŠ¸ í—¬í¼ í•¨ìˆ˜
func WithUserID(ctx context.Context, userID string) context.Context {
    return context.WithValue(ctx, userIDKey, userID)
}

func GetUserID(ctx context.Context) (string, bool) {
    userID, ok := ctx.Value(userIDKey).(string)
    return userID, ok
}

// íƒ€ì„ì•„ì›ƒ ì„¤ì •
func (s *UserService) CreateUser(ctx context.Context, user *User) (*User, error) {
    // ìµœëŒ€ 5ì´ˆ íƒ€ì„ì•„ì›ƒ
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    return s.storage.CreateUser(ctx, user)
}

// ì»¨í…ìŠ¤íŠ¸ ì „íŒŒ
func (h *UserHandler) CreateUser(c *gin.Context) {
    ctx := c.Request.Context()
    
    // ì‚¬ìš©ì ID ì¶”ê°€
    if userID, exists := c.Get("user_id"); exists {
        ctx = WithUserID(ctx, userID.(string))
    }
    
    user, err := h.userService.CreateUser(ctx, &req.User)
    // ...
}
```

### ì„±ëŠ¥ ìµœì í™”

#### 1. ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”
```go
// ì—°ê²° í’€ ì„¤ì •
func setupDatabase(cfg *DatabaseConfig) (*sql.DB, error) {
    db, err := sql.Open(cfg.Driver, cfg.ConnectionString)
    if err != nil {
        return nil, err
    }
    
    // ì—°ê²° í’€ ì„¤ì •
    db.SetMaxOpenConns(cfg.MaxOpenConns)     // ìµœëŒ€ ì—°ê²° ìˆ˜
    db.SetMaxIdleConns(cfg.MaxIdleConns)     // ìµœëŒ€ ìœ íœ´ ì—°ê²° ìˆ˜
    db.SetConnMaxLifetime(cfg.ConnMaxLifetime) // ì—°ê²° ìµœëŒ€ ìˆ˜ëª…
    
    return db, nil
}

// ë°°ì¹˜ ì²˜ë¦¬
func (r *PostgresRepository) CreateUsers(ctx context.Context, users []*User) error {
    query := `
        INSERT INTO users (id, email, name, created_at) 
        VALUES ($1, $2, $3, $4)`
    
    tx, err := r.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    stmt, err := tx.PrepareContext(ctx, query)
    if err != nil {
        return err
    }
    defer stmt.Close()
    
    for _, user := range users {
        _, err = stmt.ExecContext(ctx, user.ID, user.Email, user.Name, time.Now())
        if err != nil {
            return err
        }
    }
    
    return tx.Commit()
}

// ì¸ë±ìŠ¤ í™œìš©ì„ ìœ„í•œ ì¿¼ë¦¬ ìµœì í™”
func (r *PostgresRepository) GetUsersByRole(ctx context.Context, role string, limit, offset int) ([]*User, error) {
    query := `
        SELECT u.id, u.email, u.name, u.created_at
        FROM users u
        JOIN user_roles ur ON u.id = ur.user_id
        JOIN roles r ON ur.role_id = r.id
        WHERE r.name = $1
        ORDER BY u.created_at DESC
        LIMIT $2 OFFSET $3`
    
    rows, err := r.db.QueryContext(ctx, query, role, limit, offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []*User
    for rows.Next() {
        user := &User{}
        err := rows.Scan(&user.ID, &user.Email, &user.Name, &user.CreatedAt)
        if err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    
    return users, rows.Err()
}
```

#### 2. ìºì‹± ì „ëµ
```go
package cache

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/go-redis/redis/v8"
)

type RedisCache struct {
    client *redis.Client
}

func NewRedisCache(addr, password string, db int) *RedisCache {
    client := redis.NewClient(&redis.Options{
        Addr:     addr,
        Password: password,
        DB:       db,
    })
    
    return &RedisCache{client: client}
}

// ì œë„¤ë¦­ ìºì‹œ ë©”ì†Œë“œ
func (c *RedisCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    
    return c.client.Set(ctx, key, data, expiration).Err()
}

func (c *RedisCache) Get(ctx context.Context, key string, dest interface{}) error {
    data, err := c.client.Get(ctx, key).Bytes()
    if err != nil {
        return err
    }
    
    return json.Unmarshal(data, dest)
}

// ìºì‹œë¥¼ í™œìš©í•œ ì„œë¹„ìŠ¤ êµ¬í˜„
type CachedUserService struct {
    userService UserService
    cache       *RedisCache
}

func (s *CachedUserService) GetUserByID(ctx context.Context, id string) (*User, error) {
    cacheKey := fmt.Sprintf("user:%s", id)
    
    // ìºì‹œì—ì„œ ì¡°íšŒ
    var user User
    err := s.cache.Get(ctx, cacheKey, &user)
    if err == nil {
        return &user, nil
    }
    
    // ìºì‹œ ë¯¸ìŠ¤, ì›ë³¸ ì„œë¹„ìŠ¤ì—ì„œ ì¡°íšŒ
    user, err = s.userService.GetUserByID(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // ìºì‹œì— ì €ì¥ (5ë¶„)
    s.cache.Set(ctx, cacheKey, user, 5*time.Minute)
    
    return user, nil
}

// Write-through ìºì‹œ
func (s *CachedUserService) UpdateUser(ctx context.Context, id string, updates *UserUpdates) (*User, error) {
    // ì›ë³¸ ì—…ë°ì´íŠ¸
    user, err := s.userService.UpdateUser(ctx, id, updates)
    if err != nil {
        return nil, err
    }
    
    // ìºì‹œ ì—…ë°ì´íŠ¸
    cacheKey := fmt.Sprintf("user:%s", id)
    s.cache.Set(ctx, cacheKey, user, 5*time.Minute)
    
    return user, nil
}
```

### ë³´ì•ˆ ëª¨ë²” ì‚¬ë¡€

#### 1. ì…ë ¥ ê²€ì¦
```go
package validator

import (
    "regexp"
    "strings"
    "unicode"
)

type UserValidator struct{}

func (v *UserValidator) ValidateEmail(email string) error {
    if email == "" {
        return &ValidationError{Field: "email", Message: "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤"}
    }
    
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(email) {
        return &ValidationError{Field: "email", Message: "ìœ íš¨í•œ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤"}
    }
    
    return nil
}

func (v *UserValidator) ValidatePassword(password string) error {
    if len(password) < 8 {
        return &ValidationError{Field: "password", Message: "ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœì†Œ 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤"}
    }
    
    if len(password) > 128 {
        return &ValidationError{Field: "password", Message: "ë¹„ë°€ë²ˆí˜¸ëŠ” ìµœëŒ€ 128ìê¹Œì§€ í—ˆìš©ë©ë‹ˆë‹¤"}
    }
    
    var (
        hasUpper   = false
        hasLower   = false
        hasNumber  = false
        hasSpecial = false
    )
    
    for _, char := range password {
        switch {
        case unicode.IsUpper(char):
            hasUpper = true
        case unicode.IsLower(char):
            hasLower = true
        case unicode.IsNumber(char):
            hasNumber = true
        case unicode.IsPunct(char) || unicode.IsSymbol(char):
            hasSpecial = true
        }
    }
    
    if !hasUpper || !hasLower || !hasNumber || !hasSpecial {
        return &ValidationError{
            Field:   "password",
            Message: "ë¹„ë°€ë²ˆí˜¸ëŠ” ëŒ€ë¬¸ì, ì†Œë¬¸ì, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìë¥¼ ê°ê° ìµœì†Œ 1ê°œì”© í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤",
        }
    }
    
    return nil
}

// SQL Injection ë°©ì§€
func (v *UserValidator) ValidateSearchQuery(query string) error {
    // SQL í‚¤ì›Œë“œ í•„í„°ë§
    sqlKeywords := []string{
        "SELECT", "INSERT", "UPDATE", "DELETE", "DROP", "CREATE", "ALTER",
        "UNION", "OR", "AND", "WHERE", "EXEC", "EXECUTE",
    }
    
    upperQuery := strings.ToUpper(query)
    for _, keyword := range sqlKeywords {
        if strings.Contains(upperQuery, keyword) {
            return &ValidationError{
                Field:   "query",
                Message: "ê²€ìƒ‰ì–´ì— í—ˆìš©ë˜ì§€ ì•ŠëŠ” ë¬¸ìê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤",
            }
        }
    }
    
    return nil
}

// XSS ë°©ì§€
func (v *UserValidator) SanitizeHTML(input string) string {
    // HTML íƒœê·¸ ì œê±°
    htmlRegex := regexp.MustCompile(`<[^>]*>`)
    cleaned := htmlRegex.ReplaceAllString(input, "")
    
    // ìŠ¤í¬ë¦½íŠ¸ ê´€ë ¨ ë¬¸ìì—´ ì œê±°
    scriptRegex := regexp.MustCompile(`(?i)(javascript|vbscript|onload|onerror|onclick)`)
    cleaned = scriptRegex.ReplaceAllString(cleaned, "")
    
    return cleaned
}
```

#### 2. Rate Limiting
```go
package ratelimit

import (
    "context"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
    "golang.org/x/time/rate"
)

type RateLimiter struct {
    redis  *redis.Client
    window time.Duration
    limit  int
}

func NewRateLimiter(redis *redis.Client, window time.Duration, limit int) *RateLimiter {
    return &RateLimiter{
        redis:  redis,
        window: window,
        limit:  limit,
    }
}

func (rl *RateLimiter) Allow(ctx context.Context, key string) (bool, error) {
    now := time.Now().Unix()
    window := int64(rl.window.Seconds())
    windowStart := now - window
    
    pipe := rl.redis.Pipeline()
    
    // í˜„ì¬ ìœˆë„ìš°ì˜ ìš”ì²­ ìˆ˜ í™•ì¸
    countCmd := pipe.ZCount(ctx, key, fmt.Sprintf("%d", windowStart), fmt.Sprintf("%d", now))
    
    // í˜„ì¬ ìš”ì²­ ì¶”ê°€
    pipe.ZAdd(ctx, key, &redis.Z{Score: float64(now), Member: now})
    
    // ì˜¤ë˜ëœ ìš”ì²­ ì œê±°
    pipe.ZRemRangeByScore(ctx, key, "0", fmt.Sprintf("%d", windowStart))
    
    // TTL ì„¤ì •
    pipe.Expire(ctx, key, rl.window)
    
    _, err := pipe.Exec(ctx)
    if err != nil {
        return false, err
    }
    
    count := countCmd.Val()
    return count < int64(rl.limit), nil
}

// ë¯¸ë“¤ì›¨ì–´ë¡œ ì‚¬ìš©
func RateLimitMiddleware(limiter *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        key := fmt.Sprintf("rate_limit:%s", c.ClientIP())
        
        allowed, err := limiter.Allow(c.Request.Context(), key)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Rate limit check failed"})
            c.Abort()
            return
        }
        
        if !allowed {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Rate limit exceeded",
                "retry_after": int(limiter.window.Seconds()),
            })
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

---

## â“ FAQ

### Q1: API í˜¸ì¶œ ì‹œ 401 Unauthorized ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.

**A1**: ë‹¤ìŒ ì‚¬í•­ë“¤ì„ í™•ì¸í•´ë³´ì„¸ìš”:

1. **í† í° í˜•ì‹ í™•ì¸**:
   ```bash
   # ì˜¬ë°”ë¥¸ í˜•ì‹
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   
   # ì˜ëª»ëœ í˜•ì‹
   Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...  # Bearer ëˆ„ë½
   ```

2. **í† í° ë§Œë£Œ í™•ì¸**:
   ```javascript
   // JWT í† í° ë””ì½”ë”©í•˜ì—¬ ë§Œë£Œ ì‹œê°„ í™•ì¸
   const payload = JSON.parse(atob(token.split('.')[1]));
   const isExpired = payload.exp * 1000 < Date.now();
   ```

3. **í† í° ê°±ì‹ **:
   ```bash
   curl -X POST "http://localhost:8080/api/v1/auth/refresh" \
     -H "Content-Type: application/json" \
     -d '{"refresh_token": "YOUR_REFRESH_TOKEN"}'
   ```

### Q2: CORS ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.

**A2**: ì„œë²„ì—ì„œ CORS ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”:

```go
// CORS ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
func CORSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Header("Access-Control-Allow-Origin", "http://localhost:3000")
        c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Authorization, Content-Type")
        c.Header("Access-Control-Allow-Credentials", "true")
        
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        
        c.Next()
    }
}
```

### Q3: WebSocket ì—°ê²°ì´ ìì£¼ ëŠì–´ì§‘ë‹ˆë‹¤.

**A3**: ë‹¤ìŒê³¼ ê°™ì€ ë°©ë²•ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

1. **Ping/Pong êµ¬í˜„**:
   ```javascript
   setInterval(() => {
       if (ws.readyState === WebSocket.OPEN) {
           ws.send(JSON.stringify({ type: 'ping' }));
       }
   }, 30000); // 30ì´ˆë§ˆë‹¤ ping ì „ì†¡
   ```

2. **ì¬ì—°ê²° ë¡œì§**:
   ```javascript
   ws.onclose = function(event) {
       console.log('WebSocket ì—°ê²° ì¢…ë£Œ:', event.code);
       setTimeout(() => {
           console.log('ì¬ì—°ê²° ì‹œë„...');
           connect();
       }, 5000);
   };
   ```

### Q4: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.

**A4**: ì—°ê²° ì„¤ì •ì„ í™•ì¸í•´ë³´ì„¸ìš”:

1. **ì—°ê²° ë¬¸ìì—´ í™•ì¸**:
   ```yaml
   database:
     host: "localhost"
     port: 5432
     name: "aicli_web"
     user: "aicli_user"
     password: "your_password"
     ssl_mode: "disable"  # ê°œë°œ í™˜ê²½ì—ì„œëŠ” disable
   ```

2. **ì—°ê²° í…ŒìŠ¤íŠ¸**:
   ```bash
   psql -h localhost -U aicli_user -d aicli_web -c "SELECT 1;"
   ```

### Q5: Rate Limitingì— ìì£¼ ê±¸ë¦½ë‹ˆë‹¤.

**A5**: Rate Limit ì„¤ì •ì„ ì¡°ì •í•˜ê±°ë‚˜ ìš”ì²­ì„ ìµœì í™”í•˜ì„¸ìš”:

1. **ì„¤ì • ì¡°ì •**:
   ```yaml
   security:
     rate_limit:
       requests_per_second: 200  # ì¦ê°€
       burst_size: 400          # ì¦ê°€
   ```

2. **ìš”ì²­ ìµœì í™”**:
   ```javascript
   // ë¶ˆí•„ìš”í•œ ì¤‘ë³µ ìš”ì²­ ë°©ì§€
   const debounce = (func, wait) => {
       let timeout;
       return function executedFunction(...args) {
           const later = () => {
               clearTimeout(timeout);
               func(...args);
           };
           clearTimeout(timeout);
           timeout = setTimeout(later, wait);
       };
   };
   ```

### Q6: ì„±ëŠ¥ì´ ëŠë¦½ë‹ˆë‹¤.

**A6**: ë‹¤ìŒê³¼ ê°™ì€ ìµœì í™”ë¥¼ ì‹œë„í•´ë³´ì„¸ìš”:

1. **ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤ í™•ì¸**:
   ```sql
   EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';
   ```

2. **ìºì‹± êµ¬í˜„**:
   ```go
   // ìì£¼ ì¡°íšŒë˜ëŠ” ë°ì´í„° ìºì‹±
   func (s *UserService) GetUserByID(ctx context.Context, id string) (*User, error) {
       if user := s.cache.Get("user:" + id); user != nil {
           return user, nil
       }
       
       user, err := s.storage.GetUserByID(ctx, id)
       if err == nil {
           s.cache.Set("user:"+id, user, 5*time.Minute)
       }
       
       return user, err
   }
   ```

3. **ì—°ê²° í’€ íŠœë‹**:
   ```go
   db.SetMaxOpenConns(25)
   db.SetMaxIdleConns(5)
   db.SetConnMaxLifetime(5 * time.Minute)
   ```

### Q7: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ê³„ì† ì¦ê°€í•©ë‹ˆë‹¤.

**A7**: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ í™•ì¸í•˜ê³  ìµœì í™”í•˜ì„¸ìš”:

1. **pprofë¡œ ë©”ëª¨ë¦¬ ë¶„ì„**:
   ```bash
   go tool pprof http://localhost:8080/debug/pprof/heap
   ```

2. **ê³ ë£¨í‹´ ëˆ„ìˆ˜ í™•ì¸**:
   ```bash
   go tool pprof http://localhost:8080/debug/pprof/goroutine
   ```

3. **ë¦¬ì†ŒìŠ¤ í•´ì œ í™•ì¸**:
   ```go
   // íŒŒì¼, ì—°ê²° ë“± ë¦¬ì†ŒìŠ¤ ì ì ˆíˆ í•´ì œ
   defer file.Close()
   defer rows.Close()
   defer resp.Body.Close()
   ```

---

*ì´ ê°€ì´ë“œëŠ” ì§€ì†ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤. ì¶”ê°€ ì§ˆë¬¸ì´ë‚˜ ê°œì„  ì‚¬í•­ì´ ìˆìœ¼ë©´ GitHub Issuesë¥¼ í†µí•´ ì•Œë ¤ì£¼ì„¸ìš”.*